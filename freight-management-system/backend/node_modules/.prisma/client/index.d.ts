
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model CompanyProfile
 * 
 */
export type CompanyProfile = $Result.DefaultSelection<Prisma.$CompanyProfilePayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model PasswordResetToken
 * 
 */
export type PasswordResetToken = $Result.DefaultSelection<Prisma.$PasswordResetTokenPayload>
/**
 * Model TwoFactorChallenge
 * 
 */
export type TwoFactorChallenge = $Result.DefaultSelection<Prisma.$TwoFactorChallengePayload>
/**
 * Model UserConsent
 * 
 */
export type UserConsent = $Result.DefaultSelection<Prisma.$UserConsentPayload>
/**
 * Model Vendor
 * 
 */
export type Vendor = $Result.DefaultSelection<Prisma.$VendorPayload>
/**
 * Model VendorProfile
 * 
 */
export type VendorProfile = $Result.DefaultSelection<Prisma.$VendorProfilePayload>
/**
 * Model Driver
 * 
 */
export type Driver = $Result.DefaultSelection<Prisma.$DriverPayload>
/**
 * Model Agreement
 * 
 */
export type Agreement = $Result.DefaultSelection<Prisma.$AgreementPayload>
/**
 * Model RateCard
 * 
 */
export type RateCard = $Result.DefaultSelection<Prisma.$RateCardPayload>
/**
 * Model QuoteRequest
 * 
 */
export type QuoteRequest = $Result.DefaultSelection<Prisma.$QuoteRequestPayload>
/**
 * Model QuoteResponse
 * 
 */
export type QuoteResponse = $Result.DefaultSelection<Prisma.$QuoteResponsePayload>
/**
 * Model ConsentLog
 * 
 */
export type ConsentLog = $Result.DefaultSelection<Prisma.$ConsentLogPayload>
/**
 * Model Shipment
 * 
 */
export type Shipment = $Result.DefaultSelection<Prisma.$ShipmentPayload>
/**
 * Model StatusHistory
 * 
 */
export type StatusHistory = $Result.DefaultSelection<Prisma.$StatusHistoryPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model PaymentEvent
 * 
 */
export type PaymentEvent = $Result.DefaultSelection<Prisma.$PaymentEventPayload>
/**
 * Model TransporterInvoice
 * 
 */
export type TransporterInvoice = $Result.DefaultSelection<Prisma.$TransporterInvoicePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model ComplianceDocument
 * 
 */
export type ComplianceDocument = $Result.DefaultSelection<Prisma.$ComplianceDocumentPayload>
/**
 * Model ComplianceEvent
 * 
 */
export type ComplianceEvent = $Result.DefaultSelection<Prisma.$ComplianceEventPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  ADMIN: 'ADMIN',
  COMPANY_ADMIN: 'COMPANY_ADMIN',
  FINANCE_APPROVER: 'FINANCE_APPROVER',
  OPERATIONS: 'OPERATIONS',
  TRANSPORTER: 'TRANSPORTER',
  AGENT: 'AGENT',
  USER: 'USER'
};

export type Role = (typeof Role)[keyof typeof Role]


export const ApprovalStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type ApprovalStatus = (typeof ApprovalStatus)[keyof typeof ApprovalStatus]


export const ConsentStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  DECLINED: 'DECLINED',
  EXPIRED: 'EXPIRED'
};

export type ConsentStatus = (typeof ConsentStatus)[keyof typeof ConsentStatus]


export const QuoteStatus: {
  PENDING: 'PENDING',
  RESPONDED: 'RESPONDED',
  APPROVED: 'APPROVED',
  CLOSED: 'CLOSED'
};

export type QuoteStatus = (typeof QuoteStatus)[keyof typeof QuoteStatus]


export const QuoteResponseStatus: {
  PENDING: 'PENDING',
  RESPONDED: 'RESPONDED',
  APPROVED: 'APPROVED',
  DECLINED: 'DECLINED'
};

export type QuoteResponseStatus = (typeof QuoteResponseStatus)[keyof typeof QuoteResponseStatus]


export const ShipmentStatus: {
  PENDING: 'PENDING',
  PENDING_QUOTE: 'PENDING_QUOTE',
  QUOTE_SUBMITTED: 'QUOTE_SUBMITTED',
  QUOTE_APPROVED: 'QUOTE_APPROVED',
  REQUESTED: 'REQUESTED',
  ASSIGNED: 'ASSIGNED',
  ACCEPTED: 'ACCEPTED',
  PICKED_UP: 'PICKED_UP',
  IN_TRANSIT: 'IN_TRANSIT',
  DELIVERED: 'DELIVERED',
  CANCELLED: 'CANCELLED',
  REJECTED: 'REJECTED'
};

export type ShipmentStatus = (typeof ShipmentStatus)[keyof typeof ShipmentStatus]


export const BookingStatus: {
  PENDING_TRANSPORTER: 'PENDING_TRANSPORTER',
  CONFIRMED: 'CONFIRMED',
  DECLINED: 'DECLINED',
  EXPIRED: 'EXPIRED'
};

export type BookingStatus = (typeof BookingStatus)[keyof typeof BookingStatus]


export const PaymentStatus: {
  PENDING: 'PENDING',
  AUTHORIZED: 'AUTHORIZED',
  PAID: 'PAID',
  FAILED: 'FAILED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const ComplianceStatus: {
  PENDING: 'PENDING',
  SUBMITTED: 'SUBMITTED',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  EXEMPT: 'EXEMPT'
};

export type ComplianceStatus = (typeof ComplianceStatus)[keyof typeof ComplianceStatus]


export const InvoiceStatus: {
  DRAFT: 'DRAFT',
  ISSUED: 'ISSUED',
  PAID: 'PAID'
};

export type InvoiceStatus = (typeof InvoiceStatus)[keyof typeof InvoiceStatus]


export const DocumentType: {
  GST_INVOICE: 'GST_INVOICE',
  SELF_INVOICE_RCM: 'SELF_INVOICE_RCM',
  EWAY_BILL: 'EWAY_BILL',
  DRIVER_KYC: 'DRIVER_KYC',
  VEHICLE_KYC: 'VEHICLE_KYC',
  LORRY_RECEIPT: 'LORRY_RECEIPT'
};

export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type ApprovalStatus = $Enums.ApprovalStatus

export const ApprovalStatus: typeof $Enums.ApprovalStatus

export type ConsentStatus = $Enums.ConsentStatus

export const ConsentStatus: typeof $Enums.ConsentStatus

export type QuoteStatus = $Enums.QuoteStatus

export const QuoteStatus: typeof $Enums.QuoteStatus

export type QuoteResponseStatus = $Enums.QuoteResponseStatus

export const QuoteResponseStatus: typeof $Enums.QuoteResponseStatus

export type ShipmentStatus = $Enums.ShipmentStatus

export const ShipmentStatus: typeof $Enums.ShipmentStatus

export type BookingStatus = $Enums.BookingStatus

export const BookingStatus: typeof $Enums.BookingStatus

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type ComplianceStatus = $Enums.ComplianceStatus

export const ComplianceStatus: typeof $Enums.ComplianceStatus

export type InvoiceStatus = $Enums.InvoiceStatus

export const InvoiceStatus: typeof $Enums.InvoiceStatus

export type DocumentType = $Enums.DocumentType

export const DocumentType: typeof $Enums.DocumentType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Companies
 * const companies = await prisma.company.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Companies
   * const companies = await prisma.company.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs>;

  /**
   * `prisma.companyProfile`: Exposes CRUD operations for the **CompanyProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyProfiles
    * const companyProfiles = await prisma.companyProfile.findMany()
    * ```
    */
  get companyProfile(): Prisma.CompanyProfileDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.passwordResetToken`: Exposes CRUD operations for the **PasswordResetToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResetTokens
    * const passwordResetTokens = await prisma.passwordResetToken.findMany()
    * ```
    */
  get passwordResetToken(): Prisma.PasswordResetTokenDelegate<ExtArgs>;

  /**
   * `prisma.twoFactorChallenge`: Exposes CRUD operations for the **TwoFactorChallenge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwoFactorChallenges
    * const twoFactorChallenges = await prisma.twoFactorChallenge.findMany()
    * ```
    */
  get twoFactorChallenge(): Prisma.TwoFactorChallengeDelegate<ExtArgs>;

  /**
   * `prisma.userConsent`: Exposes CRUD operations for the **UserConsent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserConsents
    * const userConsents = await prisma.userConsent.findMany()
    * ```
    */
  get userConsent(): Prisma.UserConsentDelegate<ExtArgs>;

  /**
   * `prisma.vendor`: Exposes CRUD operations for the **Vendor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vendors
    * const vendors = await prisma.vendor.findMany()
    * ```
    */
  get vendor(): Prisma.VendorDelegate<ExtArgs>;

  /**
   * `prisma.vendorProfile`: Exposes CRUD operations for the **VendorProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VendorProfiles
    * const vendorProfiles = await prisma.vendorProfile.findMany()
    * ```
    */
  get vendorProfile(): Prisma.VendorProfileDelegate<ExtArgs>;

  /**
   * `prisma.driver`: Exposes CRUD operations for the **Driver** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Drivers
    * const drivers = await prisma.driver.findMany()
    * ```
    */
  get driver(): Prisma.DriverDelegate<ExtArgs>;

  /**
   * `prisma.agreement`: Exposes CRUD operations for the **Agreement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agreements
    * const agreements = await prisma.agreement.findMany()
    * ```
    */
  get agreement(): Prisma.AgreementDelegate<ExtArgs>;

  /**
   * `prisma.rateCard`: Exposes CRUD operations for the **RateCard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RateCards
    * const rateCards = await prisma.rateCard.findMany()
    * ```
    */
  get rateCard(): Prisma.RateCardDelegate<ExtArgs>;

  /**
   * `prisma.quoteRequest`: Exposes CRUD operations for the **QuoteRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuoteRequests
    * const quoteRequests = await prisma.quoteRequest.findMany()
    * ```
    */
  get quoteRequest(): Prisma.QuoteRequestDelegate<ExtArgs>;

  /**
   * `prisma.quoteResponse`: Exposes CRUD operations for the **QuoteResponse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuoteResponses
    * const quoteResponses = await prisma.quoteResponse.findMany()
    * ```
    */
  get quoteResponse(): Prisma.QuoteResponseDelegate<ExtArgs>;

  /**
   * `prisma.consentLog`: Exposes CRUD operations for the **ConsentLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConsentLogs
    * const consentLogs = await prisma.consentLog.findMany()
    * ```
    */
  get consentLog(): Prisma.ConsentLogDelegate<ExtArgs>;

  /**
   * `prisma.shipment`: Exposes CRUD operations for the **Shipment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shipments
    * const shipments = await prisma.shipment.findMany()
    * ```
    */
  get shipment(): Prisma.ShipmentDelegate<ExtArgs>;

  /**
   * `prisma.statusHistory`: Exposes CRUD operations for the **StatusHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StatusHistories
    * const statusHistories = await prisma.statusHistory.findMany()
    * ```
    */
  get statusHistory(): Prisma.StatusHistoryDelegate<ExtArgs>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;

  /**
   * `prisma.paymentEvent`: Exposes CRUD operations for the **PaymentEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentEvents
    * const paymentEvents = await prisma.paymentEvent.findMany()
    * ```
    */
  get paymentEvent(): Prisma.PaymentEventDelegate<ExtArgs>;

  /**
   * `prisma.transporterInvoice`: Exposes CRUD operations for the **TransporterInvoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransporterInvoices
    * const transporterInvoices = await prisma.transporterInvoice.findMany()
    * ```
    */
  get transporterInvoice(): Prisma.TransporterInvoiceDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.complianceDocument`: Exposes CRUD operations for the **ComplianceDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ComplianceDocuments
    * const complianceDocuments = await prisma.complianceDocument.findMany()
    * ```
    */
  get complianceDocument(): Prisma.ComplianceDocumentDelegate<ExtArgs>;

  /**
   * `prisma.complianceEvent`: Exposes CRUD operations for the **ComplianceEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ComplianceEvents
    * const complianceEvents = await prisma.complianceEvent.findMany()
    * ```
    */
  get complianceEvent(): Prisma.ComplianceEventDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Company: 'Company',
    CompanyProfile: 'CompanyProfile',
    User: 'User',
    PasswordResetToken: 'PasswordResetToken',
    TwoFactorChallenge: 'TwoFactorChallenge',
    UserConsent: 'UserConsent',
    Vendor: 'Vendor',
    VendorProfile: 'VendorProfile',
    Driver: 'Driver',
    Agreement: 'Agreement',
    RateCard: 'RateCard',
    QuoteRequest: 'QuoteRequest',
    QuoteResponse: 'QuoteResponse',
    ConsentLog: 'ConsentLog',
    Shipment: 'Shipment',
    StatusHistory: 'StatusHistory',
    Invoice: 'Invoice',
    Payment: 'Payment',
    PaymentEvent: 'PaymentEvent',
    TransporterInvoice: 'TransporterInvoice',
    Notification: 'Notification',
    AuditLog: 'AuditLog',
    ComplianceDocument: 'ComplianceDocument',
    ComplianceEvent: 'ComplianceEvent'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "company" | "companyProfile" | "user" | "passwordResetToken" | "twoFactorChallenge" | "userConsent" | "vendor" | "vendorProfile" | "driver" | "agreement" | "rateCard" | "quoteRequest" | "quoteResponse" | "consentLog" | "shipment" | "statusHistory" | "invoice" | "payment" | "paymentEvent" | "transporterInvoice" | "notification" | "auditLog" | "complianceDocument" | "complianceEvent"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      CompanyProfile: {
        payload: Prisma.$CompanyProfilePayload<ExtArgs>
        fields: Prisma.CompanyProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyProfilePayload>
          }
          findFirst: {
            args: Prisma.CompanyProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyProfilePayload>
          }
          findMany: {
            args: Prisma.CompanyProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyProfilePayload>[]
          }
          create: {
            args: Prisma.CompanyProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyProfilePayload>
          }
          createMany: {
            args: Prisma.CompanyProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyProfilePayload>[]
          }
          delete: {
            args: Prisma.CompanyProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyProfilePayload>
          }
          update: {
            args: Prisma.CompanyProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyProfilePayload>
          }
          deleteMany: {
            args: Prisma.CompanyProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyProfilePayload>
          }
          aggregate: {
            args: Prisma.CompanyProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyProfile>
          }
          groupBy: {
            args: Prisma.CompanyProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyProfileCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyProfileCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      PasswordResetToken: {
        payload: Prisma.$PasswordResetTokenPayload<ExtArgs>
        fields: Prisma.PasswordResetTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findMany: {
            args: Prisma.PasswordResetTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          create: {
            args: Prisma.PasswordResetTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          createMany: {
            args: Prisma.PasswordResetTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          delete: {
            args: Prisma.PasswordResetTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          update: {
            args: Prisma.PasswordResetTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PasswordResetTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordResetToken>
          }
          groupBy: {
            args: Prisma.PasswordResetTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetTokenCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenCountAggregateOutputType> | number
          }
        }
      }
      TwoFactorChallenge: {
        payload: Prisma.$TwoFactorChallengePayload<ExtArgs>
        fields: Prisma.TwoFactorChallengeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TwoFactorChallengeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorChallengePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TwoFactorChallengeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorChallengePayload>
          }
          findFirst: {
            args: Prisma.TwoFactorChallengeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorChallengePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TwoFactorChallengeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorChallengePayload>
          }
          findMany: {
            args: Prisma.TwoFactorChallengeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorChallengePayload>[]
          }
          create: {
            args: Prisma.TwoFactorChallengeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorChallengePayload>
          }
          createMany: {
            args: Prisma.TwoFactorChallengeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TwoFactorChallengeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorChallengePayload>[]
          }
          delete: {
            args: Prisma.TwoFactorChallengeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorChallengePayload>
          }
          update: {
            args: Prisma.TwoFactorChallengeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorChallengePayload>
          }
          deleteMany: {
            args: Prisma.TwoFactorChallengeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TwoFactorChallengeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TwoFactorChallengeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorChallengePayload>
          }
          aggregate: {
            args: Prisma.TwoFactorChallengeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTwoFactorChallenge>
          }
          groupBy: {
            args: Prisma.TwoFactorChallengeGroupByArgs<ExtArgs>
            result: $Utils.Optional<TwoFactorChallengeGroupByOutputType>[]
          }
          count: {
            args: Prisma.TwoFactorChallengeCountArgs<ExtArgs>
            result: $Utils.Optional<TwoFactorChallengeCountAggregateOutputType> | number
          }
        }
      }
      UserConsent: {
        payload: Prisma.$UserConsentPayload<ExtArgs>
        fields: Prisma.UserConsentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserConsentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserConsentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>
          }
          findFirst: {
            args: Prisma.UserConsentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserConsentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>
          }
          findMany: {
            args: Prisma.UserConsentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>[]
          }
          create: {
            args: Prisma.UserConsentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>
          }
          createMany: {
            args: Prisma.UserConsentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserConsentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>[]
          }
          delete: {
            args: Prisma.UserConsentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>
          }
          update: {
            args: Prisma.UserConsentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>
          }
          deleteMany: {
            args: Prisma.UserConsentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserConsentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserConsentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>
          }
          aggregate: {
            args: Prisma.UserConsentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserConsent>
          }
          groupBy: {
            args: Prisma.UserConsentGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserConsentGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserConsentCountArgs<ExtArgs>
            result: $Utils.Optional<UserConsentCountAggregateOutputType> | number
          }
        }
      }
      Vendor: {
        payload: Prisma.$VendorPayload<ExtArgs>
        fields: Prisma.VendorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          findFirst: {
            args: Prisma.VendorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          findMany: {
            args: Prisma.VendorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          create: {
            args: Prisma.VendorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          createMany: {
            args: Prisma.VendorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VendorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          delete: {
            args: Prisma.VendorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          update: {
            args: Prisma.VendorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          deleteMany: {
            args: Prisma.VendorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VendorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          aggregate: {
            args: Prisma.VendorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendor>
          }
          groupBy: {
            args: Prisma.VendorGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorCountArgs<ExtArgs>
            result: $Utils.Optional<VendorCountAggregateOutputType> | number
          }
        }
      }
      VendorProfile: {
        payload: Prisma.$VendorProfilePayload<ExtArgs>
        fields: Prisma.VendorProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorProfilePayload>
          }
          findFirst: {
            args: Prisma.VendorProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorProfilePayload>
          }
          findMany: {
            args: Prisma.VendorProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorProfilePayload>[]
          }
          create: {
            args: Prisma.VendorProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorProfilePayload>
          }
          createMany: {
            args: Prisma.VendorProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VendorProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorProfilePayload>[]
          }
          delete: {
            args: Prisma.VendorProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorProfilePayload>
          }
          update: {
            args: Prisma.VendorProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorProfilePayload>
          }
          deleteMany: {
            args: Prisma.VendorProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VendorProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorProfilePayload>
          }
          aggregate: {
            args: Prisma.VendorProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendorProfile>
          }
          groupBy: {
            args: Prisma.VendorProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorProfileCountArgs<ExtArgs>
            result: $Utils.Optional<VendorProfileCountAggregateOutputType> | number
          }
        }
      }
      Driver: {
        payload: Prisma.$DriverPayload<ExtArgs>
        fields: Prisma.DriverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DriverFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DriverFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          findFirst: {
            args: Prisma.DriverFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DriverFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          findMany: {
            args: Prisma.DriverFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>[]
          }
          create: {
            args: Prisma.DriverCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          createMany: {
            args: Prisma.DriverCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DriverCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>[]
          }
          delete: {
            args: Prisma.DriverDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          update: {
            args: Prisma.DriverUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          deleteMany: {
            args: Prisma.DriverDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DriverUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DriverUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          aggregate: {
            args: Prisma.DriverAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDriver>
          }
          groupBy: {
            args: Prisma.DriverGroupByArgs<ExtArgs>
            result: $Utils.Optional<DriverGroupByOutputType>[]
          }
          count: {
            args: Prisma.DriverCountArgs<ExtArgs>
            result: $Utils.Optional<DriverCountAggregateOutputType> | number
          }
        }
      }
      Agreement: {
        payload: Prisma.$AgreementPayload<ExtArgs>
        fields: Prisma.AgreementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgreementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgreementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementPayload>
          }
          findFirst: {
            args: Prisma.AgreementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgreementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementPayload>
          }
          findMany: {
            args: Prisma.AgreementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementPayload>[]
          }
          create: {
            args: Prisma.AgreementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementPayload>
          }
          createMany: {
            args: Prisma.AgreementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgreementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementPayload>[]
          }
          delete: {
            args: Prisma.AgreementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementPayload>
          }
          update: {
            args: Prisma.AgreementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementPayload>
          }
          deleteMany: {
            args: Prisma.AgreementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgreementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AgreementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementPayload>
          }
          aggregate: {
            args: Prisma.AgreementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgreement>
          }
          groupBy: {
            args: Prisma.AgreementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgreementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgreementCountArgs<ExtArgs>
            result: $Utils.Optional<AgreementCountAggregateOutputType> | number
          }
        }
      }
      RateCard: {
        payload: Prisma.$RateCardPayload<ExtArgs>
        fields: Prisma.RateCardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RateCardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateCardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RateCardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateCardPayload>
          }
          findFirst: {
            args: Prisma.RateCardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateCardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RateCardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateCardPayload>
          }
          findMany: {
            args: Prisma.RateCardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateCardPayload>[]
          }
          create: {
            args: Prisma.RateCardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateCardPayload>
          }
          createMany: {
            args: Prisma.RateCardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RateCardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateCardPayload>[]
          }
          delete: {
            args: Prisma.RateCardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateCardPayload>
          }
          update: {
            args: Prisma.RateCardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateCardPayload>
          }
          deleteMany: {
            args: Prisma.RateCardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RateCardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RateCardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateCardPayload>
          }
          aggregate: {
            args: Prisma.RateCardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRateCard>
          }
          groupBy: {
            args: Prisma.RateCardGroupByArgs<ExtArgs>
            result: $Utils.Optional<RateCardGroupByOutputType>[]
          }
          count: {
            args: Prisma.RateCardCountArgs<ExtArgs>
            result: $Utils.Optional<RateCardCountAggregateOutputType> | number
          }
        }
      }
      QuoteRequest: {
        payload: Prisma.$QuoteRequestPayload<ExtArgs>
        fields: Prisma.QuoteRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuoteRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuoteRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteRequestPayload>
          }
          findFirst: {
            args: Prisma.QuoteRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuoteRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteRequestPayload>
          }
          findMany: {
            args: Prisma.QuoteRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteRequestPayload>[]
          }
          create: {
            args: Prisma.QuoteRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteRequestPayload>
          }
          createMany: {
            args: Prisma.QuoteRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuoteRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteRequestPayload>[]
          }
          delete: {
            args: Prisma.QuoteRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteRequestPayload>
          }
          update: {
            args: Prisma.QuoteRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteRequestPayload>
          }
          deleteMany: {
            args: Prisma.QuoteRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuoteRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuoteRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteRequestPayload>
          }
          aggregate: {
            args: Prisma.QuoteRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuoteRequest>
          }
          groupBy: {
            args: Prisma.QuoteRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuoteRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuoteRequestCountArgs<ExtArgs>
            result: $Utils.Optional<QuoteRequestCountAggregateOutputType> | number
          }
        }
      }
      QuoteResponse: {
        payload: Prisma.$QuoteResponsePayload<ExtArgs>
        fields: Prisma.QuoteResponseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuoteResponseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteResponsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuoteResponseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteResponsePayload>
          }
          findFirst: {
            args: Prisma.QuoteResponseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteResponsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuoteResponseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteResponsePayload>
          }
          findMany: {
            args: Prisma.QuoteResponseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteResponsePayload>[]
          }
          create: {
            args: Prisma.QuoteResponseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteResponsePayload>
          }
          createMany: {
            args: Prisma.QuoteResponseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuoteResponseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteResponsePayload>[]
          }
          delete: {
            args: Prisma.QuoteResponseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteResponsePayload>
          }
          update: {
            args: Prisma.QuoteResponseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteResponsePayload>
          }
          deleteMany: {
            args: Prisma.QuoteResponseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuoteResponseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuoteResponseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteResponsePayload>
          }
          aggregate: {
            args: Prisma.QuoteResponseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuoteResponse>
          }
          groupBy: {
            args: Prisma.QuoteResponseGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuoteResponseGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuoteResponseCountArgs<ExtArgs>
            result: $Utils.Optional<QuoteResponseCountAggregateOutputType> | number
          }
        }
      }
      ConsentLog: {
        payload: Prisma.$ConsentLogPayload<ExtArgs>
        fields: Prisma.ConsentLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConsentLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConsentLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentLogPayload>
          }
          findFirst: {
            args: Prisma.ConsentLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConsentLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentLogPayload>
          }
          findMany: {
            args: Prisma.ConsentLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentLogPayload>[]
          }
          create: {
            args: Prisma.ConsentLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentLogPayload>
          }
          createMany: {
            args: Prisma.ConsentLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConsentLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentLogPayload>[]
          }
          delete: {
            args: Prisma.ConsentLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentLogPayload>
          }
          update: {
            args: Prisma.ConsentLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentLogPayload>
          }
          deleteMany: {
            args: Prisma.ConsentLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConsentLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConsentLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentLogPayload>
          }
          aggregate: {
            args: Prisma.ConsentLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConsentLog>
          }
          groupBy: {
            args: Prisma.ConsentLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConsentLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConsentLogCountArgs<ExtArgs>
            result: $Utils.Optional<ConsentLogCountAggregateOutputType> | number
          }
        }
      }
      Shipment: {
        payload: Prisma.$ShipmentPayload<ExtArgs>
        fields: Prisma.ShipmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShipmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShipmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>
          }
          findFirst: {
            args: Prisma.ShipmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShipmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>
          }
          findMany: {
            args: Prisma.ShipmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>[]
          }
          create: {
            args: Prisma.ShipmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>
          }
          createMany: {
            args: Prisma.ShipmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShipmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>[]
          }
          delete: {
            args: Prisma.ShipmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>
          }
          update: {
            args: Prisma.ShipmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>
          }
          deleteMany: {
            args: Prisma.ShipmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShipmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShipmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>
          }
          aggregate: {
            args: Prisma.ShipmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShipment>
          }
          groupBy: {
            args: Prisma.ShipmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShipmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShipmentCountArgs<ExtArgs>
            result: $Utils.Optional<ShipmentCountAggregateOutputType> | number
          }
        }
      }
      StatusHistory: {
        payload: Prisma.$StatusHistoryPayload<ExtArgs>
        fields: Prisma.StatusHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StatusHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StatusHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusHistoryPayload>
          }
          findFirst: {
            args: Prisma.StatusHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StatusHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusHistoryPayload>
          }
          findMany: {
            args: Prisma.StatusHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusHistoryPayload>[]
          }
          create: {
            args: Prisma.StatusHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusHistoryPayload>
          }
          createMany: {
            args: Prisma.StatusHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StatusHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusHistoryPayload>[]
          }
          delete: {
            args: Prisma.StatusHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusHistoryPayload>
          }
          update: {
            args: Prisma.StatusHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusHistoryPayload>
          }
          deleteMany: {
            args: Prisma.StatusHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StatusHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StatusHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusHistoryPayload>
          }
          aggregate: {
            args: Prisma.StatusHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStatusHistory>
          }
          groupBy: {
            args: Prisma.StatusHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<StatusHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.StatusHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<StatusHistoryCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      PaymentEvent: {
        payload: Prisma.$PaymentEventPayload<ExtArgs>
        fields: Prisma.PaymentEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentEventPayload>
          }
          findFirst: {
            args: Prisma.PaymentEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentEventPayload>
          }
          findMany: {
            args: Prisma.PaymentEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentEventPayload>[]
          }
          create: {
            args: Prisma.PaymentEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentEventPayload>
          }
          createMany: {
            args: Prisma.PaymentEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentEventPayload>[]
          }
          delete: {
            args: Prisma.PaymentEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentEventPayload>
          }
          update: {
            args: Prisma.PaymentEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentEventPayload>
          }
          deleteMany: {
            args: Prisma.PaymentEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentEventPayload>
          }
          aggregate: {
            args: Prisma.PaymentEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentEvent>
          }
          groupBy: {
            args: Prisma.PaymentEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentEventCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentEventCountAggregateOutputType> | number
          }
        }
      }
      TransporterInvoice: {
        payload: Prisma.$TransporterInvoicePayload<ExtArgs>
        fields: Prisma.TransporterInvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransporterInvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransporterInvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransporterInvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransporterInvoicePayload>
          }
          findFirst: {
            args: Prisma.TransporterInvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransporterInvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransporterInvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransporterInvoicePayload>
          }
          findMany: {
            args: Prisma.TransporterInvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransporterInvoicePayload>[]
          }
          create: {
            args: Prisma.TransporterInvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransporterInvoicePayload>
          }
          createMany: {
            args: Prisma.TransporterInvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransporterInvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransporterInvoicePayload>[]
          }
          delete: {
            args: Prisma.TransporterInvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransporterInvoicePayload>
          }
          update: {
            args: Prisma.TransporterInvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransporterInvoicePayload>
          }
          deleteMany: {
            args: Prisma.TransporterInvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransporterInvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransporterInvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransporterInvoicePayload>
          }
          aggregate: {
            args: Prisma.TransporterInvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransporterInvoice>
          }
          groupBy: {
            args: Prisma.TransporterInvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransporterInvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransporterInvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<TransporterInvoiceCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      ComplianceDocument: {
        payload: Prisma.$ComplianceDocumentPayload<ExtArgs>
        fields: Prisma.ComplianceDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComplianceDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComplianceDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceDocumentPayload>
          }
          findFirst: {
            args: Prisma.ComplianceDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComplianceDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceDocumentPayload>
          }
          findMany: {
            args: Prisma.ComplianceDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceDocumentPayload>[]
          }
          create: {
            args: Prisma.ComplianceDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceDocumentPayload>
          }
          createMany: {
            args: Prisma.ComplianceDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComplianceDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceDocumentPayload>[]
          }
          delete: {
            args: Prisma.ComplianceDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceDocumentPayload>
          }
          update: {
            args: Prisma.ComplianceDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceDocumentPayload>
          }
          deleteMany: {
            args: Prisma.ComplianceDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComplianceDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ComplianceDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceDocumentPayload>
          }
          aggregate: {
            args: Prisma.ComplianceDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComplianceDocument>
          }
          groupBy: {
            args: Prisma.ComplianceDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComplianceDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComplianceDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<ComplianceDocumentCountAggregateOutputType> | number
          }
        }
      }
      ComplianceEvent: {
        payload: Prisma.$ComplianceEventPayload<ExtArgs>
        fields: Prisma.ComplianceEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComplianceEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComplianceEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceEventPayload>
          }
          findFirst: {
            args: Prisma.ComplianceEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComplianceEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceEventPayload>
          }
          findMany: {
            args: Prisma.ComplianceEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceEventPayload>[]
          }
          create: {
            args: Prisma.ComplianceEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceEventPayload>
          }
          createMany: {
            args: Prisma.ComplianceEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComplianceEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceEventPayload>[]
          }
          delete: {
            args: Prisma.ComplianceEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceEventPayload>
          }
          update: {
            args: Prisma.ComplianceEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceEventPayload>
          }
          deleteMany: {
            args: Prisma.ComplianceEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComplianceEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ComplianceEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceEventPayload>
          }
          aggregate: {
            args: Prisma.ComplianceEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComplianceEvent>
          }
          groupBy: {
            args: Prisma.ComplianceEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComplianceEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComplianceEventCountArgs<ExtArgs>
            result: $Utils.Optional<ComplianceEventCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    users: number
    shipments: number
    agreements: number
    transporterInvoices: number
    invoices: number
    profiles: number
    vendors: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | CompanyCountOutputTypeCountUsersArgs
    shipments?: boolean | CompanyCountOutputTypeCountShipmentsArgs
    agreements?: boolean | CompanyCountOutputTypeCountAgreementsArgs
    transporterInvoices?: boolean | CompanyCountOutputTypeCountTransporterInvoicesArgs
    invoices?: boolean | CompanyCountOutputTypeCountInvoicesArgs
    profiles?: boolean | CompanyCountOutputTypeCountProfilesArgs
    vendors?: boolean | CompanyCountOutputTypeCountVendorsArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountShipmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShipmentWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountAgreementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgreementWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountTransporterInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransporterInvoiceWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyProfileWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountVendorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    shipments: number
    assignedShipments: number
    notifications: number
    auditLogs: number
    agreementsReviewed: number
    transporterInvoices: number
    QuoteRequest: number
    passwordResetTokens: number
    twoFactorChallenges: number
    userConsents: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shipments?: boolean | UserCountOutputTypeCountShipmentsArgs
    assignedShipments?: boolean | UserCountOutputTypeCountAssignedShipmentsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    agreementsReviewed?: boolean | UserCountOutputTypeCountAgreementsReviewedArgs
    transporterInvoices?: boolean | UserCountOutputTypeCountTransporterInvoicesArgs
    QuoteRequest?: boolean | UserCountOutputTypeCountQuoteRequestArgs
    passwordResetTokens?: boolean | UserCountOutputTypeCountPasswordResetTokensArgs
    twoFactorChallenges?: boolean | UserCountOutputTypeCountTwoFactorChallengesArgs
    userConsents?: boolean | UserCountOutputTypeCountUserConsentsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountShipmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShipmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedShipmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShipmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAgreementsReviewedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgreementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransporterInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransporterInvoiceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQuoteRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPasswordResetTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTwoFactorChallengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TwoFactorChallengeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserConsentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserConsentWhereInput
  }


  /**
   * Count Type VendorCountOutputType
   */

  export type VendorCountOutputType = {
    agreements: number
    rateCards: number
    quoteResponses: number
    shipments: number
    drivers: number
    User: number
  }

  export type VendorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agreements?: boolean | VendorCountOutputTypeCountAgreementsArgs
    rateCards?: boolean | VendorCountOutputTypeCountRateCardsArgs
    quoteResponses?: boolean | VendorCountOutputTypeCountQuoteResponsesArgs
    shipments?: boolean | VendorCountOutputTypeCountShipmentsArgs
    drivers?: boolean | VendorCountOutputTypeCountDriversArgs
    User?: boolean | VendorCountOutputTypeCountUserArgs
  }

  // Custom InputTypes
  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorCountOutputType
     */
    select?: VendorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountAgreementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgreementWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountRateCardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RateCardWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountQuoteResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteResponseWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountShipmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShipmentWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountDriversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriverWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type AgreementCountOutputType
   */

  export type AgreementCountOutputType = {
    rateCards: number
  }

  export type AgreementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rateCards?: boolean | AgreementCountOutputTypeCountRateCardsArgs
  }

  // Custom InputTypes
  /**
   * AgreementCountOutputType without action
   */
  export type AgreementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementCountOutputType
     */
    select?: AgreementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgreementCountOutputType without action
   */
  export type AgreementCountOutputTypeCountRateCardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RateCardWhereInput
  }


  /**
   * Count Type RateCardCountOutputType
   */

  export type RateCardCountOutputType = {
    shipments: number
  }

  export type RateCardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shipments?: boolean | RateCardCountOutputTypeCountShipmentsArgs
  }

  // Custom InputTypes
  /**
   * RateCardCountOutputType without action
   */
  export type RateCardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateCardCountOutputType
     */
    select?: RateCardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RateCardCountOutputType without action
   */
  export type RateCardCountOutputTypeCountShipmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShipmentWhereInput
  }


  /**
   * Count Type QuoteRequestCountOutputType
   */

  export type QuoteRequestCountOutputType = {
    responses: number
  }

  export type QuoteRequestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responses?: boolean | QuoteRequestCountOutputTypeCountResponsesArgs
  }

  // Custom InputTypes
  /**
   * QuoteRequestCountOutputType without action
   */
  export type QuoteRequestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteRequestCountOutputType
     */
    select?: QuoteRequestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuoteRequestCountOutputType without action
   */
  export type QuoteRequestCountOutputTypeCountResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteResponseWhereInput
  }


  /**
   * Count Type QuoteResponseCountOutputType
   */

  export type QuoteResponseCountOutputType = {
    consentLogs: number
  }

  export type QuoteResponseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consentLogs?: boolean | QuoteResponseCountOutputTypeCountConsentLogsArgs
  }

  // Custom InputTypes
  /**
   * QuoteResponseCountOutputType without action
   */
  export type QuoteResponseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteResponseCountOutputType
     */
    select?: QuoteResponseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuoteResponseCountOutputType without action
   */
  export type QuoteResponseCountOutputTypeCountConsentLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsentLogWhereInput
  }


  /**
   * Count Type ShipmentCountOutputType
   */

  export type ShipmentCountOutputType = {
    statusHistory: number
    complianceDocs: number
    payments: number
    consentLogs: number
    transporterInvoices: number
  }

  export type ShipmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    statusHistory?: boolean | ShipmentCountOutputTypeCountStatusHistoryArgs
    complianceDocs?: boolean | ShipmentCountOutputTypeCountComplianceDocsArgs
    payments?: boolean | ShipmentCountOutputTypeCountPaymentsArgs
    consentLogs?: boolean | ShipmentCountOutputTypeCountConsentLogsArgs
    transporterInvoices?: boolean | ShipmentCountOutputTypeCountTransporterInvoicesArgs
  }

  // Custom InputTypes
  /**
   * ShipmentCountOutputType without action
   */
  export type ShipmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentCountOutputType
     */
    select?: ShipmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShipmentCountOutputType without action
   */
  export type ShipmentCountOutputTypeCountStatusHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StatusHistoryWhereInput
  }

  /**
   * ShipmentCountOutputType without action
   */
  export type ShipmentCountOutputTypeCountComplianceDocsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplianceDocumentWhereInput
  }

  /**
   * ShipmentCountOutputType without action
   */
  export type ShipmentCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * ShipmentCountOutputType without action
   */
  export type ShipmentCountOutputTypeCountConsentLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsentLogWhereInput
  }

  /**
   * ShipmentCountOutputType without action
   */
  export type ShipmentCountOutputTypeCountTransporterInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransporterInvoiceWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    payments: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | InvoiceCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type PaymentCountOutputType
   */

  export type PaymentCountOutputType = {
    events: number
  }

  export type PaymentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | PaymentCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentCountOutputType
     */
    select?: PaymentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentEventWhereInput
  }


  /**
   * Count Type ComplianceDocumentCountOutputType
   */

  export type ComplianceDocumentCountOutputType = {
    events: number
  }

  export type ComplianceDocumentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | ComplianceDocumentCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * ComplianceDocumentCountOutputType without action
   */
  export type ComplianceDocumentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceDocumentCountOutputType
     */
    select?: ComplianceDocumentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ComplianceDocumentCountOutputType without action
   */
  export type ComplianceDocumentCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplianceEventWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyAvgAggregateOutputType = {
    id: number | null
  }

  export type CompanySumAggregateOutputType = {
    id: number | null
  }

  export type CompanyMinAggregateOutputType = {
    id: number | null
    name: string | null
    webhookSecret: string | null
    plan: string | null
    subscriptionStatus: string | null
    billingEmail: string | null
    billingCustomerId: string | null
    trialEndsAt: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: number | null
    name: string | null
    webhookSecret: string | null
    plan: string | null
    subscriptionStatus: string | null
    billingEmail: string | null
    billingCustomerId: string | null
    trialEndsAt: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    name: number
    webhookSecret: number
    plan: number
    subscriptionStatus: number
    billingEmail: number
    billingCustomerId: number
    trialEndsAt: number
    settings: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyAvgAggregateInputType = {
    id?: true
  }

  export type CompanySumAggregateInputType = {
    id?: true
  }

  export type CompanyMinAggregateInputType = {
    id?: true
    name?: true
    webhookSecret?: true
    plan?: true
    subscriptionStatus?: true
    billingEmail?: true
    billingCustomerId?: true
    trialEndsAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    name?: true
    webhookSecret?: true
    plan?: true
    subscriptionStatus?: true
    billingEmail?: true
    billingCustomerId?: true
    trialEndsAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    name?: true
    webhookSecret?: true
    plan?: true
    subscriptionStatus?: true
    billingEmail?: true
    billingCustomerId?: true
    trialEndsAt?: true
    settings?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _avg?: CompanyAvgAggregateInputType
    _sum?: CompanySumAggregateInputType
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: number
    name: string
    webhookSecret: string
    plan: string
    subscriptionStatus: string
    billingEmail: string | null
    billingCustomerId: string | null
    trialEndsAt: Date | null
    settings: JsonValue | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    webhookSecret?: boolean
    plan?: boolean
    subscriptionStatus?: boolean
    billingEmail?: boolean
    billingCustomerId?: boolean
    trialEndsAt?: boolean
    settings?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Company$usersArgs<ExtArgs>
    shipments?: boolean | Company$shipmentsArgs<ExtArgs>
    agreements?: boolean | Company$agreementsArgs<ExtArgs>
    transporterInvoices?: boolean | Company$transporterInvoicesArgs<ExtArgs>
    invoices?: boolean | Company$invoicesArgs<ExtArgs>
    profiles?: boolean | Company$profilesArgs<ExtArgs>
    vendors?: boolean | Company$vendorsArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    webhookSecret?: boolean
    plan?: boolean
    subscriptionStatus?: boolean
    billingEmail?: boolean
    billingCustomerId?: boolean
    trialEndsAt?: boolean
    settings?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectScalar = {
    id?: boolean
    name?: boolean
    webhookSecret?: boolean
    plan?: boolean
    subscriptionStatus?: boolean
    billingEmail?: boolean
    billingCustomerId?: boolean
    trialEndsAt?: boolean
    settings?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Company$usersArgs<ExtArgs>
    shipments?: boolean | Company$shipmentsArgs<ExtArgs>
    agreements?: boolean | Company$agreementsArgs<ExtArgs>
    transporterInvoices?: boolean | Company$transporterInvoicesArgs<ExtArgs>
    invoices?: boolean | Company$invoicesArgs<ExtArgs>
    profiles?: boolean | Company$profilesArgs<ExtArgs>
    vendors?: boolean | Company$vendorsArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      shipments: Prisma.$ShipmentPayload<ExtArgs>[]
      agreements: Prisma.$AgreementPayload<ExtArgs>[]
      transporterInvoices: Prisma.$TransporterInvoicePayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      profiles: Prisma.$CompanyProfilePayload<ExtArgs>[]
      vendors: Prisma.$VendorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      webhookSecret: string
      plan: string
      subscriptionStatus: string
      billingEmail: string | null
      billingCustomerId: string | null
      trialEndsAt: Date | null
      settings: Prisma.JsonValue | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {CompanyCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Company$usersArgs<ExtArgs> = {}>(args?: Subset<T, Company$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    shipments<T extends Company$shipmentsArgs<ExtArgs> = {}>(args?: Subset<T, Company$shipmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findMany"> | Null>
    agreements<T extends Company$agreementsArgs<ExtArgs> = {}>(args?: Subset<T, Company$agreementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgreementPayload<ExtArgs>, T, "findMany"> | Null>
    transporterInvoices<T extends Company$transporterInvoicesArgs<ExtArgs> = {}>(args?: Subset<T, Company$transporterInvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransporterInvoicePayload<ExtArgs>, T, "findMany"> | Null>
    invoices<T extends Company$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Company$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    profiles<T extends Company$profilesArgs<ExtArgs> = {}>(args?: Subset<T, Company$profilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyProfilePayload<ExtArgs>, T, "findMany"> | Null>
    vendors<T extends Company$vendorsArgs<ExtArgs> = {}>(args?: Subset<T, Company$vendorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */ 
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'Int'>
    readonly name: FieldRef<"Company", 'String'>
    readonly webhookSecret: FieldRef<"Company", 'String'>
    readonly plan: FieldRef<"Company", 'String'>
    readonly subscriptionStatus: FieldRef<"Company", 'String'>
    readonly billingEmail: FieldRef<"Company", 'String'>
    readonly billingCustomerId: FieldRef<"Company", 'String'>
    readonly trialEndsAt: FieldRef<"Company", 'DateTime'>
    readonly settings: FieldRef<"Company", 'Json'>
    readonly status: FieldRef<"Company", 'String'>
    readonly createdAt: FieldRef<"Company", 'DateTime'>
    readonly updatedAt: FieldRef<"Company", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company createManyAndReturn
   */
  export type CompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
  }

  /**
   * Company.users
   */
  export type Company$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Company.shipments
   */
  export type Company$shipmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    where?: ShipmentWhereInput
    orderBy?: ShipmentOrderByWithRelationInput | ShipmentOrderByWithRelationInput[]
    cursor?: ShipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShipmentScalarFieldEnum | ShipmentScalarFieldEnum[]
  }

  /**
   * Company.agreements
   */
  export type Company$agreementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementInclude<ExtArgs> | null
    where?: AgreementWhereInput
    orderBy?: AgreementOrderByWithRelationInput | AgreementOrderByWithRelationInput[]
    cursor?: AgreementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgreementScalarFieldEnum | AgreementScalarFieldEnum[]
  }

  /**
   * Company.transporterInvoices
   */
  export type Company$transporterInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransporterInvoice
     */
    select?: TransporterInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransporterInvoiceInclude<ExtArgs> | null
    where?: TransporterInvoiceWhereInput
    orderBy?: TransporterInvoiceOrderByWithRelationInput | TransporterInvoiceOrderByWithRelationInput[]
    cursor?: TransporterInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransporterInvoiceScalarFieldEnum | TransporterInvoiceScalarFieldEnum[]
  }

  /**
   * Company.invoices
   */
  export type Company$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Company.profiles
   */
  export type Company$profilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProfile
     */
    select?: CompanyProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyProfileInclude<ExtArgs> | null
    where?: CompanyProfileWhereInput
    orderBy?: CompanyProfileOrderByWithRelationInput | CompanyProfileOrderByWithRelationInput[]
    cursor?: CompanyProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyProfileScalarFieldEnum | CompanyProfileScalarFieldEnum[]
  }

  /**
   * Company.vendors
   */
  export type Company$vendorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    where?: VendorWhereInput
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    cursor?: VendorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
  }


  /**
   * Model CompanyProfile
   */

  export type AggregateCompanyProfile = {
    _count: CompanyProfileCountAggregateOutputType | null
    _avg: CompanyProfileAvgAggregateOutputType | null
    _sum: CompanyProfileSumAggregateOutputType | null
    _min: CompanyProfileMinAggregateOutputType | null
    _max: CompanyProfileMaxAggregateOutputType | null
  }

  export type CompanyProfileAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
  }

  export type CompanyProfileSumAggregateOutputType = {
    id: number | null
    companyId: number | null
  }

  export type CompanyProfileMinAggregateOutputType = {
    id: number | null
    companyId: number | null
    legalName: string | null
    gstin: string | null
    pan: string | null
    tan: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyProfileMaxAggregateOutputType = {
    id: number | null
    companyId: number | null
    legalName: string | null
    gstin: string | null
    pan: string | null
    tan: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyProfileCountAggregateOutputType = {
    id: number
    companyId: number
    legalName: number
    gstin: number
    pan: number
    tan: number
    addressLine1: number
    addressLine2: number
    city: number
    state: number
    postalCode: number
    country: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyProfileAvgAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type CompanyProfileSumAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type CompanyProfileMinAggregateInputType = {
    id?: true
    companyId?: true
    legalName?: true
    gstin?: true
    pan?: true
    tan?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyProfileMaxAggregateInputType = {
    id?: true
    companyId?: true
    legalName?: true
    gstin?: true
    pan?: true
    tan?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyProfileCountAggregateInputType = {
    id?: true
    companyId?: true
    legalName?: true
    gstin?: true
    pan?: true
    tan?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyProfile to aggregate.
     */
    where?: CompanyProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyProfiles to fetch.
     */
    orderBy?: CompanyProfileOrderByWithRelationInput | CompanyProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyProfiles
    **/
    _count?: true | CompanyProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanyProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyProfileMaxAggregateInputType
  }

  export type GetCompanyProfileAggregateType<T extends CompanyProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyProfile[P]>
      : GetScalarType<T[P], AggregateCompanyProfile[P]>
  }




  export type CompanyProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyProfileWhereInput
    orderBy?: CompanyProfileOrderByWithAggregationInput | CompanyProfileOrderByWithAggregationInput[]
    by: CompanyProfileScalarFieldEnum[] | CompanyProfileScalarFieldEnum
    having?: CompanyProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyProfileCountAggregateInputType | true
    _avg?: CompanyProfileAvgAggregateInputType
    _sum?: CompanyProfileSumAggregateInputType
    _min?: CompanyProfileMinAggregateInputType
    _max?: CompanyProfileMaxAggregateInputType
  }

  export type CompanyProfileGroupByOutputType = {
    id: number
    companyId: number | null
    legalName: string | null
    gstin: string | null
    pan: string | null
    tan: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    createdAt: Date
    updatedAt: Date
    _count: CompanyProfileCountAggregateOutputType | null
    _avg: CompanyProfileAvgAggregateOutputType | null
    _sum: CompanyProfileSumAggregateOutputType | null
    _min: CompanyProfileMinAggregateOutputType | null
    _max: CompanyProfileMaxAggregateOutputType | null
  }

  type GetCompanyProfileGroupByPayload<T extends CompanyProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyProfileGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyProfileGroupByOutputType[P]>
        }
      >
    >


  export type CompanyProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    legalName?: boolean
    gstin?: boolean
    pan?: boolean
    tan?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyProfile$companyArgs<ExtArgs>
  }, ExtArgs["result"]["companyProfile"]>

  export type CompanyProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    legalName?: boolean
    gstin?: boolean
    pan?: boolean
    tan?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyProfile$companyArgs<ExtArgs>
  }, ExtArgs["result"]["companyProfile"]>

  export type CompanyProfileSelectScalar = {
    id?: boolean
    companyId?: boolean
    legalName?: boolean
    gstin?: boolean
    pan?: boolean
    tan?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompanyProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyProfile$companyArgs<ExtArgs>
  }
  export type CompanyProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyProfile$companyArgs<ExtArgs>
  }

  export type $CompanyProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyProfile"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      companyId: number | null
      legalName: string | null
      gstin: string | null
      pan: string | null
      tan: string | null
      addressLine1: string | null
      addressLine2: string | null
      city: string | null
      state: string | null
      postalCode: string | null
      country: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["companyProfile"]>
    composites: {}
  }

  type CompanyProfileGetPayload<S extends boolean | null | undefined | CompanyProfileDefaultArgs> = $Result.GetResult<Prisma.$CompanyProfilePayload, S>

  type CompanyProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompanyProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompanyProfileCountAggregateInputType | true
    }

  export interface CompanyProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyProfile'], meta: { name: 'CompanyProfile' } }
    /**
     * Find zero or one CompanyProfile that matches the filter.
     * @param {CompanyProfileFindUniqueArgs} args - Arguments to find a CompanyProfile
     * @example
     * // Get one CompanyProfile
     * const companyProfile = await prisma.companyProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyProfileFindUniqueArgs>(args: SelectSubset<T, CompanyProfileFindUniqueArgs<ExtArgs>>): Prisma__CompanyProfileClient<$Result.GetResult<Prisma.$CompanyProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CompanyProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompanyProfileFindUniqueOrThrowArgs} args - Arguments to find a CompanyProfile
     * @example
     * // Get one CompanyProfile
     * const companyProfile = await prisma.companyProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyProfileClient<$Result.GetResult<Prisma.$CompanyProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CompanyProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyProfileFindFirstArgs} args - Arguments to find a CompanyProfile
     * @example
     * // Get one CompanyProfile
     * const companyProfile = await prisma.companyProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyProfileFindFirstArgs>(args?: SelectSubset<T, CompanyProfileFindFirstArgs<ExtArgs>>): Prisma__CompanyProfileClient<$Result.GetResult<Prisma.$CompanyProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CompanyProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyProfileFindFirstOrThrowArgs} args - Arguments to find a CompanyProfile
     * @example
     * // Get one CompanyProfile
     * const companyProfile = await prisma.companyProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyProfileClient<$Result.GetResult<Prisma.$CompanyProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CompanyProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyProfiles
     * const companyProfiles = await prisma.companyProfile.findMany()
     * 
     * // Get first 10 CompanyProfiles
     * const companyProfiles = await prisma.companyProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyProfileWithIdOnly = await prisma.companyProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyProfileFindManyArgs>(args?: SelectSubset<T, CompanyProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CompanyProfile.
     * @param {CompanyProfileCreateArgs} args - Arguments to create a CompanyProfile.
     * @example
     * // Create one CompanyProfile
     * const CompanyProfile = await prisma.companyProfile.create({
     *   data: {
     *     // ... data to create a CompanyProfile
     *   }
     * })
     * 
     */
    create<T extends CompanyProfileCreateArgs>(args: SelectSubset<T, CompanyProfileCreateArgs<ExtArgs>>): Prisma__CompanyProfileClient<$Result.GetResult<Prisma.$CompanyProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CompanyProfiles.
     * @param {CompanyProfileCreateManyArgs} args - Arguments to create many CompanyProfiles.
     * @example
     * // Create many CompanyProfiles
     * const companyProfile = await prisma.companyProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyProfileCreateManyArgs>(args?: SelectSubset<T, CompanyProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanyProfiles and returns the data saved in the database.
     * @param {CompanyProfileCreateManyAndReturnArgs} args - Arguments to create many CompanyProfiles.
     * @example
     * // Create many CompanyProfiles
     * const companyProfile = await prisma.companyProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanyProfiles and only return the `id`
     * const companyProfileWithIdOnly = await prisma.companyProfile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CompanyProfile.
     * @param {CompanyProfileDeleteArgs} args - Arguments to delete one CompanyProfile.
     * @example
     * // Delete one CompanyProfile
     * const CompanyProfile = await prisma.companyProfile.delete({
     *   where: {
     *     // ... filter to delete one CompanyProfile
     *   }
     * })
     * 
     */
    delete<T extends CompanyProfileDeleteArgs>(args: SelectSubset<T, CompanyProfileDeleteArgs<ExtArgs>>): Prisma__CompanyProfileClient<$Result.GetResult<Prisma.$CompanyProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CompanyProfile.
     * @param {CompanyProfileUpdateArgs} args - Arguments to update one CompanyProfile.
     * @example
     * // Update one CompanyProfile
     * const companyProfile = await prisma.companyProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyProfileUpdateArgs>(args: SelectSubset<T, CompanyProfileUpdateArgs<ExtArgs>>): Prisma__CompanyProfileClient<$Result.GetResult<Prisma.$CompanyProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CompanyProfiles.
     * @param {CompanyProfileDeleteManyArgs} args - Arguments to filter CompanyProfiles to delete.
     * @example
     * // Delete a few CompanyProfiles
     * const { count } = await prisma.companyProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyProfileDeleteManyArgs>(args?: SelectSubset<T, CompanyProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyProfiles
     * const companyProfile = await prisma.companyProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyProfileUpdateManyArgs>(args: SelectSubset<T, CompanyProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompanyProfile.
     * @param {CompanyProfileUpsertArgs} args - Arguments to update or create a CompanyProfile.
     * @example
     * // Update or create a CompanyProfile
     * const companyProfile = await prisma.companyProfile.upsert({
     *   create: {
     *     // ... data to create a CompanyProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyProfile we want to update
     *   }
     * })
     */
    upsert<T extends CompanyProfileUpsertArgs>(args: SelectSubset<T, CompanyProfileUpsertArgs<ExtArgs>>): Prisma__CompanyProfileClient<$Result.GetResult<Prisma.$CompanyProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CompanyProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyProfileCountArgs} args - Arguments to filter CompanyProfiles to count.
     * @example
     * // Count the number of CompanyProfiles
     * const count = await prisma.companyProfile.count({
     *   where: {
     *     // ... the filter for the CompanyProfiles we want to count
     *   }
     * })
    **/
    count<T extends CompanyProfileCountArgs>(
      args?: Subset<T, CompanyProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyProfileAggregateArgs>(args: Subset<T, CompanyProfileAggregateArgs>): Prisma.PrismaPromise<GetCompanyProfileAggregateType<T>>

    /**
     * Group by CompanyProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyProfileGroupByArgs['orderBy'] }
        : { orderBy?: CompanyProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyProfile model
   */
  readonly fields: CompanyProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyProfile$companyArgs<ExtArgs> = {}>(args?: Subset<T, CompanyProfile$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyProfile model
   */ 
  interface CompanyProfileFieldRefs {
    readonly id: FieldRef<"CompanyProfile", 'Int'>
    readonly companyId: FieldRef<"CompanyProfile", 'Int'>
    readonly legalName: FieldRef<"CompanyProfile", 'String'>
    readonly gstin: FieldRef<"CompanyProfile", 'String'>
    readonly pan: FieldRef<"CompanyProfile", 'String'>
    readonly tan: FieldRef<"CompanyProfile", 'String'>
    readonly addressLine1: FieldRef<"CompanyProfile", 'String'>
    readonly addressLine2: FieldRef<"CompanyProfile", 'String'>
    readonly city: FieldRef<"CompanyProfile", 'String'>
    readonly state: FieldRef<"CompanyProfile", 'String'>
    readonly postalCode: FieldRef<"CompanyProfile", 'String'>
    readonly country: FieldRef<"CompanyProfile", 'String'>
    readonly createdAt: FieldRef<"CompanyProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"CompanyProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanyProfile findUnique
   */
  export type CompanyProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProfile
     */
    select?: CompanyProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyProfileInclude<ExtArgs> | null
    /**
     * Filter, which CompanyProfile to fetch.
     */
    where: CompanyProfileWhereUniqueInput
  }

  /**
   * CompanyProfile findUniqueOrThrow
   */
  export type CompanyProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProfile
     */
    select?: CompanyProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyProfileInclude<ExtArgs> | null
    /**
     * Filter, which CompanyProfile to fetch.
     */
    where: CompanyProfileWhereUniqueInput
  }

  /**
   * CompanyProfile findFirst
   */
  export type CompanyProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProfile
     */
    select?: CompanyProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyProfileInclude<ExtArgs> | null
    /**
     * Filter, which CompanyProfile to fetch.
     */
    where?: CompanyProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyProfiles to fetch.
     */
    orderBy?: CompanyProfileOrderByWithRelationInput | CompanyProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyProfiles.
     */
    cursor?: CompanyProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyProfiles.
     */
    distinct?: CompanyProfileScalarFieldEnum | CompanyProfileScalarFieldEnum[]
  }

  /**
   * CompanyProfile findFirstOrThrow
   */
  export type CompanyProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProfile
     */
    select?: CompanyProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyProfileInclude<ExtArgs> | null
    /**
     * Filter, which CompanyProfile to fetch.
     */
    where?: CompanyProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyProfiles to fetch.
     */
    orderBy?: CompanyProfileOrderByWithRelationInput | CompanyProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyProfiles.
     */
    cursor?: CompanyProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyProfiles.
     */
    distinct?: CompanyProfileScalarFieldEnum | CompanyProfileScalarFieldEnum[]
  }

  /**
   * CompanyProfile findMany
   */
  export type CompanyProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProfile
     */
    select?: CompanyProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyProfileInclude<ExtArgs> | null
    /**
     * Filter, which CompanyProfiles to fetch.
     */
    where?: CompanyProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyProfiles to fetch.
     */
    orderBy?: CompanyProfileOrderByWithRelationInput | CompanyProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyProfiles.
     */
    cursor?: CompanyProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyProfiles.
     */
    skip?: number
    distinct?: CompanyProfileScalarFieldEnum | CompanyProfileScalarFieldEnum[]
  }

  /**
   * CompanyProfile create
   */
  export type CompanyProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProfile
     */
    select?: CompanyProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyProfile.
     */
    data: XOR<CompanyProfileCreateInput, CompanyProfileUncheckedCreateInput>
  }

  /**
   * CompanyProfile createMany
   */
  export type CompanyProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyProfiles.
     */
    data: CompanyProfileCreateManyInput | CompanyProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyProfile createManyAndReturn
   */
  export type CompanyProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProfile
     */
    select?: CompanyProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CompanyProfiles.
     */
    data: CompanyProfileCreateManyInput | CompanyProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanyProfile update
   */
  export type CompanyProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProfile
     */
    select?: CompanyProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyProfile.
     */
    data: XOR<CompanyProfileUpdateInput, CompanyProfileUncheckedUpdateInput>
    /**
     * Choose, which CompanyProfile to update.
     */
    where: CompanyProfileWhereUniqueInput
  }

  /**
   * CompanyProfile updateMany
   */
  export type CompanyProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyProfiles.
     */
    data: XOR<CompanyProfileUpdateManyMutationInput, CompanyProfileUncheckedUpdateManyInput>
    /**
     * Filter which CompanyProfiles to update
     */
    where?: CompanyProfileWhereInput
  }

  /**
   * CompanyProfile upsert
   */
  export type CompanyProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProfile
     */
    select?: CompanyProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyProfile to update in case it exists.
     */
    where: CompanyProfileWhereUniqueInput
    /**
     * In case the CompanyProfile found by the `where` argument doesn't exist, create a new CompanyProfile with this data.
     */
    create: XOR<CompanyProfileCreateInput, CompanyProfileUncheckedCreateInput>
    /**
     * In case the CompanyProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyProfileUpdateInput, CompanyProfileUncheckedUpdateInput>
  }

  /**
   * CompanyProfile delete
   */
  export type CompanyProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProfile
     */
    select?: CompanyProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyProfileInclude<ExtArgs> | null
    /**
     * Filter which CompanyProfile to delete.
     */
    where: CompanyProfileWhereUniqueInput
  }

  /**
   * CompanyProfile deleteMany
   */
  export type CompanyProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyProfiles to delete
     */
    where?: CompanyProfileWhereInput
  }

  /**
   * CompanyProfile.company
   */
  export type CompanyProfile$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * CompanyProfile without action
   */
  export type CompanyProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProfile
     */
    select?: CompanyProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyProfileInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    reviewedById: number | null
    vendorId: number | null
    companyId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    reviewedById: number | null
    vendorId: number | null
    companyId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    passwordHash: string | null
    name: string | null
    phone: string | null
    role: $Enums.Role | null
    approvalStatus: $Enums.ApprovalStatus | null
    approvalNote: string | null
    rejectionReason: string | null
    reviewedById: number | null
    reviewedAt: Date | null
    isActive: boolean | null
    vendorId: number | null
    companyId: number | null
    lastLoginAt: Date | null
    twoFactorEnabled: boolean | null
    twoFactorChannel: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    passwordHash: string | null
    name: string | null
    phone: string | null
    role: $Enums.Role | null
    approvalStatus: $Enums.ApprovalStatus | null
    approvalNote: string | null
    rejectionReason: string | null
    reviewedById: number | null
    reviewedAt: Date | null
    isActive: boolean | null
    vendorId: number | null
    companyId: number | null
    lastLoginAt: Date | null
    twoFactorEnabled: boolean | null
    twoFactorChannel: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    name: number
    phone: number
    role: number
    approvalStatus: number
    approvalNote: number
    rejectionReason: number
    reviewedById: number
    reviewedAt: number
    isActive: number
    vendorId: number
    companyId: number
    lastLoginAt: number
    notificationPreferences: number
    twoFactorEnabled: number
    twoFactorChannel: number
    allowedIpRanges: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    reviewedById?: true
    vendorId?: true
    companyId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    reviewedById?: true
    vendorId?: true
    companyId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    name?: true
    phone?: true
    role?: true
    approvalStatus?: true
    approvalNote?: true
    rejectionReason?: true
    reviewedById?: true
    reviewedAt?: true
    isActive?: true
    vendorId?: true
    companyId?: true
    lastLoginAt?: true
    twoFactorEnabled?: true
    twoFactorChannel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    name?: true
    phone?: true
    role?: true
    approvalStatus?: true
    approvalNote?: true
    rejectionReason?: true
    reviewedById?: true
    reviewedAt?: true
    isActive?: true
    vendorId?: true
    companyId?: true
    lastLoginAt?: true
    twoFactorEnabled?: true
    twoFactorChannel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    name?: true
    phone?: true
    role?: true
    approvalStatus?: true
    approvalNote?: true
    rejectionReason?: true
    reviewedById?: true
    reviewedAt?: true
    isActive?: true
    vendorId?: true
    companyId?: true
    lastLoginAt?: true
    notificationPreferences?: true
    twoFactorEnabled?: true
    twoFactorChannel?: true
    allowedIpRanges?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    passwordHash: string
    name: string | null
    phone: string | null
    role: $Enums.Role
    approvalStatus: $Enums.ApprovalStatus
    approvalNote: string | null
    rejectionReason: string | null
    reviewedById: number | null
    reviewedAt: Date | null
    isActive: boolean
    vendorId: number | null
    companyId: number | null
    lastLoginAt: Date | null
    notificationPreferences: JsonValue | null
    twoFactorEnabled: boolean
    twoFactorChannel: string | null
    allowedIpRanges: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    phone?: boolean
    role?: boolean
    approvalStatus?: boolean
    approvalNote?: boolean
    rejectionReason?: boolean
    reviewedById?: boolean
    reviewedAt?: boolean
    isActive?: boolean
    vendorId?: boolean
    companyId?: boolean
    lastLoginAt?: boolean
    notificationPreferences?: boolean
    twoFactorEnabled?: boolean
    twoFactorChannel?: boolean
    allowedIpRanges?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | User$companyArgs<ExtArgs>
    vendor?: boolean | User$vendorArgs<ExtArgs>
    shipments?: boolean | User$shipmentsArgs<ExtArgs>
    assignedShipments?: boolean | User$assignedShipmentsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    agreementsReviewed?: boolean | User$agreementsReviewedArgs<ExtArgs>
    transporterInvoices?: boolean | User$transporterInvoicesArgs<ExtArgs>
    QuoteRequest?: boolean | User$QuoteRequestArgs<ExtArgs>
    passwordResetTokens?: boolean | User$passwordResetTokensArgs<ExtArgs>
    twoFactorChallenges?: boolean | User$twoFactorChallengesArgs<ExtArgs>
    userConsents?: boolean | User$userConsentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    phone?: boolean
    role?: boolean
    approvalStatus?: boolean
    approvalNote?: boolean
    rejectionReason?: boolean
    reviewedById?: boolean
    reviewedAt?: boolean
    isActive?: boolean
    vendorId?: boolean
    companyId?: boolean
    lastLoginAt?: boolean
    notificationPreferences?: boolean
    twoFactorEnabled?: boolean
    twoFactorChannel?: boolean
    allowedIpRanges?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | User$companyArgs<ExtArgs>
    vendor?: boolean | User$vendorArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    phone?: boolean
    role?: boolean
    approvalStatus?: boolean
    approvalNote?: boolean
    rejectionReason?: boolean
    reviewedById?: boolean
    reviewedAt?: boolean
    isActive?: boolean
    vendorId?: boolean
    companyId?: boolean
    lastLoginAt?: boolean
    notificationPreferences?: boolean
    twoFactorEnabled?: boolean
    twoFactorChannel?: boolean
    allowedIpRanges?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | User$companyArgs<ExtArgs>
    vendor?: boolean | User$vendorArgs<ExtArgs>
    shipments?: boolean | User$shipmentsArgs<ExtArgs>
    assignedShipments?: boolean | User$assignedShipmentsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    agreementsReviewed?: boolean | User$agreementsReviewedArgs<ExtArgs>
    transporterInvoices?: boolean | User$transporterInvoicesArgs<ExtArgs>
    QuoteRequest?: boolean | User$QuoteRequestArgs<ExtArgs>
    passwordResetTokens?: boolean | User$passwordResetTokensArgs<ExtArgs>
    twoFactorChallenges?: boolean | User$twoFactorChallengesArgs<ExtArgs>
    userConsents?: boolean | User$userConsentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | User$companyArgs<ExtArgs>
    vendor?: boolean | User$vendorArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs> | null
      vendor: Prisma.$VendorPayload<ExtArgs> | null
      shipments: Prisma.$ShipmentPayload<ExtArgs>[]
      assignedShipments: Prisma.$ShipmentPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      agreementsReviewed: Prisma.$AgreementPayload<ExtArgs>[]
      transporterInvoices: Prisma.$TransporterInvoicePayload<ExtArgs>[]
      QuoteRequest: Prisma.$QuoteRequestPayload<ExtArgs>[]
      passwordResetTokens: Prisma.$PasswordResetTokenPayload<ExtArgs>[]
      twoFactorChallenges: Prisma.$TwoFactorChallengePayload<ExtArgs>[]
      userConsents: Prisma.$UserConsentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      passwordHash: string
      name: string | null
      phone: string | null
      role: $Enums.Role
      approvalStatus: $Enums.ApprovalStatus
      approvalNote: string | null
      rejectionReason: string | null
      reviewedById: number | null
      reviewedAt: Date | null
      isActive: boolean
      vendorId: number | null
      companyId: number | null
      lastLoginAt: Date | null
      notificationPreferences: Prisma.JsonValue | null
      twoFactorEnabled: boolean
      twoFactorChannel: string | null
      allowedIpRanges: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends User$companyArgs<ExtArgs> = {}>(args?: Subset<T, User$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    vendor<T extends User$vendorArgs<ExtArgs> = {}>(args?: Subset<T, User$vendorArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    shipments<T extends User$shipmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$shipmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findMany"> | Null>
    assignedShipments<T extends User$assignedShipmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedShipmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    agreementsReviewed<T extends User$agreementsReviewedArgs<ExtArgs> = {}>(args?: Subset<T, User$agreementsReviewedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgreementPayload<ExtArgs>, T, "findMany"> | Null>
    transporterInvoices<T extends User$transporterInvoicesArgs<ExtArgs> = {}>(args?: Subset<T, User$transporterInvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransporterInvoicePayload<ExtArgs>, T, "findMany"> | Null>
    QuoteRequest<T extends User$QuoteRequestArgs<ExtArgs> = {}>(args?: Subset<T, User$QuoteRequestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteRequestPayload<ExtArgs>, T, "findMany"> | Null>
    passwordResetTokens<T extends User$passwordResetTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$passwordResetTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany"> | Null>
    twoFactorChallenges<T extends User$twoFactorChallengesArgs<ExtArgs> = {}>(args?: Subset<T, User$twoFactorChallengesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwoFactorChallengePayload<ExtArgs>, T, "findMany"> | Null>
    userConsents<T extends User$userConsentsArgs<ExtArgs> = {}>(args?: Subset<T, User$userConsentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly approvalStatus: FieldRef<"User", 'ApprovalStatus'>
    readonly approvalNote: FieldRef<"User", 'String'>
    readonly rejectionReason: FieldRef<"User", 'String'>
    readonly reviewedById: FieldRef<"User", 'Int'>
    readonly reviewedAt: FieldRef<"User", 'DateTime'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly vendorId: FieldRef<"User", 'Int'>
    readonly companyId: FieldRef<"User", 'Int'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly notificationPreferences: FieldRef<"User", 'Json'>
    readonly twoFactorEnabled: FieldRef<"User", 'Boolean'>
    readonly twoFactorChannel: FieldRef<"User", 'String'>
    readonly allowedIpRanges: FieldRef<"User", 'Json'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.company
   */
  export type User$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * User.vendor
   */
  export type User$vendorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    where?: VendorWhereInput
  }

  /**
   * User.shipments
   */
  export type User$shipmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    where?: ShipmentWhereInput
    orderBy?: ShipmentOrderByWithRelationInput | ShipmentOrderByWithRelationInput[]
    cursor?: ShipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShipmentScalarFieldEnum | ShipmentScalarFieldEnum[]
  }

  /**
   * User.assignedShipments
   */
  export type User$assignedShipmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    where?: ShipmentWhereInput
    orderBy?: ShipmentOrderByWithRelationInput | ShipmentOrderByWithRelationInput[]
    cursor?: ShipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShipmentScalarFieldEnum | ShipmentScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.agreementsReviewed
   */
  export type User$agreementsReviewedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementInclude<ExtArgs> | null
    where?: AgreementWhereInput
    orderBy?: AgreementOrderByWithRelationInput | AgreementOrderByWithRelationInput[]
    cursor?: AgreementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgreementScalarFieldEnum | AgreementScalarFieldEnum[]
  }

  /**
   * User.transporterInvoices
   */
  export type User$transporterInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransporterInvoice
     */
    select?: TransporterInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransporterInvoiceInclude<ExtArgs> | null
    where?: TransporterInvoiceWhereInput
    orderBy?: TransporterInvoiceOrderByWithRelationInput | TransporterInvoiceOrderByWithRelationInput[]
    cursor?: TransporterInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransporterInvoiceScalarFieldEnum | TransporterInvoiceScalarFieldEnum[]
  }

  /**
   * User.QuoteRequest
   */
  export type User$QuoteRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteRequest
     */
    select?: QuoteRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteRequestInclude<ExtArgs> | null
    where?: QuoteRequestWhereInput
    orderBy?: QuoteRequestOrderByWithRelationInput | QuoteRequestOrderByWithRelationInput[]
    cursor?: QuoteRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuoteRequestScalarFieldEnum | QuoteRequestScalarFieldEnum[]
  }

  /**
   * User.passwordResetTokens
   */
  export type User$passwordResetTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    cursor?: PasswordResetTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * User.twoFactorChallenges
   */
  export type User$twoFactorChallengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorChallenge
     */
    select?: TwoFactorChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorChallengeInclude<ExtArgs> | null
    where?: TwoFactorChallengeWhereInput
    orderBy?: TwoFactorChallengeOrderByWithRelationInput | TwoFactorChallengeOrderByWithRelationInput[]
    cursor?: TwoFactorChallengeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TwoFactorChallengeScalarFieldEnum | TwoFactorChallengeScalarFieldEnum[]
  }

  /**
   * User.userConsents
   */
  export type User$userConsentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    where?: UserConsentWhereInput
    orderBy?: UserConsentOrderByWithRelationInput | UserConsentOrderByWithRelationInput[]
    cursor?: UserConsentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserConsentScalarFieldEnum | UserConsentScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model PasswordResetToken
   */

  export type AggregatePasswordResetToken = {
    _count: PasswordResetTokenCountAggregateOutputType | null
    _avg: PasswordResetTokenAvgAggregateOutputType | null
    _sum: PasswordResetTokenSumAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  export type PasswordResetTokenAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PasswordResetTokenSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PasswordResetTokenMinAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenHash: string | null
    expiresAt: Date | null
    used: boolean | null
    createdAt: Date | null
  }

  export type PasswordResetTokenMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    tokenHash: string | null
    expiresAt: Date | null
    used: boolean | null
    createdAt: Date | null
  }

  export type PasswordResetTokenCountAggregateOutputType = {
    id: number
    userId: number
    tokenHash: number
    expiresAt: number
    used: number
    createdAt: number
    _all: number
  }


  export type PasswordResetTokenAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PasswordResetTokenSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PasswordResetTokenMinAggregateInputType = {
    id?: true
    userId?: true
    tokenHash?: true
    expiresAt?: true
    used?: true
    createdAt?: true
  }

  export type PasswordResetTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    tokenHash?: true
    expiresAt?: true
    used?: true
    createdAt?: true
  }

  export type PasswordResetTokenCountAggregateInputType = {
    id?: true
    userId?: true
    tokenHash?: true
    expiresAt?: true
    used?: true
    createdAt?: true
    _all?: true
  }

  export type PasswordResetTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetToken to aggregate.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResetTokens
    **/
    _count?: true | PasswordResetTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PasswordResetTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PasswordResetTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type GetPasswordResetTokenAggregateType<T extends PasswordResetTokenAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordResetToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordResetToken[P]>
      : GetScalarType<T[P], AggregatePasswordResetToken[P]>
  }




  export type PasswordResetTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithAggregationInput | PasswordResetTokenOrderByWithAggregationInput[]
    by: PasswordResetTokenScalarFieldEnum[] | PasswordResetTokenScalarFieldEnum
    having?: PasswordResetTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetTokenCountAggregateInputType | true
    _avg?: PasswordResetTokenAvgAggregateInputType
    _sum?: PasswordResetTokenSumAggregateInputType
    _min?: PasswordResetTokenMinAggregateInputType
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type PasswordResetTokenGroupByOutputType = {
    id: number
    userId: number
    tokenHash: string
    expiresAt: Date
    used: boolean
    createdAt: Date
    _count: PasswordResetTokenCountAggregateOutputType | null
    _avg: PasswordResetTokenAvgAggregateOutputType | null
    _sum: PasswordResetTokenSumAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  type GetPasswordResetTokenGroupByPayload<T extends PasswordResetTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenHash?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenHash?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    tokenHash?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
  }

  export type PasswordResetTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasswordResetTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordResetToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      tokenHash: string
      expiresAt: Date
      used: boolean
      createdAt: Date
    }, ExtArgs["result"]["passwordResetToken"]>
    composites: {}
  }

  type PasswordResetTokenGetPayload<S extends boolean | null | undefined | PasswordResetTokenDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetTokenPayload, S>

  type PasswordResetTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PasswordResetTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PasswordResetTokenCountAggregateInputType | true
    }

  export interface PasswordResetTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordResetToken'], meta: { name: 'PasswordResetToken' } }
    /**
     * Find zero or one PasswordResetToken that matches the filter.
     * @param {PasswordResetTokenFindUniqueArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetTokenFindUniqueArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PasswordResetToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PasswordResetTokenFindUniqueOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PasswordResetToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetTokenFindFirstArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PasswordResetToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PasswordResetTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany()
     * 
     * // Get first 10 PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordResetTokenFindManyArgs>(args?: SelectSubset<T, PasswordResetTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PasswordResetToken.
     * @param {PasswordResetTokenCreateArgs} args - Arguments to create a PasswordResetToken.
     * @example
     * // Create one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.create({
     *   data: {
     *     // ... data to create a PasswordResetToken
     *   }
     * })
     * 
     */
    create<T extends PasswordResetTokenCreateArgs>(args: SelectSubset<T, PasswordResetTokenCreateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PasswordResetTokens.
     * @param {PasswordResetTokenCreateManyArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetTokenCreateManyArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordResetTokens and returns the data saved in the database.
     * @param {PasswordResetTokenCreateManyAndReturnArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordResetTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PasswordResetToken.
     * @param {PasswordResetTokenDeleteArgs} args - Arguments to delete one PasswordResetToken.
     * @example
     * // Delete one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.delete({
     *   where: {
     *     // ... filter to delete one PasswordResetToken
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetTokenDeleteArgs>(args: SelectSubset<T, PasswordResetTokenDeleteArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PasswordResetToken.
     * @param {PasswordResetTokenUpdateArgs} args - Arguments to update one PasswordResetToken.
     * @example
     * // Update one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetTokenUpdateArgs>(args: SelectSubset<T, PasswordResetTokenUpdateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PasswordResetTokens.
     * @param {PasswordResetTokenDeleteManyArgs} args - Arguments to filter PasswordResetTokens to delete.
     * @example
     * // Delete a few PasswordResetTokens
     * const { count } = await prisma.passwordResetToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetTokenDeleteManyArgs>(args?: SelectSubset<T, PasswordResetTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetTokenUpdateManyArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PasswordResetToken.
     * @param {PasswordResetTokenUpsertArgs} args - Arguments to update or create a PasswordResetToken.
     * @example
     * // Update or create a PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.upsert({
     *   create: {
     *     // ... data to create a PasswordResetToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordResetToken we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetTokenUpsertArgs>(args: SelectSubset<T, PasswordResetTokenUpsertArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenCountArgs} args - Arguments to filter PasswordResetTokens to count.
     * @example
     * // Count the number of PasswordResetTokens
     * const count = await prisma.passwordResetToken.count({
     *   where: {
     *     // ... the filter for the PasswordResetTokens we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetTokenCountArgs>(
      args?: Subset<T, PasswordResetTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetTokenAggregateArgs>(args: Subset<T, PasswordResetTokenAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetTokenAggregateType<T>>

    /**
     * Group by PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetTokenGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordResetToken model
   */
  readonly fields: PasswordResetTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordResetToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordResetToken model
   */ 
  interface PasswordResetTokenFieldRefs {
    readonly id: FieldRef<"PasswordResetToken", 'Int'>
    readonly userId: FieldRef<"PasswordResetToken", 'Int'>
    readonly tokenHash: FieldRef<"PasswordResetToken", 'String'>
    readonly expiresAt: FieldRef<"PasswordResetToken", 'DateTime'>
    readonly used: FieldRef<"PasswordResetToken", 'Boolean'>
    readonly createdAt: FieldRef<"PasswordResetToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordResetToken findUnique
   */
  export type PasswordResetTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findUniqueOrThrow
   */
  export type PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findFirst
   */
  export type PasswordResetTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findFirstOrThrow
   */
  export type PasswordResetTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findMany
   */
  export type PasswordResetTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetTokens to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken create
   */
  export type PasswordResetTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
  }

  /**
   * PasswordResetToken createMany
   */
  export type PasswordResetTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetToken createManyAndReturn
   */
  export type PasswordResetTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordResetToken update
   */
  export type PasswordResetTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
    /**
     * Choose, which PasswordResetToken to update.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken updateMany
   */
  export type PasswordResetTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
  }

  /**
   * PasswordResetToken upsert
   */
  export type PasswordResetTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordResetToken to update in case it exists.
     */
    where: PasswordResetTokenWhereUniqueInput
    /**
     * In case the PasswordResetToken found by the `where` argument doesn't exist, create a new PasswordResetToken with this data.
     */
    create: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
    /**
     * In case the PasswordResetToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
  }

  /**
   * PasswordResetToken delete
   */
  export type PasswordResetTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter which PasswordResetToken to delete.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken deleteMany
   */
  export type PasswordResetTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetTokens to delete
     */
    where?: PasswordResetTokenWhereInput
  }

  /**
   * PasswordResetToken without action
   */
  export type PasswordResetTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
  }


  /**
   * Model TwoFactorChallenge
   */

  export type AggregateTwoFactorChallenge = {
    _count: TwoFactorChallengeCountAggregateOutputType | null
    _avg: TwoFactorChallengeAvgAggregateOutputType | null
    _sum: TwoFactorChallengeSumAggregateOutputType | null
    _min: TwoFactorChallengeMinAggregateOutputType | null
    _max: TwoFactorChallengeMaxAggregateOutputType | null
  }

  export type TwoFactorChallengeAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type TwoFactorChallengeSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type TwoFactorChallengeMinAggregateOutputType = {
    id: number | null
    userId: number | null
    codeHash: string | null
    expiresAt: Date | null
    consumed: boolean | null
    createdAt: Date | null
  }

  export type TwoFactorChallengeMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    codeHash: string | null
    expiresAt: Date | null
    consumed: boolean | null
    createdAt: Date | null
  }

  export type TwoFactorChallengeCountAggregateOutputType = {
    id: number
    userId: number
    codeHash: number
    expiresAt: number
    consumed: number
    createdAt: number
    _all: number
  }


  export type TwoFactorChallengeAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type TwoFactorChallengeSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type TwoFactorChallengeMinAggregateInputType = {
    id?: true
    userId?: true
    codeHash?: true
    expiresAt?: true
    consumed?: true
    createdAt?: true
  }

  export type TwoFactorChallengeMaxAggregateInputType = {
    id?: true
    userId?: true
    codeHash?: true
    expiresAt?: true
    consumed?: true
    createdAt?: true
  }

  export type TwoFactorChallengeCountAggregateInputType = {
    id?: true
    userId?: true
    codeHash?: true
    expiresAt?: true
    consumed?: true
    createdAt?: true
    _all?: true
  }

  export type TwoFactorChallengeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TwoFactorChallenge to aggregate.
     */
    where?: TwoFactorChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactorChallenges to fetch.
     */
    orderBy?: TwoFactorChallengeOrderByWithRelationInput | TwoFactorChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TwoFactorChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactorChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactorChallenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwoFactorChallenges
    **/
    _count?: true | TwoFactorChallengeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TwoFactorChallengeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TwoFactorChallengeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TwoFactorChallengeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TwoFactorChallengeMaxAggregateInputType
  }

  export type GetTwoFactorChallengeAggregateType<T extends TwoFactorChallengeAggregateArgs> = {
        [P in keyof T & keyof AggregateTwoFactorChallenge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwoFactorChallenge[P]>
      : GetScalarType<T[P], AggregateTwoFactorChallenge[P]>
  }




  export type TwoFactorChallengeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TwoFactorChallengeWhereInput
    orderBy?: TwoFactorChallengeOrderByWithAggregationInput | TwoFactorChallengeOrderByWithAggregationInput[]
    by: TwoFactorChallengeScalarFieldEnum[] | TwoFactorChallengeScalarFieldEnum
    having?: TwoFactorChallengeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TwoFactorChallengeCountAggregateInputType | true
    _avg?: TwoFactorChallengeAvgAggregateInputType
    _sum?: TwoFactorChallengeSumAggregateInputType
    _min?: TwoFactorChallengeMinAggregateInputType
    _max?: TwoFactorChallengeMaxAggregateInputType
  }

  export type TwoFactorChallengeGroupByOutputType = {
    id: number
    userId: number
    codeHash: string
    expiresAt: Date
    consumed: boolean
    createdAt: Date
    _count: TwoFactorChallengeCountAggregateOutputType | null
    _avg: TwoFactorChallengeAvgAggregateOutputType | null
    _sum: TwoFactorChallengeSumAggregateOutputType | null
    _min: TwoFactorChallengeMinAggregateOutputType | null
    _max: TwoFactorChallengeMaxAggregateOutputType | null
  }

  type GetTwoFactorChallengeGroupByPayload<T extends TwoFactorChallengeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TwoFactorChallengeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TwoFactorChallengeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TwoFactorChallengeGroupByOutputType[P]>
            : GetScalarType<T[P], TwoFactorChallengeGroupByOutputType[P]>
        }
      >
    >


  export type TwoFactorChallengeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    codeHash?: boolean
    expiresAt?: boolean
    consumed?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["twoFactorChallenge"]>

  export type TwoFactorChallengeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    codeHash?: boolean
    expiresAt?: boolean
    consumed?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["twoFactorChallenge"]>

  export type TwoFactorChallengeSelectScalar = {
    id?: boolean
    userId?: boolean
    codeHash?: boolean
    expiresAt?: boolean
    consumed?: boolean
    createdAt?: boolean
  }

  export type TwoFactorChallengeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TwoFactorChallengeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TwoFactorChallengePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TwoFactorChallenge"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      codeHash: string
      expiresAt: Date
      consumed: boolean
      createdAt: Date
    }, ExtArgs["result"]["twoFactorChallenge"]>
    composites: {}
  }

  type TwoFactorChallengeGetPayload<S extends boolean | null | undefined | TwoFactorChallengeDefaultArgs> = $Result.GetResult<Prisma.$TwoFactorChallengePayload, S>

  type TwoFactorChallengeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TwoFactorChallengeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TwoFactorChallengeCountAggregateInputType | true
    }

  export interface TwoFactorChallengeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TwoFactorChallenge'], meta: { name: 'TwoFactorChallenge' } }
    /**
     * Find zero or one TwoFactorChallenge that matches the filter.
     * @param {TwoFactorChallengeFindUniqueArgs} args - Arguments to find a TwoFactorChallenge
     * @example
     * // Get one TwoFactorChallenge
     * const twoFactorChallenge = await prisma.twoFactorChallenge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TwoFactorChallengeFindUniqueArgs>(args: SelectSubset<T, TwoFactorChallengeFindUniqueArgs<ExtArgs>>): Prisma__TwoFactorChallengeClient<$Result.GetResult<Prisma.$TwoFactorChallengePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TwoFactorChallenge that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TwoFactorChallengeFindUniqueOrThrowArgs} args - Arguments to find a TwoFactorChallenge
     * @example
     * // Get one TwoFactorChallenge
     * const twoFactorChallenge = await prisma.twoFactorChallenge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TwoFactorChallengeFindUniqueOrThrowArgs>(args: SelectSubset<T, TwoFactorChallengeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TwoFactorChallengeClient<$Result.GetResult<Prisma.$TwoFactorChallengePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TwoFactorChallenge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorChallengeFindFirstArgs} args - Arguments to find a TwoFactorChallenge
     * @example
     * // Get one TwoFactorChallenge
     * const twoFactorChallenge = await prisma.twoFactorChallenge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TwoFactorChallengeFindFirstArgs>(args?: SelectSubset<T, TwoFactorChallengeFindFirstArgs<ExtArgs>>): Prisma__TwoFactorChallengeClient<$Result.GetResult<Prisma.$TwoFactorChallengePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TwoFactorChallenge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorChallengeFindFirstOrThrowArgs} args - Arguments to find a TwoFactorChallenge
     * @example
     * // Get one TwoFactorChallenge
     * const twoFactorChallenge = await prisma.twoFactorChallenge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TwoFactorChallengeFindFirstOrThrowArgs>(args?: SelectSubset<T, TwoFactorChallengeFindFirstOrThrowArgs<ExtArgs>>): Prisma__TwoFactorChallengeClient<$Result.GetResult<Prisma.$TwoFactorChallengePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TwoFactorChallenges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorChallengeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwoFactorChallenges
     * const twoFactorChallenges = await prisma.twoFactorChallenge.findMany()
     * 
     * // Get first 10 TwoFactorChallenges
     * const twoFactorChallenges = await prisma.twoFactorChallenge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twoFactorChallengeWithIdOnly = await prisma.twoFactorChallenge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TwoFactorChallengeFindManyArgs>(args?: SelectSubset<T, TwoFactorChallengeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwoFactorChallengePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TwoFactorChallenge.
     * @param {TwoFactorChallengeCreateArgs} args - Arguments to create a TwoFactorChallenge.
     * @example
     * // Create one TwoFactorChallenge
     * const TwoFactorChallenge = await prisma.twoFactorChallenge.create({
     *   data: {
     *     // ... data to create a TwoFactorChallenge
     *   }
     * })
     * 
     */
    create<T extends TwoFactorChallengeCreateArgs>(args: SelectSubset<T, TwoFactorChallengeCreateArgs<ExtArgs>>): Prisma__TwoFactorChallengeClient<$Result.GetResult<Prisma.$TwoFactorChallengePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TwoFactorChallenges.
     * @param {TwoFactorChallengeCreateManyArgs} args - Arguments to create many TwoFactorChallenges.
     * @example
     * // Create many TwoFactorChallenges
     * const twoFactorChallenge = await prisma.twoFactorChallenge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TwoFactorChallengeCreateManyArgs>(args?: SelectSubset<T, TwoFactorChallengeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TwoFactorChallenges and returns the data saved in the database.
     * @param {TwoFactorChallengeCreateManyAndReturnArgs} args - Arguments to create many TwoFactorChallenges.
     * @example
     * // Create many TwoFactorChallenges
     * const twoFactorChallenge = await prisma.twoFactorChallenge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TwoFactorChallenges and only return the `id`
     * const twoFactorChallengeWithIdOnly = await prisma.twoFactorChallenge.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TwoFactorChallengeCreateManyAndReturnArgs>(args?: SelectSubset<T, TwoFactorChallengeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwoFactorChallengePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TwoFactorChallenge.
     * @param {TwoFactorChallengeDeleteArgs} args - Arguments to delete one TwoFactorChallenge.
     * @example
     * // Delete one TwoFactorChallenge
     * const TwoFactorChallenge = await prisma.twoFactorChallenge.delete({
     *   where: {
     *     // ... filter to delete one TwoFactorChallenge
     *   }
     * })
     * 
     */
    delete<T extends TwoFactorChallengeDeleteArgs>(args: SelectSubset<T, TwoFactorChallengeDeleteArgs<ExtArgs>>): Prisma__TwoFactorChallengeClient<$Result.GetResult<Prisma.$TwoFactorChallengePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TwoFactorChallenge.
     * @param {TwoFactorChallengeUpdateArgs} args - Arguments to update one TwoFactorChallenge.
     * @example
     * // Update one TwoFactorChallenge
     * const twoFactorChallenge = await prisma.twoFactorChallenge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TwoFactorChallengeUpdateArgs>(args: SelectSubset<T, TwoFactorChallengeUpdateArgs<ExtArgs>>): Prisma__TwoFactorChallengeClient<$Result.GetResult<Prisma.$TwoFactorChallengePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TwoFactorChallenges.
     * @param {TwoFactorChallengeDeleteManyArgs} args - Arguments to filter TwoFactorChallenges to delete.
     * @example
     * // Delete a few TwoFactorChallenges
     * const { count } = await prisma.twoFactorChallenge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TwoFactorChallengeDeleteManyArgs>(args?: SelectSubset<T, TwoFactorChallengeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwoFactorChallenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorChallengeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwoFactorChallenges
     * const twoFactorChallenge = await prisma.twoFactorChallenge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TwoFactorChallengeUpdateManyArgs>(args: SelectSubset<T, TwoFactorChallengeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TwoFactorChallenge.
     * @param {TwoFactorChallengeUpsertArgs} args - Arguments to update or create a TwoFactorChallenge.
     * @example
     * // Update or create a TwoFactorChallenge
     * const twoFactorChallenge = await prisma.twoFactorChallenge.upsert({
     *   create: {
     *     // ... data to create a TwoFactorChallenge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwoFactorChallenge we want to update
     *   }
     * })
     */
    upsert<T extends TwoFactorChallengeUpsertArgs>(args: SelectSubset<T, TwoFactorChallengeUpsertArgs<ExtArgs>>): Prisma__TwoFactorChallengeClient<$Result.GetResult<Prisma.$TwoFactorChallengePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TwoFactorChallenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorChallengeCountArgs} args - Arguments to filter TwoFactorChallenges to count.
     * @example
     * // Count the number of TwoFactorChallenges
     * const count = await prisma.twoFactorChallenge.count({
     *   where: {
     *     // ... the filter for the TwoFactorChallenges we want to count
     *   }
     * })
    **/
    count<T extends TwoFactorChallengeCountArgs>(
      args?: Subset<T, TwoFactorChallengeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwoFactorChallengeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwoFactorChallenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorChallengeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwoFactorChallengeAggregateArgs>(args: Subset<T, TwoFactorChallengeAggregateArgs>): Prisma.PrismaPromise<GetTwoFactorChallengeAggregateType<T>>

    /**
     * Group by TwoFactorChallenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorChallengeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TwoFactorChallengeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TwoFactorChallengeGroupByArgs['orderBy'] }
        : { orderBy?: TwoFactorChallengeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TwoFactorChallengeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTwoFactorChallengeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TwoFactorChallenge model
   */
  readonly fields: TwoFactorChallengeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TwoFactorChallenge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TwoFactorChallengeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TwoFactorChallenge model
   */ 
  interface TwoFactorChallengeFieldRefs {
    readonly id: FieldRef<"TwoFactorChallenge", 'Int'>
    readonly userId: FieldRef<"TwoFactorChallenge", 'Int'>
    readonly codeHash: FieldRef<"TwoFactorChallenge", 'String'>
    readonly expiresAt: FieldRef<"TwoFactorChallenge", 'DateTime'>
    readonly consumed: FieldRef<"TwoFactorChallenge", 'Boolean'>
    readonly createdAt: FieldRef<"TwoFactorChallenge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TwoFactorChallenge findUnique
   */
  export type TwoFactorChallengeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorChallenge
     */
    select?: TwoFactorChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorChallengeInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactorChallenge to fetch.
     */
    where: TwoFactorChallengeWhereUniqueInput
  }

  /**
   * TwoFactorChallenge findUniqueOrThrow
   */
  export type TwoFactorChallengeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorChallenge
     */
    select?: TwoFactorChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorChallengeInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactorChallenge to fetch.
     */
    where: TwoFactorChallengeWhereUniqueInput
  }

  /**
   * TwoFactorChallenge findFirst
   */
  export type TwoFactorChallengeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorChallenge
     */
    select?: TwoFactorChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorChallengeInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactorChallenge to fetch.
     */
    where?: TwoFactorChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactorChallenges to fetch.
     */
    orderBy?: TwoFactorChallengeOrderByWithRelationInput | TwoFactorChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwoFactorChallenges.
     */
    cursor?: TwoFactorChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactorChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactorChallenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwoFactorChallenges.
     */
    distinct?: TwoFactorChallengeScalarFieldEnum | TwoFactorChallengeScalarFieldEnum[]
  }

  /**
   * TwoFactorChallenge findFirstOrThrow
   */
  export type TwoFactorChallengeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorChallenge
     */
    select?: TwoFactorChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorChallengeInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactorChallenge to fetch.
     */
    where?: TwoFactorChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactorChallenges to fetch.
     */
    orderBy?: TwoFactorChallengeOrderByWithRelationInput | TwoFactorChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwoFactorChallenges.
     */
    cursor?: TwoFactorChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactorChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactorChallenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwoFactorChallenges.
     */
    distinct?: TwoFactorChallengeScalarFieldEnum | TwoFactorChallengeScalarFieldEnum[]
  }

  /**
   * TwoFactorChallenge findMany
   */
  export type TwoFactorChallengeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorChallenge
     */
    select?: TwoFactorChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorChallengeInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactorChallenges to fetch.
     */
    where?: TwoFactorChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactorChallenges to fetch.
     */
    orderBy?: TwoFactorChallengeOrderByWithRelationInput | TwoFactorChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwoFactorChallenges.
     */
    cursor?: TwoFactorChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactorChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactorChallenges.
     */
    skip?: number
    distinct?: TwoFactorChallengeScalarFieldEnum | TwoFactorChallengeScalarFieldEnum[]
  }

  /**
   * TwoFactorChallenge create
   */
  export type TwoFactorChallengeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorChallenge
     */
    select?: TwoFactorChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorChallengeInclude<ExtArgs> | null
    /**
     * The data needed to create a TwoFactorChallenge.
     */
    data: XOR<TwoFactorChallengeCreateInput, TwoFactorChallengeUncheckedCreateInput>
  }

  /**
   * TwoFactorChallenge createMany
   */
  export type TwoFactorChallengeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TwoFactorChallenges.
     */
    data: TwoFactorChallengeCreateManyInput | TwoFactorChallengeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TwoFactorChallenge createManyAndReturn
   */
  export type TwoFactorChallengeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorChallenge
     */
    select?: TwoFactorChallengeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TwoFactorChallenges.
     */
    data: TwoFactorChallengeCreateManyInput | TwoFactorChallengeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorChallengeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TwoFactorChallenge update
   */
  export type TwoFactorChallengeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorChallenge
     */
    select?: TwoFactorChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorChallengeInclude<ExtArgs> | null
    /**
     * The data needed to update a TwoFactorChallenge.
     */
    data: XOR<TwoFactorChallengeUpdateInput, TwoFactorChallengeUncheckedUpdateInput>
    /**
     * Choose, which TwoFactorChallenge to update.
     */
    where: TwoFactorChallengeWhereUniqueInput
  }

  /**
   * TwoFactorChallenge updateMany
   */
  export type TwoFactorChallengeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TwoFactorChallenges.
     */
    data: XOR<TwoFactorChallengeUpdateManyMutationInput, TwoFactorChallengeUncheckedUpdateManyInput>
    /**
     * Filter which TwoFactorChallenges to update
     */
    where?: TwoFactorChallengeWhereInput
  }

  /**
   * TwoFactorChallenge upsert
   */
  export type TwoFactorChallengeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorChallenge
     */
    select?: TwoFactorChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorChallengeInclude<ExtArgs> | null
    /**
     * The filter to search for the TwoFactorChallenge to update in case it exists.
     */
    where: TwoFactorChallengeWhereUniqueInput
    /**
     * In case the TwoFactorChallenge found by the `where` argument doesn't exist, create a new TwoFactorChallenge with this data.
     */
    create: XOR<TwoFactorChallengeCreateInput, TwoFactorChallengeUncheckedCreateInput>
    /**
     * In case the TwoFactorChallenge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TwoFactorChallengeUpdateInput, TwoFactorChallengeUncheckedUpdateInput>
  }

  /**
   * TwoFactorChallenge delete
   */
  export type TwoFactorChallengeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorChallenge
     */
    select?: TwoFactorChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorChallengeInclude<ExtArgs> | null
    /**
     * Filter which TwoFactorChallenge to delete.
     */
    where: TwoFactorChallengeWhereUniqueInput
  }

  /**
   * TwoFactorChallenge deleteMany
   */
  export type TwoFactorChallengeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TwoFactorChallenges to delete
     */
    where?: TwoFactorChallengeWhereInput
  }

  /**
   * TwoFactorChallenge without action
   */
  export type TwoFactorChallengeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorChallenge
     */
    select?: TwoFactorChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorChallengeInclude<ExtArgs> | null
  }


  /**
   * Model UserConsent
   */

  export type AggregateUserConsent = {
    _count: UserConsentCountAggregateOutputType | null
    _avg: UserConsentAvgAggregateOutputType | null
    _sum: UserConsentSumAggregateOutputType | null
    _min: UserConsentMinAggregateOutputType | null
    _max: UserConsentMaxAggregateOutputType | null
  }

  export type UserConsentAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserConsentSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserConsentMinAggregateOutputType = {
    id: number | null
    userId: number | null
    consentType: string | null
    status: $Enums.ConsentStatus | null
    recordedAt: Date | null
  }

  export type UserConsentMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    consentType: string | null
    status: $Enums.ConsentStatus | null
    recordedAt: Date | null
  }

  export type UserConsentCountAggregateOutputType = {
    id: number
    userId: number
    consentType: number
    status: number
    metadata: number
    recordedAt: number
    _all: number
  }


  export type UserConsentAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserConsentSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserConsentMinAggregateInputType = {
    id?: true
    userId?: true
    consentType?: true
    status?: true
    recordedAt?: true
  }

  export type UserConsentMaxAggregateInputType = {
    id?: true
    userId?: true
    consentType?: true
    status?: true
    recordedAt?: true
  }

  export type UserConsentCountAggregateInputType = {
    id?: true
    userId?: true
    consentType?: true
    status?: true
    metadata?: true
    recordedAt?: true
    _all?: true
  }

  export type UserConsentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserConsent to aggregate.
     */
    where?: UserConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserConsents to fetch.
     */
    orderBy?: UserConsentOrderByWithRelationInput | UserConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserConsents
    **/
    _count?: true | UserConsentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserConsentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserConsentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserConsentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserConsentMaxAggregateInputType
  }

  export type GetUserConsentAggregateType<T extends UserConsentAggregateArgs> = {
        [P in keyof T & keyof AggregateUserConsent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserConsent[P]>
      : GetScalarType<T[P], AggregateUserConsent[P]>
  }




  export type UserConsentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserConsentWhereInput
    orderBy?: UserConsentOrderByWithAggregationInput | UserConsentOrderByWithAggregationInput[]
    by: UserConsentScalarFieldEnum[] | UserConsentScalarFieldEnum
    having?: UserConsentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserConsentCountAggregateInputType | true
    _avg?: UserConsentAvgAggregateInputType
    _sum?: UserConsentSumAggregateInputType
    _min?: UserConsentMinAggregateInputType
    _max?: UserConsentMaxAggregateInputType
  }

  export type UserConsentGroupByOutputType = {
    id: number
    userId: number
    consentType: string
    status: $Enums.ConsentStatus
    metadata: JsonValue | null
    recordedAt: Date
    _count: UserConsentCountAggregateOutputType | null
    _avg: UserConsentAvgAggregateOutputType | null
    _sum: UserConsentSumAggregateOutputType | null
    _min: UserConsentMinAggregateOutputType | null
    _max: UserConsentMaxAggregateOutputType | null
  }

  type GetUserConsentGroupByPayload<T extends UserConsentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserConsentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserConsentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserConsentGroupByOutputType[P]>
            : GetScalarType<T[P], UserConsentGroupByOutputType[P]>
        }
      >
    >


  export type UserConsentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    consentType?: boolean
    status?: boolean
    metadata?: boolean
    recordedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userConsent"]>

  export type UserConsentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    consentType?: boolean
    status?: boolean
    metadata?: boolean
    recordedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userConsent"]>

  export type UserConsentSelectScalar = {
    id?: boolean
    userId?: boolean
    consentType?: boolean
    status?: boolean
    metadata?: boolean
    recordedAt?: boolean
  }

  export type UserConsentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserConsentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserConsentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserConsent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      consentType: string
      status: $Enums.ConsentStatus
      metadata: Prisma.JsonValue | null
      recordedAt: Date
    }, ExtArgs["result"]["userConsent"]>
    composites: {}
  }

  type UserConsentGetPayload<S extends boolean | null | undefined | UserConsentDefaultArgs> = $Result.GetResult<Prisma.$UserConsentPayload, S>

  type UserConsentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserConsentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserConsentCountAggregateInputType | true
    }

  export interface UserConsentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserConsent'], meta: { name: 'UserConsent' } }
    /**
     * Find zero or one UserConsent that matches the filter.
     * @param {UserConsentFindUniqueArgs} args - Arguments to find a UserConsent
     * @example
     * // Get one UserConsent
     * const userConsent = await prisma.userConsent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserConsentFindUniqueArgs>(args: SelectSubset<T, UserConsentFindUniqueArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserConsent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserConsentFindUniqueOrThrowArgs} args - Arguments to find a UserConsent
     * @example
     * // Get one UserConsent
     * const userConsent = await prisma.userConsent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserConsentFindUniqueOrThrowArgs>(args: SelectSubset<T, UserConsentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserConsent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConsentFindFirstArgs} args - Arguments to find a UserConsent
     * @example
     * // Get one UserConsent
     * const userConsent = await prisma.userConsent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserConsentFindFirstArgs>(args?: SelectSubset<T, UserConsentFindFirstArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserConsent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConsentFindFirstOrThrowArgs} args - Arguments to find a UserConsent
     * @example
     * // Get one UserConsent
     * const userConsent = await prisma.userConsent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserConsentFindFirstOrThrowArgs>(args?: SelectSubset<T, UserConsentFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserConsents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConsentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserConsents
     * const userConsents = await prisma.userConsent.findMany()
     * 
     * // Get first 10 UserConsents
     * const userConsents = await prisma.userConsent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userConsentWithIdOnly = await prisma.userConsent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserConsentFindManyArgs>(args?: SelectSubset<T, UserConsentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserConsent.
     * @param {UserConsentCreateArgs} args - Arguments to create a UserConsent.
     * @example
     * // Create one UserConsent
     * const UserConsent = await prisma.userConsent.create({
     *   data: {
     *     // ... data to create a UserConsent
     *   }
     * })
     * 
     */
    create<T extends UserConsentCreateArgs>(args: SelectSubset<T, UserConsentCreateArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserConsents.
     * @param {UserConsentCreateManyArgs} args - Arguments to create many UserConsents.
     * @example
     * // Create many UserConsents
     * const userConsent = await prisma.userConsent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserConsentCreateManyArgs>(args?: SelectSubset<T, UserConsentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserConsents and returns the data saved in the database.
     * @param {UserConsentCreateManyAndReturnArgs} args - Arguments to create many UserConsents.
     * @example
     * // Create many UserConsents
     * const userConsent = await prisma.userConsent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserConsents and only return the `id`
     * const userConsentWithIdOnly = await prisma.userConsent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserConsentCreateManyAndReturnArgs>(args?: SelectSubset<T, UserConsentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserConsent.
     * @param {UserConsentDeleteArgs} args - Arguments to delete one UserConsent.
     * @example
     * // Delete one UserConsent
     * const UserConsent = await prisma.userConsent.delete({
     *   where: {
     *     // ... filter to delete one UserConsent
     *   }
     * })
     * 
     */
    delete<T extends UserConsentDeleteArgs>(args: SelectSubset<T, UserConsentDeleteArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserConsent.
     * @param {UserConsentUpdateArgs} args - Arguments to update one UserConsent.
     * @example
     * // Update one UserConsent
     * const userConsent = await prisma.userConsent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserConsentUpdateArgs>(args: SelectSubset<T, UserConsentUpdateArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserConsents.
     * @param {UserConsentDeleteManyArgs} args - Arguments to filter UserConsents to delete.
     * @example
     * // Delete a few UserConsents
     * const { count } = await prisma.userConsent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserConsentDeleteManyArgs>(args?: SelectSubset<T, UserConsentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserConsents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConsentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserConsents
     * const userConsent = await prisma.userConsent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserConsentUpdateManyArgs>(args: SelectSubset<T, UserConsentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserConsent.
     * @param {UserConsentUpsertArgs} args - Arguments to update or create a UserConsent.
     * @example
     * // Update or create a UserConsent
     * const userConsent = await prisma.userConsent.upsert({
     *   create: {
     *     // ... data to create a UserConsent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserConsent we want to update
     *   }
     * })
     */
    upsert<T extends UserConsentUpsertArgs>(args: SelectSubset<T, UserConsentUpsertArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserConsents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConsentCountArgs} args - Arguments to filter UserConsents to count.
     * @example
     * // Count the number of UserConsents
     * const count = await prisma.userConsent.count({
     *   where: {
     *     // ... the filter for the UserConsents we want to count
     *   }
     * })
    **/
    count<T extends UserConsentCountArgs>(
      args?: Subset<T, UserConsentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserConsentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserConsent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConsentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserConsentAggregateArgs>(args: Subset<T, UserConsentAggregateArgs>): Prisma.PrismaPromise<GetUserConsentAggregateType<T>>

    /**
     * Group by UserConsent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConsentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserConsentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserConsentGroupByArgs['orderBy'] }
        : { orderBy?: UserConsentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserConsentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserConsentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserConsent model
   */
  readonly fields: UserConsentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserConsent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserConsentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserConsent model
   */ 
  interface UserConsentFieldRefs {
    readonly id: FieldRef<"UserConsent", 'Int'>
    readonly userId: FieldRef<"UserConsent", 'Int'>
    readonly consentType: FieldRef<"UserConsent", 'String'>
    readonly status: FieldRef<"UserConsent", 'ConsentStatus'>
    readonly metadata: FieldRef<"UserConsent", 'Json'>
    readonly recordedAt: FieldRef<"UserConsent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserConsent findUnique
   */
  export type UserConsentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * Filter, which UserConsent to fetch.
     */
    where: UserConsentWhereUniqueInput
  }

  /**
   * UserConsent findUniqueOrThrow
   */
  export type UserConsentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * Filter, which UserConsent to fetch.
     */
    where: UserConsentWhereUniqueInput
  }

  /**
   * UserConsent findFirst
   */
  export type UserConsentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * Filter, which UserConsent to fetch.
     */
    where?: UserConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserConsents to fetch.
     */
    orderBy?: UserConsentOrderByWithRelationInput | UserConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserConsents.
     */
    cursor?: UserConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserConsents.
     */
    distinct?: UserConsentScalarFieldEnum | UserConsentScalarFieldEnum[]
  }

  /**
   * UserConsent findFirstOrThrow
   */
  export type UserConsentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * Filter, which UserConsent to fetch.
     */
    where?: UserConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserConsents to fetch.
     */
    orderBy?: UserConsentOrderByWithRelationInput | UserConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserConsents.
     */
    cursor?: UserConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserConsents.
     */
    distinct?: UserConsentScalarFieldEnum | UserConsentScalarFieldEnum[]
  }

  /**
   * UserConsent findMany
   */
  export type UserConsentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * Filter, which UserConsents to fetch.
     */
    where?: UserConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserConsents to fetch.
     */
    orderBy?: UserConsentOrderByWithRelationInput | UserConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserConsents.
     */
    cursor?: UserConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserConsents.
     */
    skip?: number
    distinct?: UserConsentScalarFieldEnum | UserConsentScalarFieldEnum[]
  }

  /**
   * UserConsent create
   */
  export type UserConsentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * The data needed to create a UserConsent.
     */
    data: XOR<UserConsentCreateInput, UserConsentUncheckedCreateInput>
  }

  /**
   * UserConsent createMany
   */
  export type UserConsentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserConsents.
     */
    data: UserConsentCreateManyInput | UserConsentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserConsent createManyAndReturn
   */
  export type UserConsentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserConsents.
     */
    data: UserConsentCreateManyInput | UserConsentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserConsent update
   */
  export type UserConsentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * The data needed to update a UserConsent.
     */
    data: XOR<UserConsentUpdateInput, UserConsentUncheckedUpdateInput>
    /**
     * Choose, which UserConsent to update.
     */
    where: UserConsentWhereUniqueInput
  }

  /**
   * UserConsent updateMany
   */
  export type UserConsentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserConsents.
     */
    data: XOR<UserConsentUpdateManyMutationInput, UserConsentUncheckedUpdateManyInput>
    /**
     * Filter which UserConsents to update
     */
    where?: UserConsentWhereInput
  }

  /**
   * UserConsent upsert
   */
  export type UserConsentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * The filter to search for the UserConsent to update in case it exists.
     */
    where: UserConsentWhereUniqueInput
    /**
     * In case the UserConsent found by the `where` argument doesn't exist, create a new UserConsent with this data.
     */
    create: XOR<UserConsentCreateInput, UserConsentUncheckedCreateInput>
    /**
     * In case the UserConsent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserConsentUpdateInput, UserConsentUncheckedUpdateInput>
  }

  /**
   * UserConsent delete
   */
  export type UserConsentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * Filter which UserConsent to delete.
     */
    where: UserConsentWhereUniqueInput
  }

  /**
   * UserConsent deleteMany
   */
  export type UserConsentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserConsents to delete
     */
    where?: UserConsentWhereInput
  }

  /**
   * UserConsent without action
   */
  export type UserConsentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
  }


  /**
   * Model Vendor
   */

  export type AggregateVendor = {
    _count: VendorCountAggregateOutputType | null
    _avg: VendorAvgAggregateOutputType | null
    _sum: VendorSumAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  export type VendorAvgAggregateOutputType = {
    id: number | null
    baseRate: number | null
    rating: number | null
    speed: number | null
    companyId: number | null
  }

  export type VendorSumAggregateOutputType = {
    id: number | null
    baseRate: number | null
    rating: number | null
    speed: number | null
    companyId: number | null
  }

  export type VendorMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    phone: string | null
    baseRate: number | null
    rating: number | null
    speed: number | null
    isActive: boolean | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    phone: string | null
    baseRate: number | null
    rating: number | null
    speed: number | null
    isActive: boolean | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    baseRate: number
    rating: number
    speed: number
    isActive: number
    companyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VendorAvgAggregateInputType = {
    id?: true
    baseRate?: true
    rating?: true
    speed?: true
    companyId?: true
  }

  export type VendorSumAggregateInputType = {
    id?: true
    baseRate?: true
    rating?: true
    speed?: true
    companyId?: true
  }

  export type VendorMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    baseRate?: true
    rating?: true
    speed?: true
    isActive?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    baseRate?: true
    rating?: true
    speed?: true
    isActive?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    baseRate?: true
    rating?: true
    speed?: true
    isActive?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VendorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendor to aggregate.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vendors
    **/
    _count?: true | VendorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorMaxAggregateInputType
  }

  export type GetVendorAggregateType<T extends VendorAggregateArgs> = {
        [P in keyof T & keyof AggregateVendor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendor[P]>
      : GetScalarType<T[P], AggregateVendor[P]>
  }




  export type VendorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorWhereInput
    orderBy?: VendorOrderByWithAggregationInput | VendorOrderByWithAggregationInput[]
    by: VendorScalarFieldEnum[] | VendorScalarFieldEnum
    having?: VendorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorCountAggregateInputType | true
    _avg?: VendorAvgAggregateInputType
    _sum?: VendorSumAggregateInputType
    _min?: VendorMinAggregateInputType
    _max?: VendorMaxAggregateInputType
  }

  export type VendorGroupByOutputType = {
    id: number
    name: string
    email: string | null
    phone: string | null
    baseRate: number | null
    rating: number | null
    speed: number | null
    isActive: boolean
    companyId: number | null
    createdAt: Date
    updatedAt: Date
    _count: VendorCountAggregateOutputType | null
    _avg: VendorAvgAggregateOutputType | null
    _sum: VendorSumAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  type GetVendorGroupByPayload<T extends VendorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorGroupByOutputType[P]>
            : GetScalarType<T[P], VendorGroupByOutputType[P]>
        }
      >
    >


  export type VendorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    baseRate?: boolean
    rating?: boolean
    speed?: boolean
    isActive?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | Vendor$companyArgs<ExtArgs>
    profile?: boolean | Vendor$profileArgs<ExtArgs>
    agreements?: boolean | Vendor$agreementsArgs<ExtArgs>
    rateCards?: boolean | Vendor$rateCardsArgs<ExtArgs>
    quoteResponses?: boolean | Vendor$quoteResponsesArgs<ExtArgs>
    shipments?: boolean | Vendor$shipmentsArgs<ExtArgs>
    drivers?: boolean | Vendor$driversArgs<ExtArgs>
    User?: boolean | Vendor$UserArgs<ExtArgs>
    _count?: boolean | VendorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendor"]>

  export type VendorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    baseRate?: boolean
    rating?: boolean
    speed?: boolean
    isActive?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | Vendor$companyArgs<ExtArgs>
  }, ExtArgs["result"]["vendor"]>

  export type VendorSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    baseRate?: boolean
    rating?: boolean
    speed?: boolean
    isActive?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VendorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | Vendor$companyArgs<ExtArgs>
    profile?: boolean | Vendor$profileArgs<ExtArgs>
    agreements?: boolean | Vendor$agreementsArgs<ExtArgs>
    rateCards?: boolean | Vendor$rateCardsArgs<ExtArgs>
    quoteResponses?: boolean | Vendor$quoteResponsesArgs<ExtArgs>
    shipments?: boolean | Vendor$shipmentsArgs<ExtArgs>
    drivers?: boolean | Vendor$driversArgs<ExtArgs>
    User?: boolean | Vendor$UserArgs<ExtArgs>
    _count?: boolean | VendorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VendorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | Vendor$companyArgs<ExtArgs>
  }

  export type $VendorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vendor"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs> | null
      profile: Prisma.$VendorProfilePayload<ExtArgs> | null
      agreements: Prisma.$AgreementPayload<ExtArgs>[]
      rateCards: Prisma.$RateCardPayload<ExtArgs>[]
      quoteResponses: Prisma.$QuoteResponsePayload<ExtArgs>[]
      shipments: Prisma.$ShipmentPayload<ExtArgs>[]
      drivers: Prisma.$DriverPayload<ExtArgs>[]
      User: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string | null
      phone: string | null
      baseRate: number | null
      rating: number | null
      speed: number | null
      isActive: boolean
      companyId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vendor"]>
    composites: {}
  }

  type VendorGetPayload<S extends boolean | null | undefined | VendorDefaultArgs> = $Result.GetResult<Prisma.$VendorPayload, S>

  type VendorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VendorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VendorCountAggregateInputType | true
    }

  export interface VendorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vendor'], meta: { name: 'Vendor' } }
    /**
     * Find zero or one Vendor that matches the filter.
     * @param {VendorFindUniqueArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorFindUniqueArgs>(args: SelectSubset<T, VendorFindUniqueArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Vendor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VendorFindUniqueOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Vendor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorFindFirstArgs>(args?: SelectSubset<T, VendorFindFirstArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Vendor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Vendors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vendors
     * const vendors = await prisma.vendor.findMany()
     * 
     * // Get first 10 Vendors
     * const vendors = await prisma.vendor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorWithIdOnly = await prisma.vendor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorFindManyArgs>(args?: SelectSubset<T, VendorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Vendor.
     * @param {VendorCreateArgs} args - Arguments to create a Vendor.
     * @example
     * // Create one Vendor
     * const Vendor = await prisma.vendor.create({
     *   data: {
     *     // ... data to create a Vendor
     *   }
     * })
     * 
     */
    create<T extends VendorCreateArgs>(args: SelectSubset<T, VendorCreateArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Vendors.
     * @param {VendorCreateManyArgs} args - Arguments to create many Vendors.
     * @example
     * // Create many Vendors
     * const vendor = await prisma.vendor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorCreateManyArgs>(args?: SelectSubset<T, VendorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vendors and returns the data saved in the database.
     * @param {VendorCreateManyAndReturnArgs} args - Arguments to create many Vendors.
     * @example
     * // Create many Vendors
     * const vendor = await prisma.vendor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vendors and only return the `id`
     * const vendorWithIdOnly = await prisma.vendor.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VendorCreateManyAndReturnArgs>(args?: SelectSubset<T, VendorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Vendor.
     * @param {VendorDeleteArgs} args - Arguments to delete one Vendor.
     * @example
     * // Delete one Vendor
     * const Vendor = await prisma.vendor.delete({
     *   where: {
     *     // ... filter to delete one Vendor
     *   }
     * })
     * 
     */
    delete<T extends VendorDeleteArgs>(args: SelectSubset<T, VendorDeleteArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Vendor.
     * @param {VendorUpdateArgs} args - Arguments to update one Vendor.
     * @example
     * // Update one Vendor
     * const vendor = await prisma.vendor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorUpdateArgs>(args: SelectSubset<T, VendorUpdateArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Vendors.
     * @param {VendorDeleteManyArgs} args - Arguments to filter Vendors to delete.
     * @example
     * // Delete a few Vendors
     * const { count } = await prisma.vendor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorDeleteManyArgs>(args?: SelectSubset<T, VendorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vendors
     * const vendor = await prisma.vendor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorUpdateManyArgs>(args: SelectSubset<T, VendorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vendor.
     * @param {VendorUpsertArgs} args - Arguments to update or create a Vendor.
     * @example
     * // Update or create a Vendor
     * const vendor = await prisma.vendor.upsert({
     *   create: {
     *     // ... data to create a Vendor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vendor we want to update
     *   }
     * })
     */
    upsert<T extends VendorUpsertArgs>(args: SelectSubset<T, VendorUpsertArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorCountArgs} args - Arguments to filter Vendors to count.
     * @example
     * // Count the number of Vendors
     * const count = await prisma.vendor.count({
     *   where: {
     *     // ... the filter for the Vendors we want to count
     *   }
     * })
    **/
    count<T extends VendorCountArgs>(
      args?: Subset<T, VendorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorAggregateArgs>(args: Subset<T, VendorAggregateArgs>): Prisma.PrismaPromise<GetVendorAggregateType<T>>

    /**
     * Group by Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorGroupByArgs['orderBy'] }
        : { orderBy?: VendorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vendor model
   */
  readonly fields: VendorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vendor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends Vendor$companyArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    profile<T extends Vendor$profileArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$profileArgs<ExtArgs>>): Prisma__VendorProfileClient<$Result.GetResult<Prisma.$VendorProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    agreements<T extends Vendor$agreementsArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$agreementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgreementPayload<ExtArgs>, T, "findMany"> | Null>
    rateCards<T extends Vendor$rateCardsArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$rateCardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RateCardPayload<ExtArgs>, T, "findMany"> | Null>
    quoteResponses<T extends Vendor$quoteResponsesArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$quoteResponsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteResponsePayload<ExtArgs>, T, "findMany"> | Null>
    shipments<T extends Vendor$shipmentsArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$shipmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findMany"> | Null>
    drivers<T extends Vendor$driversArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$driversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findMany"> | Null>
    User<T extends Vendor$UserArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$UserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vendor model
   */ 
  interface VendorFieldRefs {
    readonly id: FieldRef<"Vendor", 'Int'>
    readonly name: FieldRef<"Vendor", 'String'>
    readonly email: FieldRef<"Vendor", 'String'>
    readonly phone: FieldRef<"Vendor", 'String'>
    readonly baseRate: FieldRef<"Vendor", 'Float'>
    readonly rating: FieldRef<"Vendor", 'Float'>
    readonly speed: FieldRef<"Vendor", 'Float'>
    readonly isActive: FieldRef<"Vendor", 'Boolean'>
    readonly companyId: FieldRef<"Vendor", 'Int'>
    readonly createdAt: FieldRef<"Vendor", 'DateTime'>
    readonly updatedAt: FieldRef<"Vendor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Vendor findUnique
   */
  export type VendorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findUniqueOrThrow
   */
  export type VendorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findFirst
   */
  export type VendorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor findFirstOrThrow
   */
  export type VendorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor findMany
   */
  export type VendorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendors to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor create
   */
  export type VendorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to create a Vendor.
     */
    data: XOR<VendorCreateInput, VendorUncheckedCreateInput>
  }

  /**
   * Vendor createMany
   */
  export type VendorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vendors.
     */
    data: VendorCreateManyInput | VendorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vendor createManyAndReturn
   */
  export type VendorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Vendors.
     */
    data: VendorCreateManyInput | VendorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vendor update
   */
  export type VendorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to update a Vendor.
     */
    data: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
    /**
     * Choose, which Vendor to update.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor updateMany
   */
  export type VendorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vendors.
     */
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyInput>
    /**
     * Filter which Vendors to update
     */
    where?: VendorWhereInput
  }

  /**
   * Vendor upsert
   */
  export type VendorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The filter to search for the Vendor to update in case it exists.
     */
    where: VendorWhereUniqueInput
    /**
     * In case the Vendor found by the `where` argument doesn't exist, create a new Vendor with this data.
     */
    create: XOR<VendorCreateInput, VendorUncheckedCreateInput>
    /**
     * In case the Vendor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
  }

  /**
   * Vendor delete
   */
  export type VendorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter which Vendor to delete.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor deleteMany
   */
  export type VendorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendors to delete
     */
    where?: VendorWhereInput
  }

  /**
   * Vendor.company
   */
  export type Vendor$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * Vendor.profile
   */
  export type Vendor$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProfile
     */
    select?: VendorProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProfileInclude<ExtArgs> | null
    where?: VendorProfileWhereInput
  }

  /**
   * Vendor.agreements
   */
  export type Vendor$agreementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementInclude<ExtArgs> | null
    where?: AgreementWhereInput
    orderBy?: AgreementOrderByWithRelationInput | AgreementOrderByWithRelationInput[]
    cursor?: AgreementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgreementScalarFieldEnum | AgreementScalarFieldEnum[]
  }

  /**
   * Vendor.rateCards
   */
  export type Vendor$rateCardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateCard
     */
    select?: RateCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateCardInclude<ExtArgs> | null
    where?: RateCardWhereInput
    orderBy?: RateCardOrderByWithRelationInput | RateCardOrderByWithRelationInput[]
    cursor?: RateCardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RateCardScalarFieldEnum | RateCardScalarFieldEnum[]
  }

  /**
   * Vendor.quoteResponses
   */
  export type Vendor$quoteResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteResponse
     */
    select?: QuoteResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteResponseInclude<ExtArgs> | null
    where?: QuoteResponseWhereInput
    orderBy?: QuoteResponseOrderByWithRelationInput | QuoteResponseOrderByWithRelationInput[]
    cursor?: QuoteResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuoteResponseScalarFieldEnum | QuoteResponseScalarFieldEnum[]
  }

  /**
   * Vendor.shipments
   */
  export type Vendor$shipmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    where?: ShipmentWhereInput
    orderBy?: ShipmentOrderByWithRelationInput | ShipmentOrderByWithRelationInput[]
    cursor?: ShipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShipmentScalarFieldEnum | ShipmentScalarFieldEnum[]
  }

  /**
   * Vendor.drivers
   */
  export type Vendor$driversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    where?: DriverWhereInput
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    cursor?: DriverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DriverScalarFieldEnum | DriverScalarFieldEnum[]
  }

  /**
   * Vendor.User
   */
  export type Vendor$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Vendor without action
   */
  export type VendorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
  }


  /**
   * Model VendorProfile
   */

  export type AggregateVendorProfile = {
    _count: VendorProfileCountAggregateOutputType | null
    _avg: VendorProfileAvgAggregateOutputType | null
    _sum: VendorProfileSumAggregateOutputType | null
    _min: VendorProfileMinAggregateOutputType | null
    _max: VendorProfileMaxAggregateOutputType | null
  }

  export type VendorProfileAvgAggregateOutputType = {
    id: number | null
    vendorId: number | null
  }

  export type VendorProfileSumAggregateOutputType = {
    id: number | null
    vendorId: number | null
  }

  export type VendorProfileMinAggregateOutputType = {
    id: number | null
    vendorId: number | null
    legalName: string | null
    gstin: string | null
    pan: string | null
    tan: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    rcmEligible: boolean | null
    gstRegistrationType: string | null
    contactPerson: string | null
    contactEmail: string | null
    contactPhone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorProfileMaxAggregateOutputType = {
    id: number | null
    vendorId: number | null
    legalName: string | null
    gstin: string | null
    pan: string | null
    tan: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    rcmEligible: boolean | null
    gstRegistrationType: string | null
    contactPerson: string | null
    contactEmail: string | null
    contactPhone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorProfileCountAggregateOutputType = {
    id: number
    vendorId: number
    legalName: number
    gstin: number
    pan: number
    tan: number
    addressLine1: number
    addressLine2: number
    city: number
    state: number
    postalCode: number
    country: number
    rcmEligible: number
    gstRegistrationType: number
    contactPerson: number
    contactEmail: number
    contactPhone: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VendorProfileAvgAggregateInputType = {
    id?: true
    vendorId?: true
  }

  export type VendorProfileSumAggregateInputType = {
    id?: true
    vendorId?: true
  }

  export type VendorProfileMinAggregateInputType = {
    id?: true
    vendorId?: true
    legalName?: true
    gstin?: true
    pan?: true
    tan?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    rcmEligible?: true
    gstRegistrationType?: true
    contactPerson?: true
    contactEmail?: true
    contactPhone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorProfileMaxAggregateInputType = {
    id?: true
    vendorId?: true
    legalName?: true
    gstin?: true
    pan?: true
    tan?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    rcmEligible?: true
    gstRegistrationType?: true
    contactPerson?: true
    contactEmail?: true
    contactPhone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorProfileCountAggregateInputType = {
    id?: true
    vendorId?: true
    legalName?: true
    gstin?: true
    pan?: true
    tan?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    rcmEligible?: true
    gstRegistrationType?: true
    contactPerson?: true
    contactEmail?: true
    contactPhone?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VendorProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorProfile to aggregate.
     */
    where?: VendorProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorProfiles to fetch.
     */
    orderBy?: VendorProfileOrderByWithRelationInput | VendorProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VendorProfiles
    **/
    _count?: true | VendorProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorProfileMaxAggregateInputType
  }

  export type GetVendorProfileAggregateType<T extends VendorProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateVendorProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendorProfile[P]>
      : GetScalarType<T[P], AggregateVendorProfile[P]>
  }




  export type VendorProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorProfileWhereInput
    orderBy?: VendorProfileOrderByWithAggregationInput | VendorProfileOrderByWithAggregationInput[]
    by: VendorProfileScalarFieldEnum[] | VendorProfileScalarFieldEnum
    having?: VendorProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorProfileCountAggregateInputType | true
    _avg?: VendorProfileAvgAggregateInputType
    _sum?: VendorProfileSumAggregateInputType
    _min?: VendorProfileMinAggregateInputType
    _max?: VendorProfileMaxAggregateInputType
  }

  export type VendorProfileGroupByOutputType = {
    id: number
    vendorId: number
    legalName: string | null
    gstin: string | null
    pan: string | null
    tan: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    rcmEligible: boolean
    gstRegistrationType: string | null
    contactPerson: string | null
    contactEmail: string | null
    contactPhone: string | null
    createdAt: Date
    updatedAt: Date
    _count: VendorProfileCountAggregateOutputType | null
    _avg: VendorProfileAvgAggregateOutputType | null
    _sum: VendorProfileSumAggregateOutputType | null
    _min: VendorProfileMinAggregateOutputType | null
    _max: VendorProfileMaxAggregateOutputType | null
  }

  type GetVendorProfileGroupByPayload<T extends VendorProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorProfileGroupByOutputType[P]>
            : GetScalarType<T[P], VendorProfileGroupByOutputType[P]>
        }
      >
    >


  export type VendorProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    legalName?: boolean
    gstin?: boolean
    pan?: boolean
    tan?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    rcmEligible?: boolean
    gstRegistrationType?: boolean
    contactPerson?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorProfile"]>

  export type VendorProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    legalName?: boolean
    gstin?: boolean
    pan?: boolean
    tan?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    rcmEligible?: boolean
    gstRegistrationType?: boolean
    contactPerson?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorProfile"]>

  export type VendorProfileSelectScalar = {
    id?: boolean
    vendorId?: boolean
    legalName?: boolean
    gstin?: boolean
    pan?: boolean
    tan?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    rcmEligible?: boolean
    gstRegistrationType?: boolean
    contactPerson?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VendorProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }
  export type VendorProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }

  export type $VendorProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VendorProfile"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      vendorId: number
      legalName: string | null
      gstin: string | null
      pan: string | null
      tan: string | null
      addressLine1: string | null
      addressLine2: string | null
      city: string | null
      state: string | null
      postalCode: string | null
      country: string | null
      rcmEligible: boolean
      gstRegistrationType: string | null
      contactPerson: string | null
      contactEmail: string | null
      contactPhone: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vendorProfile"]>
    composites: {}
  }

  type VendorProfileGetPayload<S extends boolean | null | undefined | VendorProfileDefaultArgs> = $Result.GetResult<Prisma.$VendorProfilePayload, S>

  type VendorProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VendorProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VendorProfileCountAggregateInputType | true
    }

  export interface VendorProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VendorProfile'], meta: { name: 'VendorProfile' } }
    /**
     * Find zero or one VendorProfile that matches the filter.
     * @param {VendorProfileFindUniqueArgs} args - Arguments to find a VendorProfile
     * @example
     * // Get one VendorProfile
     * const vendorProfile = await prisma.vendorProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorProfileFindUniqueArgs>(args: SelectSubset<T, VendorProfileFindUniqueArgs<ExtArgs>>): Prisma__VendorProfileClient<$Result.GetResult<Prisma.$VendorProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VendorProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VendorProfileFindUniqueOrThrowArgs} args - Arguments to find a VendorProfile
     * @example
     * // Get one VendorProfile
     * const vendorProfile = await prisma.vendorProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorProfileClient<$Result.GetResult<Prisma.$VendorProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VendorProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorProfileFindFirstArgs} args - Arguments to find a VendorProfile
     * @example
     * // Get one VendorProfile
     * const vendorProfile = await prisma.vendorProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorProfileFindFirstArgs>(args?: SelectSubset<T, VendorProfileFindFirstArgs<ExtArgs>>): Prisma__VendorProfileClient<$Result.GetResult<Prisma.$VendorProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VendorProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorProfileFindFirstOrThrowArgs} args - Arguments to find a VendorProfile
     * @example
     * // Get one VendorProfile
     * const vendorProfile = await prisma.vendorProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorProfileClient<$Result.GetResult<Prisma.$VendorProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VendorProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VendorProfiles
     * const vendorProfiles = await prisma.vendorProfile.findMany()
     * 
     * // Get first 10 VendorProfiles
     * const vendorProfiles = await prisma.vendorProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorProfileWithIdOnly = await prisma.vendorProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorProfileFindManyArgs>(args?: SelectSubset<T, VendorProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VendorProfile.
     * @param {VendorProfileCreateArgs} args - Arguments to create a VendorProfile.
     * @example
     * // Create one VendorProfile
     * const VendorProfile = await prisma.vendorProfile.create({
     *   data: {
     *     // ... data to create a VendorProfile
     *   }
     * })
     * 
     */
    create<T extends VendorProfileCreateArgs>(args: SelectSubset<T, VendorProfileCreateArgs<ExtArgs>>): Prisma__VendorProfileClient<$Result.GetResult<Prisma.$VendorProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VendorProfiles.
     * @param {VendorProfileCreateManyArgs} args - Arguments to create many VendorProfiles.
     * @example
     * // Create many VendorProfiles
     * const vendorProfile = await prisma.vendorProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorProfileCreateManyArgs>(args?: SelectSubset<T, VendorProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VendorProfiles and returns the data saved in the database.
     * @param {VendorProfileCreateManyAndReturnArgs} args - Arguments to create many VendorProfiles.
     * @example
     * // Create many VendorProfiles
     * const vendorProfile = await prisma.vendorProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VendorProfiles and only return the `id`
     * const vendorProfileWithIdOnly = await prisma.vendorProfile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VendorProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, VendorProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VendorProfile.
     * @param {VendorProfileDeleteArgs} args - Arguments to delete one VendorProfile.
     * @example
     * // Delete one VendorProfile
     * const VendorProfile = await prisma.vendorProfile.delete({
     *   where: {
     *     // ... filter to delete one VendorProfile
     *   }
     * })
     * 
     */
    delete<T extends VendorProfileDeleteArgs>(args: SelectSubset<T, VendorProfileDeleteArgs<ExtArgs>>): Prisma__VendorProfileClient<$Result.GetResult<Prisma.$VendorProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VendorProfile.
     * @param {VendorProfileUpdateArgs} args - Arguments to update one VendorProfile.
     * @example
     * // Update one VendorProfile
     * const vendorProfile = await prisma.vendorProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorProfileUpdateArgs>(args: SelectSubset<T, VendorProfileUpdateArgs<ExtArgs>>): Prisma__VendorProfileClient<$Result.GetResult<Prisma.$VendorProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VendorProfiles.
     * @param {VendorProfileDeleteManyArgs} args - Arguments to filter VendorProfiles to delete.
     * @example
     * // Delete a few VendorProfiles
     * const { count } = await prisma.vendorProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorProfileDeleteManyArgs>(args?: SelectSubset<T, VendorProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VendorProfiles
     * const vendorProfile = await prisma.vendorProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorProfileUpdateManyArgs>(args: SelectSubset<T, VendorProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VendorProfile.
     * @param {VendorProfileUpsertArgs} args - Arguments to update or create a VendorProfile.
     * @example
     * // Update or create a VendorProfile
     * const vendorProfile = await prisma.vendorProfile.upsert({
     *   create: {
     *     // ... data to create a VendorProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VendorProfile we want to update
     *   }
     * })
     */
    upsert<T extends VendorProfileUpsertArgs>(args: SelectSubset<T, VendorProfileUpsertArgs<ExtArgs>>): Prisma__VendorProfileClient<$Result.GetResult<Prisma.$VendorProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VendorProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorProfileCountArgs} args - Arguments to filter VendorProfiles to count.
     * @example
     * // Count the number of VendorProfiles
     * const count = await prisma.vendorProfile.count({
     *   where: {
     *     // ... the filter for the VendorProfiles we want to count
     *   }
     * })
    **/
    count<T extends VendorProfileCountArgs>(
      args?: Subset<T, VendorProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VendorProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorProfileAggregateArgs>(args: Subset<T, VendorProfileAggregateArgs>): Prisma.PrismaPromise<GetVendorProfileAggregateType<T>>

    /**
     * Group by VendorProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorProfileGroupByArgs['orderBy'] }
        : { orderBy?: VendorProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VendorProfile model
   */
  readonly fields: VendorProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VendorProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VendorProfile model
   */ 
  interface VendorProfileFieldRefs {
    readonly id: FieldRef<"VendorProfile", 'Int'>
    readonly vendorId: FieldRef<"VendorProfile", 'Int'>
    readonly legalName: FieldRef<"VendorProfile", 'String'>
    readonly gstin: FieldRef<"VendorProfile", 'String'>
    readonly pan: FieldRef<"VendorProfile", 'String'>
    readonly tan: FieldRef<"VendorProfile", 'String'>
    readonly addressLine1: FieldRef<"VendorProfile", 'String'>
    readonly addressLine2: FieldRef<"VendorProfile", 'String'>
    readonly city: FieldRef<"VendorProfile", 'String'>
    readonly state: FieldRef<"VendorProfile", 'String'>
    readonly postalCode: FieldRef<"VendorProfile", 'String'>
    readonly country: FieldRef<"VendorProfile", 'String'>
    readonly rcmEligible: FieldRef<"VendorProfile", 'Boolean'>
    readonly gstRegistrationType: FieldRef<"VendorProfile", 'String'>
    readonly contactPerson: FieldRef<"VendorProfile", 'String'>
    readonly contactEmail: FieldRef<"VendorProfile", 'String'>
    readonly contactPhone: FieldRef<"VendorProfile", 'String'>
    readonly createdAt: FieldRef<"VendorProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"VendorProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VendorProfile findUnique
   */
  export type VendorProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProfile
     */
    select?: VendorProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProfileInclude<ExtArgs> | null
    /**
     * Filter, which VendorProfile to fetch.
     */
    where: VendorProfileWhereUniqueInput
  }

  /**
   * VendorProfile findUniqueOrThrow
   */
  export type VendorProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProfile
     */
    select?: VendorProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProfileInclude<ExtArgs> | null
    /**
     * Filter, which VendorProfile to fetch.
     */
    where: VendorProfileWhereUniqueInput
  }

  /**
   * VendorProfile findFirst
   */
  export type VendorProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProfile
     */
    select?: VendorProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProfileInclude<ExtArgs> | null
    /**
     * Filter, which VendorProfile to fetch.
     */
    where?: VendorProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorProfiles to fetch.
     */
    orderBy?: VendorProfileOrderByWithRelationInput | VendorProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorProfiles.
     */
    cursor?: VendorProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorProfiles.
     */
    distinct?: VendorProfileScalarFieldEnum | VendorProfileScalarFieldEnum[]
  }

  /**
   * VendorProfile findFirstOrThrow
   */
  export type VendorProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProfile
     */
    select?: VendorProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProfileInclude<ExtArgs> | null
    /**
     * Filter, which VendorProfile to fetch.
     */
    where?: VendorProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorProfiles to fetch.
     */
    orderBy?: VendorProfileOrderByWithRelationInput | VendorProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorProfiles.
     */
    cursor?: VendorProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorProfiles.
     */
    distinct?: VendorProfileScalarFieldEnum | VendorProfileScalarFieldEnum[]
  }

  /**
   * VendorProfile findMany
   */
  export type VendorProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProfile
     */
    select?: VendorProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProfileInclude<ExtArgs> | null
    /**
     * Filter, which VendorProfiles to fetch.
     */
    where?: VendorProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorProfiles to fetch.
     */
    orderBy?: VendorProfileOrderByWithRelationInput | VendorProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VendorProfiles.
     */
    cursor?: VendorProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorProfiles.
     */
    skip?: number
    distinct?: VendorProfileScalarFieldEnum | VendorProfileScalarFieldEnum[]
  }

  /**
   * VendorProfile create
   */
  export type VendorProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProfile
     */
    select?: VendorProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a VendorProfile.
     */
    data: XOR<VendorProfileCreateInput, VendorProfileUncheckedCreateInput>
  }

  /**
   * VendorProfile createMany
   */
  export type VendorProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VendorProfiles.
     */
    data: VendorProfileCreateManyInput | VendorProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VendorProfile createManyAndReturn
   */
  export type VendorProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProfile
     */
    select?: VendorProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VendorProfiles.
     */
    data: VendorProfileCreateManyInput | VendorProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorProfile update
   */
  export type VendorProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProfile
     */
    select?: VendorProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a VendorProfile.
     */
    data: XOR<VendorProfileUpdateInput, VendorProfileUncheckedUpdateInput>
    /**
     * Choose, which VendorProfile to update.
     */
    where: VendorProfileWhereUniqueInput
  }

  /**
   * VendorProfile updateMany
   */
  export type VendorProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VendorProfiles.
     */
    data: XOR<VendorProfileUpdateManyMutationInput, VendorProfileUncheckedUpdateManyInput>
    /**
     * Filter which VendorProfiles to update
     */
    where?: VendorProfileWhereInput
  }

  /**
   * VendorProfile upsert
   */
  export type VendorProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProfile
     */
    select?: VendorProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the VendorProfile to update in case it exists.
     */
    where: VendorProfileWhereUniqueInput
    /**
     * In case the VendorProfile found by the `where` argument doesn't exist, create a new VendorProfile with this data.
     */
    create: XOR<VendorProfileCreateInput, VendorProfileUncheckedCreateInput>
    /**
     * In case the VendorProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorProfileUpdateInput, VendorProfileUncheckedUpdateInput>
  }

  /**
   * VendorProfile delete
   */
  export type VendorProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProfile
     */
    select?: VendorProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProfileInclude<ExtArgs> | null
    /**
     * Filter which VendorProfile to delete.
     */
    where: VendorProfileWhereUniqueInput
  }

  /**
   * VendorProfile deleteMany
   */
  export type VendorProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorProfiles to delete
     */
    where?: VendorProfileWhereInput
  }

  /**
   * VendorProfile without action
   */
  export type VendorProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorProfile
     */
    select?: VendorProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProfileInclude<ExtArgs> | null
  }


  /**
   * Model Driver
   */

  export type AggregateDriver = {
    _count: DriverCountAggregateOutputType | null
    _avg: DriverAvgAggregateOutputType | null
    _sum: DriverSumAggregateOutputType | null
    _min: DriverMinAggregateOutputType | null
    _max: DriverMaxAggregateOutputType | null
  }

  export type DriverAvgAggregateOutputType = {
    id: number | null
    vendorId: number | null
  }

  export type DriverSumAggregateOutputType = {
    id: number | null
    vendorId: number | null
  }

  export type DriverMinAggregateOutputType = {
    id: number | null
    vendorId: number | null
    name: string | null
    phone: string | null
    licenseNumber: string | null
    vehicleNumber: string | null
    notes: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DriverMaxAggregateOutputType = {
    id: number | null
    vendorId: number | null
    name: string | null
    phone: string | null
    licenseNumber: string | null
    vehicleNumber: string | null
    notes: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DriverCountAggregateOutputType = {
    id: number
    vendorId: number
    name: number
    phone: number
    licenseNumber: number
    vehicleNumber: number
    notes: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DriverAvgAggregateInputType = {
    id?: true
    vendorId?: true
  }

  export type DriverSumAggregateInputType = {
    id?: true
    vendorId?: true
  }

  export type DriverMinAggregateInputType = {
    id?: true
    vendorId?: true
    name?: true
    phone?: true
    licenseNumber?: true
    vehicleNumber?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DriverMaxAggregateInputType = {
    id?: true
    vendorId?: true
    name?: true
    phone?: true
    licenseNumber?: true
    vehicleNumber?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DriverCountAggregateInputType = {
    id?: true
    vendorId?: true
    name?: true
    phone?: true
    licenseNumber?: true
    vehicleNumber?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DriverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Driver to aggregate.
     */
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Drivers
    **/
    _count?: true | DriverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DriverAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DriverSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DriverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DriverMaxAggregateInputType
  }

  export type GetDriverAggregateType<T extends DriverAggregateArgs> = {
        [P in keyof T & keyof AggregateDriver]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDriver[P]>
      : GetScalarType<T[P], AggregateDriver[P]>
  }




  export type DriverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriverWhereInput
    orderBy?: DriverOrderByWithAggregationInput | DriverOrderByWithAggregationInput[]
    by: DriverScalarFieldEnum[] | DriverScalarFieldEnum
    having?: DriverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DriverCountAggregateInputType | true
    _avg?: DriverAvgAggregateInputType
    _sum?: DriverSumAggregateInputType
    _min?: DriverMinAggregateInputType
    _max?: DriverMaxAggregateInputType
  }

  export type DriverGroupByOutputType = {
    id: number
    vendorId: number
    name: string
    phone: string | null
    licenseNumber: string | null
    vehicleNumber: string | null
    notes: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: DriverCountAggregateOutputType | null
    _avg: DriverAvgAggregateOutputType | null
    _sum: DriverSumAggregateOutputType | null
    _min: DriverMinAggregateOutputType | null
    _max: DriverMaxAggregateOutputType | null
  }

  type GetDriverGroupByPayload<T extends DriverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DriverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DriverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DriverGroupByOutputType[P]>
            : GetScalarType<T[P], DriverGroupByOutputType[P]>
        }
      >
    >


  export type DriverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    name?: boolean
    phone?: boolean
    licenseNumber?: boolean
    vehicleNumber?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["driver"]>

  export type DriverSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    name?: boolean
    phone?: boolean
    licenseNumber?: boolean
    vehicleNumber?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["driver"]>

  export type DriverSelectScalar = {
    id?: boolean
    vendorId?: boolean
    name?: boolean
    phone?: boolean
    licenseNumber?: boolean
    vehicleNumber?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DriverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }
  export type DriverIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }

  export type $DriverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Driver"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      vendorId: number
      name: string
      phone: string | null
      licenseNumber: string | null
      vehicleNumber: string | null
      notes: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["driver"]>
    composites: {}
  }

  type DriverGetPayload<S extends boolean | null | undefined | DriverDefaultArgs> = $Result.GetResult<Prisma.$DriverPayload, S>

  type DriverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DriverFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DriverCountAggregateInputType | true
    }

  export interface DriverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Driver'], meta: { name: 'Driver' } }
    /**
     * Find zero or one Driver that matches the filter.
     * @param {DriverFindUniqueArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DriverFindUniqueArgs>(args: SelectSubset<T, DriverFindUniqueArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Driver that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DriverFindUniqueOrThrowArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DriverFindUniqueOrThrowArgs>(args: SelectSubset<T, DriverFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Driver that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverFindFirstArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DriverFindFirstArgs>(args?: SelectSubset<T, DriverFindFirstArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Driver that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverFindFirstOrThrowArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DriverFindFirstOrThrowArgs>(args?: SelectSubset<T, DriverFindFirstOrThrowArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Drivers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Drivers
     * const drivers = await prisma.driver.findMany()
     * 
     * // Get first 10 Drivers
     * const drivers = await prisma.driver.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const driverWithIdOnly = await prisma.driver.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DriverFindManyArgs>(args?: SelectSubset<T, DriverFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Driver.
     * @param {DriverCreateArgs} args - Arguments to create a Driver.
     * @example
     * // Create one Driver
     * const Driver = await prisma.driver.create({
     *   data: {
     *     // ... data to create a Driver
     *   }
     * })
     * 
     */
    create<T extends DriverCreateArgs>(args: SelectSubset<T, DriverCreateArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Drivers.
     * @param {DriverCreateManyArgs} args - Arguments to create many Drivers.
     * @example
     * // Create many Drivers
     * const driver = await prisma.driver.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DriverCreateManyArgs>(args?: SelectSubset<T, DriverCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Drivers and returns the data saved in the database.
     * @param {DriverCreateManyAndReturnArgs} args - Arguments to create many Drivers.
     * @example
     * // Create many Drivers
     * const driver = await prisma.driver.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Drivers and only return the `id`
     * const driverWithIdOnly = await prisma.driver.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DriverCreateManyAndReturnArgs>(args?: SelectSubset<T, DriverCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Driver.
     * @param {DriverDeleteArgs} args - Arguments to delete one Driver.
     * @example
     * // Delete one Driver
     * const Driver = await prisma.driver.delete({
     *   where: {
     *     // ... filter to delete one Driver
     *   }
     * })
     * 
     */
    delete<T extends DriverDeleteArgs>(args: SelectSubset<T, DriverDeleteArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Driver.
     * @param {DriverUpdateArgs} args - Arguments to update one Driver.
     * @example
     * // Update one Driver
     * const driver = await prisma.driver.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DriverUpdateArgs>(args: SelectSubset<T, DriverUpdateArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Drivers.
     * @param {DriverDeleteManyArgs} args - Arguments to filter Drivers to delete.
     * @example
     * // Delete a few Drivers
     * const { count } = await prisma.driver.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DriverDeleteManyArgs>(args?: SelectSubset<T, DriverDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Drivers
     * const driver = await prisma.driver.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DriverUpdateManyArgs>(args: SelectSubset<T, DriverUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Driver.
     * @param {DriverUpsertArgs} args - Arguments to update or create a Driver.
     * @example
     * // Update or create a Driver
     * const driver = await prisma.driver.upsert({
     *   create: {
     *     // ... data to create a Driver
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Driver we want to update
     *   }
     * })
     */
    upsert<T extends DriverUpsertArgs>(args: SelectSubset<T, DriverUpsertArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Drivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverCountArgs} args - Arguments to filter Drivers to count.
     * @example
     * // Count the number of Drivers
     * const count = await prisma.driver.count({
     *   where: {
     *     // ... the filter for the Drivers we want to count
     *   }
     * })
    **/
    count<T extends DriverCountArgs>(
      args?: Subset<T, DriverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DriverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Driver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DriverAggregateArgs>(args: Subset<T, DriverAggregateArgs>): Prisma.PrismaPromise<GetDriverAggregateType<T>>

    /**
     * Group by Driver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DriverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DriverGroupByArgs['orderBy'] }
        : { orderBy?: DriverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DriverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDriverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Driver model
   */
  readonly fields: DriverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Driver.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DriverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Driver model
   */ 
  interface DriverFieldRefs {
    readonly id: FieldRef<"Driver", 'Int'>
    readonly vendorId: FieldRef<"Driver", 'Int'>
    readonly name: FieldRef<"Driver", 'String'>
    readonly phone: FieldRef<"Driver", 'String'>
    readonly licenseNumber: FieldRef<"Driver", 'String'>
    readonly vehicleNumber: FieldRef<"Driver", 'String'>
    readonly notes: FieldRef<"Driver", 'String'>
    readonly isActive: FieldRef<"Driver", 'Boolean'>
    readonly createdAt: FieldRef<"Driver", 'DateTime'>
    readonly updatedAt: FieldRef<"Driver", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Driver findUnique
   */
  export type DriverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Driver to fetch.
     */
    where: DriverWhereUniqueInput
  }

  /**
   * Driver findUniqueOrThrow
   */
  export type DriverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Driver to fetch.
     */
    where: DriverWhereUniqueInput
  }

  /**
   * Driver findFirst
   */
  export type DriverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Driver to fetch.
     */
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Drivers.
     */
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Drivers.
     */
    distinct?: DriverScalarFieldEnum | DriverScalarFieldEnum[]
  }

  /**
   * Driver findFirstOrThrow
   */
  export type DriverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Driver to fetch.
     */
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Drivers.
     */
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Drivers.
     */
    distinct?: DriverScalarFieldEnum | DriverScalarFieldEnum[]
  }

  /**
   * Driver findMany
   */
  export type DriverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Drivers to fetch.
     */
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Drivers.
     */
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    distinct?: DriverScalarFieldEnum | DriverScalarFieldEnum[]
  }

  /**
   * Driver create
   */
  export type DriverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * The data needed to create a Driver.
     */
    data: XOR<DriverCreateInput, DriverUncheckedCreateInput>
  }

  /**
   * Driver createMany
   */
  export type DriverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Drivers.
     */
    data: DriverCreateManyInput | DriverCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Driver createManyAndReturn
   */
  export type DriverCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Drivers.
     */
    data: DriverCreateManyInput | DriverCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Driver update
   */
  export type DriverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * The data needed to update a Driver.
     */
    data: XOR<DriverUpdateInput, DriverUncheckedUpdateInput>
    /**
     * Choose, which Driver to update.
     */
    where: DriverWhereUniqueInput
  }

  /**
   * Driver updateMany
   */
  export type DriverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Drivers.
     */
    data: XOR<DriverUpdateManyMutationInput, DriverUncheckedUpdateManyInput>
    /**
     * Filter which Drivers to update
     */
    where?: DriverWhereInput
  }

  /**
   * Driver upsert
   */
  export type DriverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * The filter to search for the Driver to update in case it exists.
     */
    where: DriverWhereUniqueInput
    /**
     * In case the Driver found by the `where` argument doesn't exist, create a new Driver with this data.
     */
    create: XOR<DriverCreateInput, DriverUncheckedCreateInput>
    /**
     * In case the Driver was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DriverUpdateInput, DriverUncheckedUpdateInput>
  }

  /**
   * Driver delete
   */
  export type DriverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter which Driver to delete.
     */
    where: DriverWhereUniqueInput
  }

  /**
   * Driver deleteMany
   */
  export type DriverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Drivers to delete
     */
    where?: DriverWhereInput
  }

  /**
   * Driver without action
   */
  export type DriverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
  }


  /**
   * Model Agreement
   */

  export type AggregateAgreement = {
    _count: AgreementCountAggregateOutputType | null
    _avg: AgreementAvgAggregateOutputType | null
    _sum: AgreementSumAggregateOutputType | null
    _min: AgreementMinAggregateOutputType | null
    _max: AgreementMaxAggregateOutputType | null
  }

  export type AgreementAvgAggregateOutputType = {
    id: number | null
    vendorId: number | null
    reviewedById: number | null
    companyId: number | null
  }

  export type AgreementSumAggregateOutputType = {
    id: number | null
    vendorId: number | null
    reviewedById: number | null
    companyId: number | null
  }

  export type AgreementMinAggregateOutputType = {
    id: number | null
    vendorId: number | null
    title: string | null
    referenceCode: string | null
    status: string | null
    effectiveFrom: Date | null
    effectiveTo: Date | null
    notes: string | null
    reviewedById: number | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: number | null
  }

  export type AgreementMaxAggregateOutputType = {
    id: number | null
    vendorId: number | null
    title: string | null
    referenceCode: string | null
    status: string | null
    effectiveFrom: Date | null
    effectiveTo: Date | null
    notes: string | null
    reviewedById: number | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: number | null
  }

  export type AgreementCountAggregateOutputType = {
    id: number
    vendorId: number
    title: number
    referenceCode: number
    status: number
    effectiveFrom: number
    effectiveTo: number
    notes: number
    reviewedById: number
    createdAt: number
    updatedAt: number
    companyId: number
    _all: number
  }


  export type AgreementAvgAggregateInputType = {
    id?: true
    vendorId?: true
    reviewedById?: true
    companyId?: true
  }

  export type AgreementSumAggregateInputType = {
    id?: true
    vendorId?: true
    reviewedById?: true
    companyId?: true
  }

  export type AgreementMinAggregateInputType = {
    id?: true
    vendorId?: true
    title?: true
    referenceCode?: true
    status?: true
    effectiveFrom?: true
    effectiveTo?: true
    notes?: true
    reviewedById?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type AgreementMaxAggregateInputType = {
    id?: true
    vendorId?: true
    title?: true
    referenceCode?: true
    status?: true
    effectiveFrom?: true
    effectiveTo?: true
    notes?: true
    reviewedById?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type AgreementCountAggregateInputType = {
    id?: true
    vendorId?: true
    title?: true
    referenceCode?: true
    status?: true
    effectiveFrom?: true
    effectiveTo?: true
    notes?: true
    reviewedById?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    _all?: true
  }

  export type AgreementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agreement to aggregate.
     */
    where?: AgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agreements to fetch.
     */
    orderBy?: AgreementOrderByWithRelationInput | AgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agreements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Agreements
    **/
    _count?: true | AgreementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgreementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgreementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgreementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgreementMaxAggregateInputType
  }

  export type GetAgreementAggregateType<T extends AgreementAggregateArgs> = {
        [P in keyof T & keyof AggregateAgreement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgreement[P]>
      : GetScalarType<T[P], AggregateAgreement[P]>
  }




  export type AgreementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgreementWhereInput
    orderBy?: AgreementOrderByWithAggregationInput | AgreementOrderByWithAggregationInput[]
    by: AgreementScalarFieldEnum[] | AgreementScalarFieldEnum
    having?: AgreementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgreementCountAggregateInputType | true
    _avg?: AgreementAvgAggregateInputType
    _sum?: AgreementSumAggregateInputType
    _min?: AgreementMinAggregateInputType
    _max?: AgreementMaxAggregateInputType
  }

  export type AgreementGroupByOutputType = {
    id: number
    vendorId: number
    title: string
    referenceCode: string
    status: string
    effectiveFrom: Date | null
    effectiveTo: Date | null
    notes: string | null
    reviewedById: number | null
    createdAt: Date
    updatedAt: Date
    companyId: number | null
    _count: AgreementCountAggregateOutputType | null
    _avg: AgreementAvgAggregateOutputType | null
    _sum: AgreementSumAggregateOutputType | null
    _min: AgreementMinAggregateOutputType | null
    _max: AgreementMaxAggregateOutputType | null
  }

  type GetAgreementGroupByPayload<T extends AgreementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgreementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgreementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgreementGroupByOutputType[P]>
            : GetScalarType<T[P], AgreementGroupByOutputType[P]>
        }
      >
    >


  export type AgreementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    title?: boolean
    referenceCode?: boolean
    status?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    notes?: boolean
    reviewedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    reviewedBy?: boolean | Agreement$reviewedByArgs<ExtArgs>
    rateCards?: boolean | Agreement$rateCardsArgs<ExtArgs>
    Company?: boolean | Agreement$CompanyArgs<ExtArgs>
    _count?: boolean | AgreementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agreement"]>

  export type AgreementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendorId?: boolean
    title?: boolean
    referenceCode?: boolean
    status?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    notes?: boolean
    reviewedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    reviewedBy?: boolean | Agreement$reviewedByArgs<ExtArgs>
    Company?: boolean | Agreement$CompanyArgs<ExtArgs>
  }, ExtArgs["result"]["agreement"]>

  export type AgreementSelectScalar = {
    id?: boolean
    vendorId?: boolean
    title?: boolean
    referenceCode?: boolean
    status?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    notes?: boolean
    reviewedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
  }

  export type AgreementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    reviewedBy?: boolean | Agreement$reviewedByArgs<ExtArgs>
    rateCards?: boolean | Agreement$rateCardsArgs<ExtArgs>
    Company?: boolean | Agreement$CompanyArgs<ExtArgs>
    _count?: boolean | AgreementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AgreementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    reviewedBy?: boolean | Agreement$reviewedByArgs<ExtArgs>
    Company?: boolean | Agreement$CompanyArgs<ExtArgs>
  }

  export type $AgreementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Agreement"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
      reviewedBy: Prisma.$UserPayload<ExtArgs> | null
      rateCards: Prisma.$RateCardPayload<ExtArgs>[]
      Company: Prisma.$CompanyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      vendorId: number
      title: string
      referenceCode: string
      status: string
      effectiveFrom: Date | null
      effectiveTo: Date | null
      notes: string | null
      reviewedById: number | null
      createdAt: Date
      updatedAt: Date
      companyId: number | null
    }, ExtArgs["result"]["agreement"]>
    composites: {}
  }

  type AgreementGetPayload<S extends boolean | null | undefined | AgreementDefaultArgs> = $Result.GetResult<Prisma.$AgreementPayload, S>

  type AgreementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AgreementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AgreementCountAggregateInputType | true
    }

  export interface AgreementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Agreement'], meta: { name: 'Agreement' } }
    /**
     * Find zero or one Agreement that matches the filter.
     * @param {AgreementFindUniqueArgs} args - Arguments to find a Agreement
     * @example
     * // Get one Agreement
     * const agreement = await prisma.agreement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgreementFindUniqueArgs>(args: SelectSubset<T, AgreementFindUniqueArgs<ExtArgs>>): Prisma__AgreementClient<$Result.GetResult<Prisma.$AgreementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Agreement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AgreementFindUniqueOrThrowArgs} args - Arguments to find a Agreement
     * @example
     * // Get one Agreement
     * const agreement = await prisma.agreement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgreementFindUniqueOrThrowArgs>(args: SelectSubset<T, AgreementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgreementClient<$Result.GetResult<Prisma.$AgreementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Agreement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementFindFirstArgs} args - Arguments to find a Agreement
     * @example
     * // Get one Agreement
     * const agreement = await prisma.agreement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgreementFindFirstArgs>(args?: SelectSubset<T, AgreementFindFirstArgs<ExtArgs>>): Prisma__AgreementClient<$Result.GetResult<Prisma.$AgreementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Agreement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementFindFirstOrThrowArgs} args - Arguments to find a Agreement
     * @example
     * // Get one Agreement
     * const agreement = await prisma.agreement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgreementFindFirstOrThrowArgs>(args?: SelectSubset<T, AgreementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgreementClient<$Result.GetResult<Prisma.$AgreementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Agreements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agreements
     * const agreements = await prisma.agreement.findMany()
     * 
     * // Get first 10 Agreements
     * const agreements = await prisma.agreement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agreementWithIdOnly = await prisma.agreement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgreementFindManyArgs>(args?: SelectSubset<T, AgreementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgreementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Agreement.
     * @param {AgreementCreateArgs} args - Arguments to create a Agreement.
     * @example
     * // Create one Agreement
     * const Agreement = await prisma.agreement.create({
     *   data: {
     *     // ... data to create a Agreement
     *   }
     * })
     * 
     */
    create<T extends AgreementCreateArgs>(args: SelectSubset<T, AgreementCreateArgs<ExtArgs>>): Prisma__AgreementClient<$Result.GetResult<Prisma.$AgreementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Agreements.
     * @param {AgreementCreateManyArgs} args - Arguments to create many Agreements.
     * @example
     * // Create many Agreements
     * const agreement = await prisma.agreement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgreementCreateManyArgs>(args?: SelectSubset<T, AgreementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Agreements and returns the data saved in the database.
     * @param {AgreementCreateManyAndReturnArgs} args - Arguments to create many Agreements.
     * @example
     * // Create many Agreements
     * const agreement = await prisma.agreement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Agreements and only return the `id`
     * const agreementWithIdOnly = await prisma.agreement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgreementCreateManyAndReturnArgs>(args?: SelectSubset<T, AgreementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgreementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Agreement.
     * @param {AgreementDeleteArgs} args - Arguments to delete one Agreement.
     * @example
     * // Delete one Agreement
     * const Agreement = await prisma.agreement.delete({
     *   where: {
     *     // ... filter to delete one Agreement
     *   }
     * })
     * 
     */
    delete<T extends AgreementDeleteArgs>(args: SelectSubset<T, AgreementDeleteArgs<ExtArgs>>): Prisma__AgreementClient<$Result.GetResult<Prisma.$AgreementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Agreement.
     * @param {AgreementUpdateArgs} args - Arguments to update one Agreement.
     * @example
     * // Update one Agreement
     * const agreement = await prisma.agreement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgreementUpdateArgs>(args: SelectSubset<T, AgreementUpdateArgs<ExtArgs>>): Prisma__AgreementClient<$Result.GetResult<Prisma.$AgreementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Agreements.
     * @param {AgreementDeleteManyArgs} args - Arguments to filter Agreements to delete.
     * @example
     * // Delete a few Agreements
     * const { count } = await prisma.agreement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgreementDeleteManyArgs>(args?: SelectSubset<T, AgreementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agreements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agreements
     * const agreement = await prisma.agreement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgreementUpdateManyArgs>(args: SelectSubset<T, AgreementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Agreement.
     * @param {AgreementUpsertArgs} args - Arguments to update or create a Agreement.
     * @example
     * // Update or create a Agreement
     * const agreement = await prisma.agreement.upsert({
     *   create: {
     *     // ... data to create a Agreement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agreement we want to update
     *   }
     * })
     */
    upsert<T extends AgreementUpsertArgs>(args: SelectSubset<T, AgreementUpsertArgs<ExtArgs>>): Prisma__AgreementClient<$Result.GetResult<Prisma.$AgreementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Agreements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementCountArgs} args - Arguments to filter Agreements to count.
     * @example
     * // Count the number of Agreements
     * const count = await prisma.agreement.count({
     *   where: {
     *     // ... the filter for the Agreements we want to count
     *   }
     * })
    **/
    count<T extends AgreementCountArgs>(
      args?: Subset<T, AgreementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgreementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agreement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgreementAggregateArgs>(args: Subset<T, AgreementAggregateArgs>): Prisma.PrismaPromise<GetAgreementAggregateType<T>>

    /**
     * Group by Agreement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgreementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgreementGroupByArgs['orderBy'] }
        : { orderBy?: AgreementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgreementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgreementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Agreement model
   */
  readonly fields: AgreementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Agreement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgreementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    reviewedBy<T extends Agreement$reviewedByArgs<ExtArgs> = {}>(args?: Subset<T, Agreement$reviewedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    rateCards<T extends Agreement$rateCardsArgs<ExtArgs> = {}>(args?: Subset<T, Agreement$rateCardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RateCardPayload<ExtArgs>, T, "findMany"> | Null>
    Company<T extends Agreement$CompanyArgs<ExtArgs> = {}>(args?: Subset<T, Agreement$CompanyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Agreement model
   */ 
  interface AgreementFieldRefs {
    readonly id: FieldRef<"Agreement", 'Int'>
    readonly vendorId: FieldRef<"Agreement", 'Int'>
    readonly title: FieldRef<"Agreement", 'String'>
    readonly referenceCode: FieldRef<"Agreement", 'String'>
    readonly status: FieldRef<"Agreement", 'String'>
    readonly effectiveFrom: FieldRef<"Agreement", 'DateTime'>
    readonly effectiveTo: FieldRef<"Agreement", 'DateTime'>
    readonly notes: FieldRef<"Agreement", 'String'>
    readonly reviewedById: FieldRef<"Agreement", 'Int'>
    readonly createdAt: FieldRef<"Agreement", 'DateTime'>
    readonly updatedAt: FieldRef<"Agreement", 'DateTime'>
    readonly companyId: FieldRef<"Agreement", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Agreement findUnique
   */
  export type AgreementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementInclude<ExtArgs> | null
    /**
     * Filter, which Agreement to fetch.
     */
    where: AgreementWhereUniqueInput
  }

  /**
   * Agreement findUniqueOrThrow
   */
  export type AgreementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementInclude<ExtArgs> | null
    /**
     * Filter, which Agreement to fetch.
     */
    where: AgreementWhereUniqueInput
  }

  /**
   * Agreement findFirst
   */
  export type AgreementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementInclude<ExtArgs> | null
    /**
     * Filter, which Agreement to fetch.
     */
    where?: AgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agreements to fetch.
     */
    orderBy?: AgreementOrderByWithRelationInput | AgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agreements.
     */
    cursor?: AgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agreements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agreements.
     */
    distinct?: AgreementScalarFieldEnum | AgreementScalarFieldEnum[]
  }

  /**
   * Agreement findFirstOrThrow
   */
  export type AgreementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementInclude<ExtArgs> | null
    /**
     * Filter, which Agreement to fetch.
     */
    where?: AgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agreements to fetch.
     */
    orderBy?: AgreementOrderByWithRelationInput | AgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agreements.
     */
    cursor?: AgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agreements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agreements.
     */
    distinct?: AgreementScalarFieldEnum | AgreementScalarFieldEnum[]
  }

  /**
   * Agreement findMany
   */
  export type AgreementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementInclude<ExtArgs> | null
    /**
     * Filter, which Agreements to fetch.
     */
    where?: AgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agreements to fetch.
     */
    orderBy?: AgreementOrderByWithRelationInput | AgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Agreements.
     */
    cursor?: AgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agreements.
     */
    skip?: number
    distinct?: AgreementScalarFieldEnum | AgreementScalarFieldEnum[]
  }

  /**
   * Agreement create
   */
  export type AgreementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementInclude<ExtArgs> | null
    /**
     * The data needed to create a Agreement.
     */
    data: XOR<AgreementCreateInput, AgreementUncheckedCreateInput>
  }

  /**
   * Agreement createMany
   */
  export type AgreementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Agreements.
     */
    data: AgreementCreateManyInput | AgreementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agreement createManyAndReturn
   */
  export type AgreementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Agreements.
     */
    data: AgreementCreateManyInput | AgreementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Agreement update
   */
  export type AgreementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementInclude<ExtArgs> | null
    /**
     * The data needed to update a Agreement.
     */
    data: XOR<AgreementUpdateInput, AgreementUncheckedUpdateInput>
    /**
     * Choose, which Agreement to update.
     */
    where: AgreementWhereUniqueInput
  }

  /**
   * Agreement updateMany
   */
  export type AgreementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Agreements.
     */
    data: XOR<AgreementUpdateManyMutationInput, AgreementUncheckedUpdateManyInput>
    /**
     * Filter which Agreements to update
     */
    where?: AgreementWhereInput
  }

  /**
   * Agreement upsert
   */
  export type AgreementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementInclude<ExtArgs> | null
    /**
     * The filter to search for the Agreement to update in case it exists.
     */
    where: AgreementWhereUniqueInput
    /**
     * In case the Agreement found by the `where` argument doesn't exist, create a new Agreement with this data.
     */
    create: XOR<AgreementCreateInput, AgreementUncheckedCreateInput>
    /**
     * In case the Agreement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgreementUpdateInput, AgreementUncheckedUpdateInput>
  }

  /**
   * Agreement delete
   */
  export type AgreementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementInclude<ExtArgs> | null
    /**
     * Filter which Agreement to delete.
     */
    where: AgreementWhereUniqueInput
  }

  /**
   * Agreement deleteMany
   */
  export type AgreementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agreements to delete
     */
    where?: AgreementWhereInput
  }

  /**
   * Agreement.reviewedBy
   */
  export type Agreement$reviewedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Agreement.rateCards
   */
  export type Agreement$rateCardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateCard
     */
    select?: RateCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateCardInclude<ExtArgs> | null
    where?: RateCardWhereInput
    orderBy?: RateCardOrderByWithRelationInput | RateCardOrderByWithRelationInput[]
    cursor?: RateCardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RateCardScalarFieldEnum | RateCardScalarFieldEnum[]
  }

  /**
   * Agreement.Company
   */
  export type Agreement$CompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * Agreement without action
   */
  export type AgreementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementInclude<ExtArgs> | null
  }


  /**
   * Model RateCard
   */

  export type AggregateRateCard = {
    _count: RateCardCountAggregateOutputType | null
    _avg: RateCardAvgAggregateOutputType | null
    _sum: RateCardSumAggregateOutputType | null
    _min: RateCardMinAggregateOutputType | null
    _max: RateCardMaxAggregateOutputType | null
  }

  export type RateCardAvgAggregateOutputType = {
    id: number | null
    agreementId: number | null
    distanceKm: number | null
    ratePerKm: number | null
    vendorId: number | null
  }

  export type RateCardSumAggregateOutputType = {
    id: number | null
    agreementId: number | null
    distanceKm: number | null
    ratePerKm: number | null
    vendorId: number | null
  }

  export type RateCardMinAggregateOutputType = {
    id: number | null
    agreementId: number | null
    routeName: string | null
    origin: string | null
    destination: string | null
    distanceKm: number | null
    ratePerKm: number | null
    uom: string | null
    vehicleType: string | null
    effectiveFrom: Date | null
    remarks: string | null
    createdAt: Date | null
    updatedAt: Date | null
    vendorId: number | null
  }

  export type RateCardMaxAggregateOutputType = {
    id: number | null
    agreementId: number | null
    routeName: string | null
    origin: string | null
    destination: string | null
    distanceKm: number | null
    ratePerKm: number | null
    uom: string | null
    vehicleType: string | null
    effectiveFrom: Date | null
    remarks: string | null
    createdAt: Date | null
    updatedAt: Date | null
    vendorId: number | null
  }

  export type RateCardCountAggregateOutputType = {
    id: number
    agreementId: number
    routeName: number
    origin: number
    destination: number
    distanceKm: number
    ratePerKm: number
    uom: number
    vehicleType: number
    effectiveFrom: number
    remarks: number
    createdAt: number
    updatedAt: number
    vendorId: number
    _all: number
  }


  export type RateCardAvgAggregateInputType = {
    id?: true
    agreementId?: true
    distanceKm?: true
    ratePerKm?: true
    vendorId?: true
  }

  export type RateCardSumAggregateInputType = {
    id?: true
    agreementId?: true
    distanceKm?: true
    ratePerKm?: true
    vendorId?: true
  }

  export type RateCardMinAggregateInputType = {
    id?: true
    agreementId?: true
    routeName?: true
    origin?: true
    destination?: true
    distanceKm?: true
    ratePerKm?: true
    uom?: true
    vehicleType?: true
    effectiveFrom?: true
    remarks?: true
    createdAt?: true
    updatedAt?: true
    vendorId?: true
  }

  export type RateCardMaxAggregateInputType = {
    id?: true
    agreementId?: true
    routeName?: true
    origin?: true
    destination?: true
    distanceKm?: true
    ratePerKm?: true
    uom?: true
    vehicleType?: true
    effectiveFrom?: true
    remarks?: true
    createdAt?: true
    updatedAt?: true
    vendorId?: true
  }

  export type RateCardCountAggregateInputType = {
    id?: true
    agreementId?: true
    routeName?: true
    origin?: true
    destination?: true
    distanceKm?: true
    ratePerKm?: true
    uom?: true
    vehicleType?: true
    effectiveFrom?: true
    remarks?: true
    createdAt?: true
    updatedAt?: true
    vendorId?: true
    _all?: true
  }

  export type RateCardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RateCard to aggregate.
     */
    where?: RateCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RateCards to fetch.
     */
    orderBy?: RateCardOrderByWithRelationInput | RateCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RateCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RateCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RateCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RateCards
    **/
    _count?: true | RateCardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RateCardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RateCardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RateCardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RateCardMaxAggregateInputType
  }

  export type GetRateCardAggregateType<T extends RateCardAggregateArgs> = {
        [P in keyof T & keyof AggregateRateCard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRateCard[P]>
      : GetScalarType<T[P], AggregateRateCard[P]>
  }




  export type RateCardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RateCardWhereInput
    orderBy?: RateCardOrderByWithAggregationInput | RateCardOrderByWithAggregationInput[]
    by: RateCardScalarFieldEnum[] | RateCardScalarFieldEnum
    having?: RateCardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RateCardCountAggregateInputType | true
    _avg?: RateCardAvgAggregateInputType
    _sum?: RateCardSumAggregateInputType
    _min?: RateCardMinAggregateInputType
    _max?: RateCardMaxAggregateInputType
  }

  export type RateCardGroupByOutputType = {
    id: number
    agreementId: number
    routeName: string
    origin: string
    destination: string
    distanceKm: number | null
    ratePerKm: number
    uom: string
    vehicleType: string
    effectiveFrom: Date | null
    remarks: string | null
    createdAt: Date
    updatedAt: Date
    vendorId: number | null
    _count: RateCardCountAggregateOutputType | null
    _avg: RateCardAvgAggregateOutputType | null
    _sum: RateCardSumAggregateOutputType | null
    _min: RateCardMinAggregateOutputType | null
    _max: RateCardMaxAggregateOutputType | null
  }

  type GetRateCardGroupByPayload<T extends RateCardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RateCardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RateCardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RateCardGroupByOutputType[P]>
            : GetScalarType<T[P], RateCardGroupByOutputType[P]>
        }
      >
    >


  export type RateCardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agreementId?: boolean
    routeName?: boolean
    origin?: boolean
    destination?: boolean
    distanceKm?: boolean
    ratePerKm?: boolean
    uom?: boolean
    vehicleType?: boolean
    effectiveFrom?: boolean
    remarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendorId?: boolean
    agreement?: boolean | AgreementDefaultArgs<ExtArgs>
    Vendor?: boolean | RateCard$VendorArgs<ExtArgs>
    shipments?: boolean | RateCard$shipmentsArgs<ExtArgs>
    _count?: boolean | RateCardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rateCard"]>

  export type RateCardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agreementId?: boolean
    routeName?: boolean
    origin?: boolean
    destination?: boolean
    distanceKm?: boolean
    ratePerKm?: boolean
    uom?: boolean
    vehicleType?: boolean
    effectiveFrom?: boolean
    remarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendorId?: boolean
    agreement?: boolean | AgreementDefaultArgs<ExtArgs>
    Vendor?: boolean | RateCard$VendorArgs<ExtArgs>
  }, ExtArgs["result"]["rateCard"]>

  export type RateCardSelectScalar = {
    id?: boolean
    agreementId?: boolean
    routeName?: boolean
    origin?: boolean
    destination?: boolean
    distanceKm?: boolean
    ratePerKm?: boolean
    uom?: boolean
    vehicleType?: boolean
    effectiveFrom?: boolean
    remarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendorId?: boolean
  }

  export type RateCardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agreement?: boolean | AgreementDefaultArgs<ExtArgs>
    Vendor?: boolean | RateCard$VendorArgs<ExtArgs>
    shipments?: boolean | RateCard$shipmentsArgs<ExtArgs>
    _count?: boolean | RateCardCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RateCardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agreement?: boolean | AgreementDefaultArgs<ExtArgs>
    Vendor?: boolean | RateCard$VendorArgs<ExtArgs>
  }

  export type $RateCardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RateCard"
    objects: {
      agreement: Prisma.$AgreementPayload<ExtArgs>
      Vendor: Prisma.$VendorPayload<ExtArgs> | null
      shipments: Prisma.$ShipmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      agreementId: number
      routeName: string
      origin: string
      destination: string
      distanceKm: number | null
      ratePerKm: number
      uom: string
      vehicleType: string
      effectiveFrom: Date | null
      remarks: string | null
      createdAt: Date
      updatedAt: Date
      vendorId: number | null
    }, ExtArgs["result"]["rateCard"]>
    composites: {}
  }

  type RateCardGetPayload<S extends boolean | null | undefined | RateCardDefaultArgs> = $Result.GetResult<Prisma.$RateCardPayload, S>

  type RateCardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RateCardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RateCardCountAggregateInputType | true
    }

  export interface RateCardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RateCard'], meta: { name: 'RateCard' } }
    /**
     * Find zero or one RateCard that matches the filter.
     * @param {RateCardFindUniqueArgs} args - Arguments to find a RateCard
     * @example
     * // Get one RateCard
     * const rateCard = await prisma.rateCard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RateCardFindUniqueArgs>(args: SelectSubset<T, RateCardFindUniqueArgs<ExtArgs>>): Prisma__RateCardClient<$Result.GetResult<Prisma.$RateCardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RateCard that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RateCardFindUniqueOrThrowArgs} args - Arguments to find a RateCard
     * @example
     * // Get one RateCard
     * const rateCard = await prisma.rateCard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RateCardFindUniqueOrThrowArgs>(args: SelectSubset<T, RateCardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RateCardClient<$Result.GetResult<Prisma.$RateCardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RateCard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateCardFindFirstArgs} args - Arguments to find a RateCard
     * @example
     * // Get one RateCard
     * const rateCard = await prisma.rateCard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RateCardFindFirstArgs>(args?: SelectSubset<T, RateCardFindFirstArgs<ExtArgs>>): Prisma__RateCardClient<$Result.GetResult<Prisma.$RateCardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RateCard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateCardFindFirstOrThrowArgs} args - Arguments to find a RateCard
     * @example
     * // Get one RateCard
     * const rateCard = await prisma.rateCard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RateCardFindFirstOrThrowArgs>(args?: SelectSubset<T, RateCardFindFirstOrThrowArgs<ExtArgs>>): Prisma__RateCardClient<$Result.GetResult<Prisma.$RateCardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RateCards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateCardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RateCards
     * const rateCards = await prisma.rateCard.findMany()
     * 
     * // Get first 10 RateCards
     * const rateCards = await prisma.rateCard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rateCardWithIdOnly = await prisma.rateCard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RateCardFindManyArgs>(args?: SelectSubset<T, RateCardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RateCardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RateCard.
     * @param {RateCardCreateArgs} args - Arguments to create a RateCard.
     * @example
     * // Create one RateCard
     * const RateCard = await prisma.rateCard.create({
     *   data: {
     *     // ... data to create a RateCard
     *   }
     * })
     * 
     */
    create<T extends RateCardCreateArgs>(args: SelectSubset<T, RateCardCreateArgs<ExtArgs>>): Prisma__RateCardClient<$Result.GetResult<Prisma.$RateCardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RateCards.
     * @param {RateCardCreateManyArgs} args - Arguments to create many RateCards.
     * @example
     * // Create many RateCards
     * const rateCard = await prisma.rateCard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RateCardCreateManyArgs>(args?: SelectSubset<T, RateCardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RateCards and returns the data saved in the database.
     * @param {RateCardCreateManyAndReturnArgs} args - Arguments to create many RateCards.
     * @example
     * // Create many RateCards
     * const rateCard = await prisma.rateCard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RateCards and only return the `id`
     * const rateCardWithIdOnly = await prisma.rateCard.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RateCardCreateManyAndReturnArgs>(args?: SelectSubset<T, RateCardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RateCardPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RateCard.
     * @param {RateCardDeleteArgs} args - Arguments to delete one RateCard.
     * @example
     * // Delete one RateCard
     * const RateCard = await prisma.rateCard.delete({
     *   where: {
     *     // ... filter to delete one RateCard
     *   }
     * })
     * 
     */
    delete<T extends RateCardDeleteArgs>(args: SelectSubset<T, RateCardDeleteArgs<ExtArgs>>): Prisma__RateCardClient<$Result.GetResult<Prisma.$RateCardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RateCard.
     * @param {RateCardUpdateArgs} args - Arguments to update one RateCard.
     * @example
     * // Update one RateCard
     * const rateCard = await prisma.rateCard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RateCardUpdateArgs>(args: SelectSubset<T, RateCardUpdateArgs<ExtArgs>>): Prisma__RateCardClient<$Result.GetResult<Prisma.$RateCardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RateCards.
     * @param {RateCardDeleteManyArgs} args - Arguments to filter RateCards to delete.
     * @example
     * // Delete a few RateCards
     * const { count } = await prisma.rateCard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RateCardDeleteManyArgs>(args?: SelectSubset<T, RateCardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RateCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateCardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RateCards
     * const rateCard = await prisma.rateCard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RateCardUpdateManyArgs>(args: SelectSubset<T, RateCardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RateCard.
     * @param {RateCardUpsertArgs} args - Arguments to update or create a RateCard.
     * @example
     * // Update or create a RateCard
     * const rateCard = await prisma.rateCard.upsert({
     *   create: {
     *     // ... data to create a RateCard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RateCard we want to update
     *   }
     * })
     */
    upsert<T extends RateCardUpsertArgs>(args: SelectSubset<T, RateCardUpsertArgs<ExtArgs>>): Prisma__RateCardClient<$Result.GetResult<Prisma.$RateCardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RateCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateCardCountArgs} args - Arguments to filter RateCards to count.
     * @example
     * // Count the number of RateCards
     * const count = await prisma.rateCard.count({
     *   where: {
     *     // ... the filter for the RateCards we want to count
     *   }
     * })
    **/
    count<T extends RateCardCountArgs>(
      args?: Subset<T, RateCardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RateCardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RateCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateCardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RateCardAggregateArgs>(args: Subset<T, RateCardAggregateArgs>): Prisma.PrismaPromise<GetRateCardAggregateType<T>>

    /**
     * Group by RateCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateCardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RateCardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RateCardGroupByArgs['orderBy'] }
        : { orderBy?: RateCardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RateCardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRateCardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RateCard model
   */
  readonly fields: RateCardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RateCard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RateCardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agreement<T extends AgreementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgreementDefaultArgs<ExtArgs>>): Prisma__AgreementClient<$Result.GetResult<Prisma.$AgreementPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Vendor<T extends RateCard$VendorArgs<ExtArgs> = {}>(args?: Subset<T, RateCard$VendorArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    shipments<T extends RateCard$shipmentsArgs<ExtArgs> = {}>(args?: Subset<T, RateCard$shipmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RateCard model
   */ 
  interface RateCardFieldRefs {
    readonly id: FieldRef<"RateCard", 'Int'>
    readonly agreementId: FieldRef<"RateCard", 'Int'>
    readonly routeName: FieldRef<"RateCard", 'String'>
    readonly origin: FieldRef<"RateCard", 'String'>
    readonly destination: FieldRef<"RateCard", 'String'>
    readonly distanceKm: FieldRef<"RateCard", 'Float'>
    readonly ratePerKm: FieldRef<"RateCard", 'Float'>
    readonly uom: FieldRef<"RateCard", 'String'>
    readonly vehicleType: FieldRef<"RateCard", 'String'>
    readonly effectiveFrom: FieldRef<"RateCard", 'DateTime'>
    readonly remarks: FieldRef<"RateCard", 'String'>
    readonly createdAt: FieldRef<"RateCard", 'DateTime'>
    readonly updatedAt: FieldRef<"RateCard", 'DateTime'>
    readonly vendorId: FieldRef<"RateCard", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RateCard findUnique
   */
  export type RateCardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateCard
     */
    select?: RateCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateCardInclude<ExtArgs> | null
    /**
     * Filter, which RateCard to fetch.
     */
    where: RateCardWhereUniqueInput
  }

  /**
   * RateCard findUniqueOrThrow
   */
  export type RateCardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateCard
     */
    select?: RateCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateCardInclude<ExtArgs> | null
    /**
     * Filter, which RateCard to fetch.
     */
    where: RateCardWhereUniqueInput
  }

  /**
   * RateCard findFirst
   */
  export type RateCardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateCard
     */
    select?: RateCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateCardInclude<ExtArgs> | null
    /**
     * Filter, which RateCard to fetch.
     */
    where?: RateCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RateCards to fetch.
     */
    orderBy?: RateCardOrderByWithRelationInput | RateCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RateCards.
     */
    cursor?: RateCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RateCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RateCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RateCards.
     */
    distinct?: RateCardScalarFieldEnum | RateCardScalarFieldEnum[]
  }

  /**
   * RateCard findFirstOrThrow
   */
  export type RateCardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateCard
     */
    select?: RateCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateCardInclude<ExtArgs> | null
    /**
     * Filter, which RateCard to fetch.
     */
    where?: RateCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RateCards to fetch.
     */
    orderBy?: RateCardOrderByWithRelationInput | RateCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RateCards.
     */
    cursor?: RateCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RateCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RateCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RateCards.
     */
    distinct?: RateCardScalarFieldEnum | RateCardScalarFieldEnum[]
  }

  /**
   * RateCard findMany
   */
  export type RateCardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateCard
     */
    select?: RateCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateCardInclude<ExtArgs> | null
    /**
     * Filter, which RateCards to fetch.
     */
    where?: RateCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RateCards to fetch.
     */
    orderBy?: RateCardOrderByWithRelationInput | RateCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RateCards.
     */
    cursor?: RateCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RateCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RateCards.
     */
    skip?: number
    distinct?: RateCardScalarFieldEnum | RateCardScalarFieldEnum[]
  }

  /**
   * RateCard create
   */
  export type RateCardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateCard
     */
    select?: RateCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateCardInclude<ExtArgs> | null
    /**
     * The data needed to create a RateCard.
     */
    data: XOR<RateCardCreateInput, RateCardUncheckedCreateInput>
  }

  /**
   * RateCard createMany
   */
  export type RateCardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RateCards.
     */
    data: RateCardCreateManyInput | RateCardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RateCard createManyAndReturn
   */
  export type RateCardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateCard
     */
    select?: RateCardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RateCards.
     */
    data: RateCardCreateManyInput | RateCardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateCardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RateCard update
   */
  export type RateCardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateCard
     */
    select?: RateCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateCardInclude<ExtArgs> | null
    /**
     * The data needed to update a RateCard.
     */
    data: XOR<RateCardUpdateInput, RateCardUncheckedUpdateInput>
    /**
     * Choose, which RateCard to update.
     */
    where: RateCardWhereUniqueInput
  }

  /**
   * RateCard updateMany
   */
  export type RateCardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RateCards.
     */
    data: XOR<RateCardUpdateManyMutationInput, RateCardUncheckedUpdateManyInput>
    /**
     * Filter which RateCards to update
     */
    where?: RateCardWhereInput
  }

  /**
   * RateCard upsert
   */
  export type RateCardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateCard
     */
    select?: RateCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateCardInclude<ExtArgs> | null
    /**
     * The filter to search for the RateCard to update in case it exists.
     */
    where: RateCardWhereUniqueInput
    /**
     * In case the RateCard found by the `where` argument doesn't exist, create a new RateCard with this data.
     */
    create: XOR<RateCardCreateInput, RateCardUncheckedCreateInput>
    /**
     * In case the RateCard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RateCardUpdateInput, RateCardUncheckedUpdateInput>
  }

  /**
   * RateCard delete
   */
  export type RateCardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateCard
     */
    select?: RateCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateCardInclude<ExtArgs> | null
    /**
     * Filter which RateCard to delete.
     */
    where: RateCardWhereUniqueInput
  }

  /**
   * RateCard deleteMany
   */
  export type RateCardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RateCards to delete
     */
    where?: RateCardWhereInput
  }

  /**
   * RateCard.Vendor
   */
  export type RateCard$VendorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    where?: VendorWhereInput
  }

  /**
   * RateCard.shipments
   */
  export type RateCard$shipmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    where?: ShipmentWhereInput
    orderBy?: ShipmentOrderByWithRelationInput | ShipmentOrderByWithRelationInput[]
    cursor?: ShipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShipmentScalarFieldEnum | ShipmentScalarFieldEnum[]
  }

  /**
   * RateCard without action
   */
  export type RateCardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateCard
     */
    select?: RateCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateCardInclude<ExtArgs> | null
  }


  /**
   * Model QuoteRequest
   */

  export type AggregateQuoteRequest = {
    _count: QuoteRequestCountAggregateOutputType | null
    _avg: QuoteRequestAvgAggregateOutputType | null
    _sum: QuoteRequestSumAggregateOutputType | null
    _min: QuoteRequestMinAggregateOutputType | null
    _max: QuoteRequestMaxAggregateOutputType | null
  }

  export type QuoteRequestAvgAggregateOutputType = {
    id: number | null
    createdByUserId: number | null
    fromLat: number | null
    fromLng: number | null
    toLat: number | null
    toLng: number | null
    weight: number | null
    approvedResponseId: number | null
  }

  export type QuoteRequestSumAggregateOutputType = {
    id: number | null
    createdByUserId: number | null
    fromLat: number | null
    fromLng: number | null
    toLat: number | null
    toLng: number | null
    weight: number | null
    approvedResponseId: number | null
  }

  export type QuoteRequestMinAggregateOutputType = {
    id: number | null
    createdByUserId: number | null
    fromLocation: string | null
    toLocation: string | null
    fromLat: number | null
    fromLng: number | null
    toLat: number | null
    toLng: number | null
    weight: number | null
    shipmentType: string | null
    urgency: string | null
    status: $Enums.QuoteStatus | null
    notes: string | null
    approvedResponseId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuoteRequestMaxAggregateOutputType = {
    id: number | null
    createdByUserId: number | null
    fromLocation: string | null
    toLocation: string | null
    fromLat: number | null
    fromLng: number | null
    toLat: number | null
    toLng: number | null
    weight: number | null
    shipmentType: string | null
    urgency: string | null
    status: $Enums.QuoteStatus | null
    notes: string | null
    approvedResponseId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuoteRequestCountAggregateOutputType = {
    id: number
    createdByUserId: number
    fromLocation: number
    toLocation: number
    fromLat: number
    fromLng: number
    toLat: number
    toLng: number
    weight: number
    shipmentType: number
    urgency: number
    status: number
    notes: number
    approvedResponseId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuoteRequestAvgAggregateInputType = {
    id?: true
    createdByUserId?: true
    fromLat?: true
    fromLng?: true
    toLat?: true
    toLng?: true
    weight?: true
    approvedResponseId?: true
  }

  export type QuoteRequestSumAggregateInputType = {
    id?: true
    createdByUserId?: true
    fromLat?: true
    fromLng?: true
    toLat?: true
    toLng?: true
    weight?: true
    approvedResponseId?: true
  }

  export type QuoteRequestMinAggregateInputType = {
    id?: true
    createdByUserId?: true
    fromLocation?: true
    toLocation?: true
    fromLat?: true
    fromLng?: true
    toLat?: true
    toLng?: true
    weight?: true
    shipmentType?: true
    urgency?: true
    status?: true
    notes?: true
    approvedResponseId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuoteRequestMaxAggregateInputType = {
    id?: true
    createdByUserId?: true
    fromLocation?: true
    toLocation?: true
    fromLat?: true
    fromLng?: true
    toLat?: true
    toLng?: true
    weight?: true
    shipmentType?: true
    urgency?: true
    status?: true
    notes?: true
    approvedResponseId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuoteRequestCountAggregateInputType = {
    id?: true
    createdByUserId?: true
    fromLocation?: true
    toLocation?: true
    fromLat?: true
    fromLng?: true
    toLat?: true
    toLng?: true
    weight?: true
    shipmentType?: true
    urgency?: true
    status?: true
    notes?: true
    approvedResponseId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuoteRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuoteRequest to aggregate.
     */
    where?: QuoteRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteRequests to fetch.
     */
    orderBy?: QuoteRequestOrderByWithRelationInput | QuoteRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuoteRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuoteRequests
    **/
    _count?: true | QuoteRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuoteRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuoteRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuoteRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuoteRequestMaxAggregateInputType
  }

  export type GetQuoteRequestAggregateType<T extends QuoteRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateQuoteRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuoteRequest[P]>
      : GetScalarType<T[P], AggregateQuoteRequest[P]>
  }




  export type QuoteRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteRequestWhereInput
    orderBy?: QuoteRequestOrderByWithAggregationInput | QuoteRequestOrderByWithAggregationInput[]
    by: QuoteRequestScalarFieldEnum[] | QuoteRequestScalarFieldEnum
    having?: QuoteRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuoteRequestCountAggregateInputType | true
    _avg?: QuoteRequestAvgAggregateInputType
    _sum?: QuoteRequestSumAggregateInputType
    _min?: QuoteRequestMinAggregateInputType
    _max?: QuoteRequestMaxAggregateInputType
  }

  export type QuoteRequestGroupByOutputType = {
    id: number
    createdByUserId: number
    fromLocation: string
    toLocation: string
    fromLat: number | null
    fromLng: number | null
    toLat: number | null
    toLng: number | null
    weight: number | null
    shipmentType: string | null
    urgency: string | null
    status: $Enums.QuoteStatus
    notes: string | null
    approvedResponseId: number | null
    createdAt: Date
    updatedAt: Date
    _count: QuoteRequestCountAggregateOutputType | null
    _avg: QuoteRequestAvgAggregateOutputType | null
    _sum: QuoteRequestSumAggregateOutputType | null
    _min: QuoteRequestMinAggregateOutputType | null
    _max: QuoteRequestMaxAggregateOutputType | null
  }

  type GetQuoteRequestGroupByPayload<T extends QuoteRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuoteRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuoteRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuoteRequestGroupByOutputType[P]>
            : GetScalarType<T[P], QuoteRequestGroupByOutputType[P]>
        }
      >
    >


  export type QuoteRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdByUserId?: boolean
    fromLocation?: boolean
    toLocation?: boolean
    fromLat?: boolean
    fromLng?: boolean
    toLat?: boolean
    toLng?: boolean
    weight?: boolean
    shipmentType?: boolean
    urgency?: boolean
    status?: boolean
    notes?: boolean
    approvedResponseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    responses?: boolean | QuoteRequest$responsesArgs<ExtArgs>
    approvedResponse?: boolean | QuoteRequest$approvedResponseArgs<ExtArgs>
    shipment?: boolean | QuoteRequest$shipmentArgs<ExtArgs>
    _count?: boolean | QuoteRequestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quoteRequest"]>

  export type QuoteRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdByUserId?: boolean
    fromLocation?: boolean
    toLocation?: boolean
    fromLat?: boolean
    fromLng?: boolean
    toLat?: boolean
    toLng?: boolean
    weight?: boolean
    shipmentType?: boolean
    urgency?: boolean
    status?: boolean
    notes?: boolean
    approvedResponseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    approvedResponse?: boolean | QuoteRequest$approvedResponseArgs<ExtArgs>
  }, ExtArgs["result"]["quoteRequest"]>

  export type QuoteRequestSelectScalar = {
    id?: boolean
    createdByUserId?: boolean
    fromLocation?: boolean
    toLocation?: boolean
    fromLat?: boolean
    fromLng?: boolean
    toLat?: boolean
    toLng?: boolean
    weight?: boolean
    shipmentType?: boolean
    urgency?: boolean
    status?: boolean
    notes?: boolean
    approvedResponseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuoteRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    responses?: boolean | QuoteRequest$responsesArgs<ExtArgs>
    approvedResponse?: boolean | QuoteRequest$approvedResponseArgs<ExtArgs>
    shipment?: boolean | QuoteRequest$shipmentArgs<ExtArgs>
    _count?: boolean | QuoteRequestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuoteRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    approvedResponse?: boolean | QuoteRequest$approvedResponseArgs<ExtArgs>
  }

  export type $QuoteRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuoteRequest"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      responses: Prisma.$QuoteResponsePayload<ExtArgs>[]
      approvedResponse: Prisma.$QuoteResponsePayload<ExtArgs> | null
      shipment: Prisma.$ShipmentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdByUserId: number
      fromLocation: string
      toLocation: string
      fromLat: number | null
      fromLng: number | null
      toLat: number | null
      toLng: number | null
      weight: number | null
      shipmentType: string | null
      urgency: string | null
      status: $Enums.QuoteStatus
      notes: string | null
      approvedResponseId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["quoteRequest"]>
    composites: {}
  }

  type QuoteRequestGetPayload<S extends boolean | null | undefined | QuoteRequestDefaultArgs> = $Result.GetResult<Prisma.$QuoteRequestPayload, S>

  type QuoteRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuoteRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuoteRequestCountAggregateInputType | true
    }

  export interface QuoteRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuoteRequest'], meta: { name: 'QuoteRequest' } }
    /**
     * Find zero or one QuoteRequest that matches the filter.
     * @param {QuoteRequestFindUniqueArgs} args - Arguments to find a QuoteRequest
     * @example
     * // Get one QuoteRequest
     * const quoteRequest = await prisma.quoteRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuoteRequestFindUniqueArgs>(args: SelectSubset<T, QuoteRequestFindUniqueArgs<ExtArgs>>): Prisma__QuoteRequestClient<$Result.GetResult<Prisma.$QuoteRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one QuoteRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuoteRequestFindUniqueOrThrowArgs} args - Arguments to find a QuoteRequest
     * @example
     * // Get one QuoteRequest
     * const quoteRequest = await prisma.quoteRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuoteRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, QuoteRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuoteRequestClient<$Result.GetResult<Prisma.$QuoteRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first QuoteRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteRequestFindFirstArgs} args - Arguments to find a QuoteRequest
     * @example
     * // Get one QuoteRequest
     * const quoteRequest = await prisma.quoteRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuoteRequestFindFirstArgs>(args?: SelectSubset<T, QuoteRequestFindFirstArgs<ExtArgs>>): Prisma__QuoteRequestClient<$Result.GetResult<Prisma.$QuoteRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first QuoteRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteRequestFindFirstOrThrowArgs} args - Arguments to find a QuoteRequest
     * @example
     * // Get one QuoteRequest
     * const quoteRequest = await prisma.quoteRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuoteRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, QuoteRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuoteRequestClient<$Result.GetResult<Prisma.$QuoteRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more QuoteRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuoteRequests
     * const quoteRequests = await prisma.quoteRequest.findMany()
     * 
     * // Get first 10 QuoteRequests
     * const quoteRequests = await prisma.quoteRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quoteRequestWithIdOnly = await prisma.quoteRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuoteRequestFindManyArgs>(args?: SelectSubset<T, QuoteRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a QuoteRequest.
     * @param {QuoteRequestCreateArgs} args - Arguments to create a QuoteRequest.
     * @example
     * // Create one QuoteRequest
     * const QuoteRequest = await prisma.quoteRequest.create({
     *   data: {
     *     // ... data to create a QuoteRequest
     *   }
     * })
     * 
     */
    create<T extends QuoteRequestCreateArgs>(args: SelectSubset<T, QuoteRequestCreateArgs<ExtArgs>>): Prisma__QuoteRequestClient<$Result.GetResult<Prisma.$QuoteRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many QuoteRequests.
     * @param {QuoteRequestCreateManyArgs} args - Arguments to create many QuoteRequests.
     * @example
     * // Create many QuoteRequests
     * const quoteRequest = await prisma.quoteRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuoteRequestCreateManyArgs>(args?: SelectSubset<T, QuoteRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuoteRequests and returns the data saved in the database.
     * @param {QuoteRequestCreateManyAndReturnArgs} args - Arguments to create many QuoteRequests.
     * @example
     * // Create many QuoteRequests
     * const quoteRequest = await prisma.quoteRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuoteRequests and only return the `id`
     * const quoteRequestWithIdOnly = await prisma.quoteRequest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuoteRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, QuoteRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteRequestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a QuoteRequest.
     * @param {QuoteRequestDeleteArgs} args - Arguments to delete one QuoteRequest.
     * @example
     * // Delete one QuoteRequest
     * const QuoteRequest = await prisma.quoteRequest.delete({
     *   where: {
     *     // ... filter to delete one QuoteRequest
     *   }
     * })
     * 
     */
    delete<T extends QuoteRequestDeleteArgs>(args: SelectSubset<T, QuoteRequestDeleteArgs<ExtArgs>>): Prisma__QuoteRequestClient<$Result.GetResult<Prisma.$QuoteRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one QuoteRequest.
     * @param {QuoteRequestUpdateArgs} args - Arguments to update one QuoteRequest.
     * @example
     * // Update one QuoteRequest
     * const quoteRequest = await prisma.quoteRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuoteRequestUpdateArgs>(args: SelectSubset<T, QuoteRequestUpdateArgs<ExtArgs>>): Prisma__QuoteRequestClient<$Result.GetResult<Prisma.$QuoteRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more QuoteRequests.
     * @param {QuoteRequestDeleteManyArgs} args - Arguments to filter QuoteRequests to delete.
     * @example
     * // Delete a few QuoteRequests
     * const { count } = await prisma.quoteRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuoteRequestDeleteManyArgs>(args?: SelectSubset<T, QuoteRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuoteRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuoteRequests
     * const quoteRequest = await prisma.quoteRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuoteRequestUpdateManyArgs>(args: SelectSubset<T, QuoteRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuoteRequest.
     * @param {QuoteRequestUpsertArgs} args - Arguments to update or create a QuoteRequest.
     * @example
     * // Update or create a QuoteRequest
     * const quoteRequest = await prisma.quoteRequest.upsert({
     *   create: {
     *     // ... data to create a QuoteRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuoteRequest we want to update
     *   }
     * })
     */
    upsert<T extends QuoteRequestUpsertArgs>(args: SelectSubset<T, QuoteRequestUpsertArgs<ExtArgs>>): Prisma__QuoteRequestClient<$Result.GetResult<Prisma.$QuoteRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of QuoteRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteRequestCountArgs} args - Arguments to filter QuoteRequests to count.
     * @example
     * // Count the number of QuoteRequests
     * const count = await prisma.quoteRequest.count({
     *   where: {
     *     // ... the filter for the QuoteRequests we want to count
     *   }
     * })
    **/
    count<T extends QuoteRequestCountArgs>(
      args?: Subset<T, QuoteRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuoteRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuoteRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuoteRequestAggregateArgs>(args: Subset<T, QuoteRequestAggregateArgs>): Prisma.PrismaPromise<GetQuoteRequestAggregateType<T>>

    /**
     * Group by QuoteRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuoteRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuoteRequestGroupByArgs['orderBy'] }
        : { orderBy?: QuoteRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuoteRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuoteRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuoteRequest model
   */
  readonly fields: QuoteRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuoteRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuoteRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    responses<T extends QuoteRequest$responsesArgs<ExtArgs> = {}>(args?: Subset<T, QuoteRequest$responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteResponsePayload<ExtArgs>, T, "findMany"> | Null>
    approvedResponse<T extends QuoteRequest$approvedResponseArgs<ExtArgs> = {}>(args?: Subset<T, QuoteRequest$approvedResponseArgs<ExtArgs>>): Prisma__QuoteResponseClient<$Result.GetResult<Prisma.$QuoteResponsePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    shipment<T extends QuoteRequest$shipmentArgs<ExtArgs> = {}>(args?: Subset<T, QuoteRequest$shipmentArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuoteRequest model
   */ 
  interface QuoteRequestFieldRefs {
    readonly id: FieldRef<"QuoteRequest", 'Int'>
    readonly createdByUserId: FieldRef<"QuoteRequest", 'Int'>
    readonly fromLocation: FieldRef<"QuoteRequest", 'String'>
    readonly toLocation: FieldRef<"QuoteRequest", 'String'>
    readonly fromLat: FieldRef<"QuoteRequest", 'Float'>
    readonly fromLng: FieldRef<"QuoteRequest", 'Float'>
    readonly toLat: FieldRef<"QuoteRequest", 'Float'>
    readonly toLng: FieldRef<"QuoteRequest", 'Float'>
    readonly weight: FieldRef<"QuoteRequest", 'Float'>
    readonly shipmentType: FieldRef<"QuoteRequest", 'String'>
    readonly urgency: FieldRef<"QuoteRequest", 'String'>
    readonly status: FieldRef<"QuoteRequest", 'QuoteStatus'>
    readonly notes: FieldRef<"QuoteRequest", 'String'>
    readonly approvedResponseId: FieldRef<"QuoteRequest", 'Int'>
    readonly createdAt: FieldRef<"QuoteRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"QuoteRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuoteRequest findUnique
   */
  export type QuoteRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteRequest
     */
    select?: QuoteRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteRequestInclude<ExtArgs> | null
    /**
     * Filter, which QuoteRequest to fetch.
     */
    where: QuoteRequestWhereUniqueInput
  }

  /**
   * QuoteRequest findUniqueOrThrow
   */
  export type QuoteRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteRequest
     */
    select?: QuoteRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteRequestInclude<ExtArgs> | null
    /**
     * Filter, which QuoteRequest to fetch.
     */
    where: QuoteRequestWhereUniqueInput
  }

  /**
   * QuoteRequest findFirst
   */
  export type QuoteRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteRequest
     */
    select?: QuoteRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteRequestInclude<ExtArgs> | null
    /**
     * Filter, which QuoteRequest to fetch.
     */
    where?: QuoteRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteRequests to fetch.
     */
    orderBy?: QuoteRequestOrderByWithRelationInput | QuoteRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuoteRequests.
     */
    cursor?: QuoteRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuoteRequests.
     */
    distinct?: QuoteRequestScalarFieldEnum | QuoteRequestScalarFieldEnum[]
  }

  /**
   * QuoteRequest findFirstOrThrow
   */
  export type QuoteRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteRequest
     */
    select?: QuoteRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteRequestInclude<ExtArgs> | null
    /**
     * Filter, which QuoteRequest to fetch.
     */
    where?: QuoteRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteRequests to fetch.
     */
    orderBy?: QuoteRequestOrderByWithRelationInput | QuoteRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuoteRequests.
     */
    cursor?: QuoteRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuoteRequests.
     */
    distinct?: QuoteRequestScalarFieldEnum | QuoteRequestScalarFieldEnum[]
  }

  /**
   * QuoteRequest findMany
   */
  export type QuoteRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteRequest
     */
    select?: QuoteRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteRequestInclude<ExtArgs> | null
    /**
     * Filter, which QuoteRequests to fetch.
     */
    where?: QuoteRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteRequests to fetch.
     */
    orderBy?: QuoteRequestOrderByWithRelationInput | QuoteRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuoteRequests.
     */
    cursor?: QuoteRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteRequests.
     */
    skip?: number
    distinct?: QuoteRequestScalarFieldEnum | QuoteRequestScalarFieldEnum[]
  }

  /**
   * QuoteRequest create
   */
  export type QuoteRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteRequest
     */
    select?: QuoteRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a QuoteRequest.
     */
    data: XOR<QuoteRequestCreateInput, QuoteRequestUncheckedCreateInput>
  }

  /**
   * QuoteRequest createMany
   */
  export type QuoteRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuoteRequests.
     */
    data: QuoteRequestCreateManyInput | QuoteRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuoteRequest createManyAndReturn
   */
  export type QuoteRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteRequest
     */
    select?: QuoteRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many QuoteRequests.
     */
    data: QuoteRequestCreateManyInput | QuoteRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuoteRequest update
   */
  export type QuoteRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteRequest
     */
    select?: QuoteRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a QuoteRequest.
     */
    data: XOR<QuoteRequestUpdateInput, QuoteRequestUncheckedUpdateInput>
    /**
     * Choose, which QuoteRequest to update.
     */
    where: QuoteRequestWhereUniqueInput
  }

  /**
   * QuoteRequest updateMany
   */
  export type QuoteRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuoteRequests.
     */
    data: XOR<QuoteRequestUpdateManyMutationInput, QuoteRequestUncheckedUpdateManyInput>
    /**
     * Filter which QuoteRequests to update
     */
    where?: QuoteRequestWhereInput
  }

  /**
   * QuoteRequest upsert
   */
  export type QuoteRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteRequest
     */
    select?: QuoteRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the QuoteRequest to update in case it exists.
     */
    where: QuoteRequestWhereUniqueInput
    /**
     * In case the QuoteRequest found by the `where` argument doesn't exist, create a new QuoteRequest with this data.
     */
    create: XOR<QuoteRequestCreateInput, QuoteRequestUncheckedCreateInput>
    /**
     * In case the QuoteRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuoteRequestUpdateInput, QuoteRequestUncheckedUpdateInput>
  }

  /**
   * QuoteRequest delete
   */
  export type QuoteRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteRequest
     */
    select?: QuoteRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteRequestInclude<ExtArgs> | null
    /**
     * Filter which QuoteRequest to delete.
     */
    where: QuoteRequestWhereUniqueInput
  }

  /**
   * QuoteRequest deleteMany
   */
  export type QuoteRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuoteRequests to delete
     */
    where?: QuoteRequestWhereInput
  }

  /**
   * QuoteRequest.responses
   */
  export type QuoteRequest$responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteResponse
     */
    select?: QuoteResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteResponseInclude<ExtArgs> | null
    where?: QuoteResponseWhereInput
    orderBy?: QuoteResponseOrderByWithRelationInput | QuoteResponseOrderByWithRelationInput[]
    cursor?: QuoteResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuoteResponseScalarFieldEnum | QuoteResponseScalarFieldEnum[]
  }

  /**
   * QuoteRequest.approvedResponse
   */
  export type QuoteRequest$approvedResponseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteResponse
     */
    select?: QuoteResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteResponseInclude<ExtArgs> | null
    where?: QuoteResponseWhereInput
  }

  /**
   * QuoteRequest.shipment
   */
  export type QuoteRequest$shipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    where?: ShipmentWhereInput
  }

  /**
   * QuoteRequest without action
   */
  export type QuoteRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteRequest
     */
    select?: QuoteRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteRequestInclude<ExtArgs> | null
  }


  /**
   * Model QuoteResponse
   */

  export type AggregateQuoteResponse = {
    _count: QuoteResponseCountAggregateOutputType | null
    _avg: QuoteResponseAvgAggregateOutputType | null
    _sum: QuoteResponseSumAggregateOutputType | null
    _min: QuoteResponseMinAggregateOutputType | null
    _max: QuoteResponseMaxAggregateOutputType | null
  }

  export type QuoteResponseAvgAggregateOutputType = {
    id: number | null
    quoteRequestId: number | null
    vendorId: number | null
    quotedPrice: number | null
  }

  export type QuoteResponseSumAggregateOutputType = {
    id: number | null
    quoteRequestId: number | null
    vendorId: number | null
    quotedPrice: number | null
  }

  export type QuoteResponseMinAggregateOutputType = {
    id: number | null
    quoteRequestId: number | null
    vendorId: number | null
    quotedPrice: number | null
    estimatedDelivery: Date | null
    expiresAt: Date | null
    status: $Enums.QuoteResponseStatus | null
    consentStatus: $Enums.ConsentStatus | null
    notes: string | null
    transporterNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuoteResponseMaxAggregateOutputType = {
    id: number | null
    quoteRequestId: number | null
    vendorId: number | null
    quotedPrice: number | null
    estimatedDelivery: Date | null
    expiresAt: Date | null
    status: $Enums.QuoteResponseStatus | null
    consentStatus: $Enums.ConsentStatus | null
    notes: string | null
    transporterNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuoteResponseCountAggregateOutputType = {
    id: number
    quoteRequestId: number
    vendorId: number
    quotedPrice: number
    estimatedDelivery: number
    expiresAt: number
    status: number
    consentStatus: number
    notes: number
    transporterNotes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuoteResponseAvgAggregateInputType = {
    id?: true
    quoteRequestId?: true
    vendorId?: true
    quotedPrice?: true
  }

  export type QuoteResponseSumAggregateInputType = {
    id?: true
    quoteRequestId?: true
    vendorId?: true
    quotedPrice?: true
  }

  export type QuoteResponseMinAggregateInputType = {
    id?: true
    quoteRequestId?: true
    vendorId?: true
    quotedPrice?: true
    estimatedDelivery?: true
    expiresAt?: true
    status?: true
    consentStatus?: true
    notes?: true
    transporterNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuoteResponseMaxAggregateInputType = {
    id?: true
    quoteRequestId?: true
    vendorId?: true
    quotedPrice?: true
    estimatedDelivery?: true
    expiresAt?: true
    status?: true
    consentStatus?: true
    notes?: true
    transporterNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuoteResponseCountAggregateInputType = {
    id?: true
    quoteRequestId?: true
    vendorId?: true
    quotedPrice?: true
    estimatedDelivery?: true
    expiresAt?: true
    status?: true
    consentStatus?: true
    notes?: true
    transporterNotes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuoteResponseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuoteResponse to aggregate.
     */
    where?: QuoteResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteResponses to fetch.
     */
    orderBy?: QuoteResponseOrderByWithRelationInput | QuoteResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuoteResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuoteResponses
    **/
    _count?: true | QuoteResponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuoteResponseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuoteResponseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuoteResponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuoteResponseMaxAggregateInputType
  }

  export type GetQuoteResponseAggregateType<T extends QuoteResponseAggregateArgs> = {
        [P in keyof T & keyof AggregateQuoteResponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuoteResponse[P]>
      : GetScalarType<T[P], AggregateQuoteResponse[P]>
  }




  export type QuoteResponseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteResponseWhereInput
    orderBy?: QuoteResponseOrderByWithAggregationInput | QuoteResponseOrderByWithAggregationInput[]
    by: QuoteResponseScalarFieldEnum[] | QuoteResponseScalarFieldEnum
    having?: QuoteResponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuoteResponseCountAggregateInputType | true
    _avg?: QuoteResponseAvgAggregateInputType
    _sum?: QuoteResponseSumAggregateInputType
    _min?: QuoteResponseMinAggregateInputType
    _max?: QuoteResponseMaxAggregateInputType
  }

  export type QuoteResponseGroupByOutputType = {
    id: number
    quoteRequestId: number
    vendorId: number
    quotedPrice: number | null
    estimatedDelivery: Date | null
    expiresAt: Date | null
    status: $Enums.QuoteResponseStatus
    consentStatus: $Enums.ConsentStatus
    notes: string | null
    transporterNotes: string | null
    createdAt: Date
    updatedAt: Date
    _count: QuoteResponseCountAggregateOutputType | null
    _avg: QuoteResponseAvgAggregateOutputType | null
    _sum: QuoteResponseSumAggregateOutputType | null
    _min: QuoteResponseMinAggregateOutputType | null
    _max: QuoteResponseMaxAggregateOutputType | null
  }

  type GetQuoteResponseGroupByPayload<T extends QuoteResponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuoteResponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuoteResponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuoteResponseGroupByOutputType[P]>
            : GetScalarType<T[P], QuoteResponseGroupByOutputType[P]>
        }
      >
    >


  export type QuoteResponseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quoteRequestId?: boolean
    vendorId?: boolean
    quotedPrice?: boolean
    estimatedDelivery?: boolean
    expiresAt?: boolean
    status?: boolean
    consentStatus?: boolean
    notes?: boolean
    transporterNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quoteRequest?: boolean | QuoteRequestDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    shipment?: boolean | QuoteResponse$shipmentArgs<ExtArgs>
    approvedFor?: boolean | QuoteResponse$approvedForArgs<ExtArgs>
    consentLogs?: boolean | QuoteResponse$consentLogsArgs<ExtArgs>
    _count?: boolean | QuoteResponseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quoteResponse"]>

  export type QuoteResponseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quoteRequestId?: boolean
    vendorId?: boolean
    quotedPrice?: boolean
    estimatedDelivery?: boolean
    expiresAt?: boolean
    status?: boolean
    consentStatus?: boolean
    notes?: boolean
    transporterNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quoteRequest?: boolean | QuoteRequestDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quoteResponse"]>

  export type QuoteResponseSelectScalar = {
    id?: boolean
    quoteRequestId?: boolean
    vendorId?: boolean
    quotedPrice?: boolean
    estimatedDelivery?: boolean
    expiresAt?: boolean
    status?: boolean
    consentStatus?: boolean
    notes?: boolean
    transporterNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuoteResponseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quoteRequest?: boolean | QuoteRequestDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    shipment?: boolean | QuoteResponse$shipmentArgs<ExtArgs>
    approvedFor?: boolean | QuoteResponse$approvedForArgs<ExtArgs>
    consentLogs?: boolean | QuoteResponse$consentLogsArgs<ExtArgs>
    _count?: boolean | QuoteResponseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuoteResponseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quoteRequest?: boolean | QuoteRequestDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }

  export type $QuoteResponsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuoteResponse"
    objects: {
      quoteRequest: Prisma.$QuoteRequestPayload<ExtArgs>
      vendor: Prisma.$VendorPayload<ExtArgs>
      shipment: Prisma.$ShipmentPayload<ExtArgs> | null
      approvedFor: Prisma.$QuoteRequestPayload<ExtArgs> | null
      consentLogs: Prisma.$ConsentLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      quoteRequestId: number
      vendorId: number
      quotedPrice: number | null
      estimatedDelivery: Date | null
      expiresAt: Date | null
      status: $Enums.QuoteResponseStatus
      consentStatus: $Enums.ConsentStatus
      notes: string | null
      transporterNotes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["quoteResponse"]>
    composites: {}
  }

  type QuoteResponseGetPayload<S extends boolean | null | undefined | QuoteResponseDefaultArgs> = $Result.GetResult<Prisma.$QuoteResponsePayload, S>

  type QuoteResponseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuoteResponseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuoteResponseCountAggregateInputType | true
    }

  export interface QuoteResponseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuoteResponse'], meta: { name: 'QuoteResponse' } }
    /**
     * Find zero or one QuoteResponse that matches the filter.
     * @param {QuoteResponseFindUniqueArgs} args - Arguments to find a QuoteResponse
     * @example
     * // Get one QuoteResponse
     * const quoteResponse = await prisma.quoteResponse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuoteResponseFindUniqueArgs>(args: SelectSubset<T, QuoteResponseFindUniqueArgs<ExtArgs>>): Prisma__QuoteResponseClient<$Result.GetResult<Prisma.$QuoteResponsePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one QuoteResponse that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuoteResponseFindUniqueOrThrowArgs} args - Arguments to find a QuoteResponse
     * @example
     * // Get one QuoteResponse
     * const quoteResponse = await prisma.quoteResponse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuoteResponseFindUniqueOrThrowArgs>(args: SelectSubset<T, QuoteResponseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuoteResponseClient<$Result.GetResult<Prisma.$QuoteResponsePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first QuoteResponse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteResponseFindFirstArgs} args - Arguments to find a QuoteResponse
     * @example
     * // Get one QuoteResponse
     * const quoteResponse = await prisma.quoteResponse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuoteResponseFindFirstArgs>(args?: SelectSubset<T, QuoteResponseFindFirstArgs<ExtArgs>>): Prisma__QuoteResponseClient<$Result.GetResult<Prisma.$QuoteResponsePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first QuoteResponse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteResponseFindFirstOrThrowArgs} args - Arguments to find a QuoteResponse
     * @example
     * // Get one QuoteResponse
     * const quoteResponse = await prisma.quoteResponse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuoteResponseFindFirstOrThrowArgs>(args?: SelectSubset<T, QuoteResponseFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuoteResponseClient<$Result.GetResult<Prisma.$QuoteResponsePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more QuoteResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteResponseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuoteResponses
     * const quoteResponses = await prisma.quoteResponse.findMany()
     * 
     * // Get first 10 QuoteResponses
     * const quoteResponses = await prisma.quoteResponse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quoteResponseWithIdOnly = await prisma.quoteResponse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuoteResponseFindManyArgs>(args?: SelectSubset<T, QuoteResponseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteResponsePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a QuoteResponse.
     * @param {QuoteResponseCreateArgs} args - Arguments to create a QuoteResponse.
     * @example
     * // Create one QuoteResponse
     * const QuoteResponse = await prisma.quoteResponse.create({
     *   data: {
     *     // ... data to create a QuoteResponse
     *   }
     * })
     * 
     */
    create<T extends QuoteResponseCreateArgs>(args: SelectSubset<T, QuoteResponseCreateArgs<ExtArgs>>): Prisma__QuoteResponseClient<$Result.GetResult<Prisma.$QuoteResponsePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many QuoteResponses.
     * @param {QuoteResponseCreateManyArgs} args - Arguments to create many QuoteResponses.
     * @example
     * // Create many QuoteResponses
     * const quoteResponse = await prisma.quoteResponse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuoteResponseCreateManyArgs>(args?: SelectSubset<T, QuoteResponseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuoteResponses and returns the data saved in the database.
     * @param {QuoteResponseCreateManyAndReturnArgs} args - Arguments to create many QuoteResponses.
     * @example
     * // Create many QuoteResponses
     * const quoteResponse = await prisma.quoteResponse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuoteResponses and only return the `id`
     * const quoteResponseWithIdOnly = await prisma.quoteResponse.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuoteResponseCreateManyAndReturnArgs>(args?: SelectSubset<T, QuoteResponseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteResponsePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a QuoteResponse.
     * @param {QuoteResponseDeleteArgs} args - Arguments to delete one QuoteResponse.
     * @example
     * // Delete one QuoteResponse
     * const QuoteResponse = await prisma.quoteResponse.delete({
     *   where: {
     *     // ... filter to delete one QuoteResponse
     *   }
     * })
     * 
     */
    delete<T extends QuoteResponseDeleteArgs>(args: SelectSubset<T, QuoteResponseDeleteArgs<ExtArgs>>): Prisma__QuoteResponseClient<$Result.GetResult<Prisma.$QuoteResponsePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one QuoteResponse.
     * @param {QuoteResponseUpdateArgs} args - Arguments to update one QuoteResponse.
     * @example
     * // Update one QuoteResponse
     * const quoteResponse = await prisma.quoteResponse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuoteResponseUpdateArgs>(args: SelectSubset<T, QuoteResponseUpdateArgs<ExtArgs>>): Prisma__QuoteResponseClient<$Result.GetResult<Prisma.$QuoteResponsePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more QuoteResponses.
     * @param {QuoteResponseDeleteManyArgs} args - Arguments to filter QuoteResponses to delete.
     * @example
     * // Delete a few QuoteResponses
     * const { count } = await prisma.quoteResponse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuoteResponseDeleteManyArgs>(args?: SelectSubset<T, QuoteResponseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuoteResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteResponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuoteResponses
     * const quoteResponse = await prisma.quoteResponse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuoteResponseUpdateManyArgs>(args: SelectSubset<T, QuoteResponseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuoteResponse.
     * @param {QuoteResponseUpsertArgs} args - Arguments to update or create a QuoteResponse.
     * @example
     * // Update or create a QuoteResponse
     * const quoteResponse = await prisma.quoteResponse.upsert({
     *   create: {
     *     // ... data to create a QuoteResponse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuoteResponse we want to update
     *   }
     * })
     */
    upsert<T extends QuoteResponseUpsertArgs>(args: SelectSubset<T, QuoteResponseUpsertArgs<ExtArgs>>): Prisma__QuoteResponseClient<$Result.GetResult<Prisma.$QuoteResponsePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of QuoteResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteResponseCountArgs} args - Arguments to filter QuoteResponses to count.
     * @example
     * // Count the number of QuoteResponses
     * const count = await prisma.quoteResponse.count({
     *   where: {
     *     // ... the filter for the QuoteResponses we want to count
     *   }
     * })
    **/
    count<T extends QuoteResponseCountArgs>(
      args?: Subset<T, QuoteResponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuoteResponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuoteResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteResponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuoteResponseAggregateArgs>(args: Subset<T, QuoteResponseAggregateArgs>): Prisma.PrismaPromise<GetQuoteResponseAggregateType<T>>

    /**
     * Group by QuoteResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteResponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuoteResponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuoteResponseGroupByArgs['orderBy'] }
        : { orderBy?: QuoteResponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuoteResponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuoteResponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuoteResponse model
   */
  readonly fields: QuoteResponseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuoteResponse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuoteResponseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quoteRequest<T extends QuoteRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuoteRequestDefaultArgs<ExtArgs>>): Prisma__QuoteRequestClient<$Result.GetResult<Prisma.$QuoteRequestPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    shipment<T extends QuoteResponse$shipmentArgs<ExtArgs> = {}>(args?: Subset<T, QuoteResponse$shipmentArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    approvedFor<T extends QuoteResponse$approvedForArgs<ExtArgs> = {}>(args?: Subset<T, QuoteResponse$approvedForArgs<ExtArgs>>): Prisma__QuoteRequestClient<$Result.GetResult<Prisma.$QuoteRequestPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    consentLogs<T extends QuoteResponse$consentLogsArgs<ExtArgs> = {}>(args?: Subset<T, QuoteResponse$consentLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsentLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuoteResponse model
   */ 
  interface QuoteResponseFieldRefs {
    readonly id: FieldRef<"QuoteResponse", 'Int'>
    readonly quoteRequestId: FieldRef<"QuoteResponse", 'Int'>
    readonly vendorId: FieldRef<"QuoteResponse", 'Int'>
    readonly quotedPrice: FieldRef<"QuoteResponse", 'Float'>
    readonly estimatedDelivery: FieldRef<"QuoteResponse", 'DateTime'>
    readonly expiresAt: FieldRef<"QuoteResponse", 'DateTime'>
    readonly status: FieldRef<"QuoteResponse", 'QuoteResponseStatus'>
    readonly consentStatus: FieldRef<"QuoteResponse", 'ConsentStatus'>
    readonly notes: FieldRef<"QuoteResponse", 'String'>
    readonly transporterNotes: FieldRef<"QuoteResponse", 'String'>
    readonly createdAt: FieldRef<"QuoteResponse", 'DateTime'>
    readonly updatedAt: FieldRef<"QuoteResponse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuoteResponse findUnique
   */
  export type QuoteResponseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteResponse
     */
    select?: QuoteResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteResponseInclude<ExtArgs> | null
    /**
     * Filter, which QuoteResponse to fetch.
     */
    where: QuoteResponseWhereUniqueInput
  }

  /**
   * QuoteResponse findUniqueOrThrow
   */
  export type QuoteResponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteResponse
     */
    select?: QuoteResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteResponseInclude<ExtArgs> | null
    /**
     * Filter, which QuoteResponse to fetch.
     */
    where: QuoteResponseWhereUniqueInput
  }

  /**
   * QuoteResponse findFirst
   */
  export type QuoteResponseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteResponse
     */
    select?: QuoteResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteResponseInclude<ExtArgs> | null
    /**
     * Filter, which QuoteResponse to fetch.
     */
    where?: QuoteResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteResponses to fetch.
     */
    orderBy?: QuoteResponseOrderByWithRelationInput | QuoteResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuoteResponses.
     */
    cursor?: QuoteResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuoteResponses.
     */
    distinct?: QuoteResponseScalarFieldEnum | QuoteResponseScalarFieldEnum[]
  }

  /**
   * QuoteResponse findFirstOrThrow
   */
  export type QuoteResponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteResponse
     */
    select?: QuoteResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteResponseInclude<ExtArgs> | null
    /**
     * Filter, which QuoteResponse to fetch.
     */
    where?: QuoteResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteResponses to fetch.
     */
    orderBy?: QuoteResponseOrderByWithRelationInput | QuoteResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuoteResponses.
     */
    cursor?: QuoteResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuoteResponses.
     */
    distinct?: QuoteResponseScalarFieldEnum | QuoteResponseScalarFieldEnum[]
  }

  /**
   * QuoteResponse findMany
   */
  export type QuoteResponseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteResponse
     */
    select?: QuoteResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteResponseInclude<ExtArgs> | null
    /**
     * Filter, which QuoteResponses to fetch.
     */
    where?: QuoteResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteResponses to fetch.
     */
    orderBy?: QuoteResponseOrderByWithRelationInput | QuoteResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuoteResponses.
     */
    cursor?: QuoteResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteResponses.
     */
    skip?: number
    distinct?: QuoteResponseScalarFieldEnum | QuoteResponseScalarFieldEnum[]
  }

  /**
   * QuoteResponse create
   */
  export type QuoteResponseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteResponse
     */
    select?: QuoteResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteResponseInclude<ExtArgs> | null
    /**
     * The data needed to create a QuoteResponse.
     */
    data: XOR<QuoteResponseCreateInput, QuoteResponseUncheckedCreateInput>
  }

  /**
   * QuoteResponse createMany
   */
  export type QuoteResponseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuoteResponses.
     */
    data: QuoteResponseCreateManyInput | QuoteResponseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuoteResponse createManyAndReturn
   */
  export type QuoteResponseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteResponse
     */
    select?: QuoteResponseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many QuoteResponses.
     */
    data: QuoteResponseCreateManyInput | QuoteResponseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteResponseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuoteResponse update
   */
  export type QuoteResponseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteResponse
     */
    select?: QuoteResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteResponseInclude<ExtArgs> | null
    /**
     * The data needed to update a QuoteResponse.
     */
    data: XOR<QuoteResponseUpdateInput, QuoteResponseUncheckedUpdateInput>
    /**
     * Choose, which QuoteResponse to update.
     */
    where: QuoteResponseWhereUniqueInput
  }

  /**
   * QuoteResponse updateMany
   */
  export type QuoteResponseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuoteResponses.
     */
    data: XOR<QuoteResponseUpdateManyMutationInput, QuoteResponseUncheckedUpdateManyInput>
    /**
     * Filter which QuoteResponses to update
     */
    where?: QuoteResponseWhereInput
  }

  /**
   * QuoteResponse upsert
   */
  export type QuoteResponseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteResponse
     */
    select?: QuoteResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteResponseInclude<ExtArgs> | null
    /**
     * The filter to search for the QuoteResponse to update in case it exists.
     */
    where: QuoteResponseWhereUniqueInput
    /**
     * In case the QuoteResponse found by the `where` argument doesn't exist, create a new QuoteResponse with this data.
     */
    create: XOR<QuoteResponseCreateInput, QuoteResponseUncheckedCreateInput>
    /**
     * In case the QuoteResponse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuoteResponseUpdateInput, QuoteResponseUncheckedUpdateInput>
  }

  /**
   * QuoteResponse delete
   */
  export type QuoteResponseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteResponse
     */
    select?: QuoteResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteResponseInclude<ExtArgs> | null
    /**
     * Filter which QuoteResponse to delete.
     */
    where: QuoteResponseWhereUniqueInput
  }

  /**
   * QuoteResponse deleteMany
   */
  export type QuoteResponseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuoteResponses to delete
     */
    where?: QuoteResponseWhereInput
  }

  /**
   * QuoteResponse.shipment
   */
  export type QuoteResponse$shipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    where?: ShipmentWhereInput
  }

  /**
   * QuoteResponse.approvedFor
   */
  export type QuoteResponse$approvedForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteRequest
     */
    select?: QuoteRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteRequestInclude<ExtArgs> | null
    where?: QuoteRequestWhereInput
  }

  /**
   * QuoteResponse.consentLogs
   */
  export type QuoteResponse$consentLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentLog
     */
    select?: ConsentLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentLogInclude<ExtArgs> | null
    where?: ConsentLogWhereInput
    orderBy?: ConsentLogOrderByWithRelationInput | ConsentLogOrderByWithRelationInput[]
    cursor?: ConsentLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConsentLogScalarFieldEnum | ConsentLogScalarFieldEnum[]
  }

  /**
   * QuoteResponse without action
   */
  export type QuoteResponseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteResponse
     */
    select?: QuoteResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteResponseInclude<ExtArgs> | null
  }


  /**
   * Model ConsentLog
   */

  export type AggregateConsentLog = {
    _count: ConsentLogCountAggregateOutputType | null
    _avg: ConsentLogAvgAggregateOutputType | null
    _sum: ConsentLogSumAggregateOutputType | null
    _min: ConsentLogMinAggregateOutputType | null
    _max: ConsentLogMaxAggregateOutputType | null
  }

  export type ConsentLogAvgAggregateOutputType = {
    id: number | null
    quoteResponseId: number | null
    shipmentId: number | null
  }

  export type ConsentLogSumAggregateOutputType = {
    id: number | null
    quoteResponseId: number | null
    shipmentId: number | null
  }

  export type ConsentLogMinAggregateOutputType = {
    id: number | null
    quoteResponseId: number | null
    shipmentId: number | null
    statusBefore: $Enums.ConsentStatus | null
    statusAfter: $Enums.ConsentStatus | null
    note: string | null
    recordedAt: Date | null
  }

  export type ConsentLogMaxAggregateOutputType = {
    id: number | null
    quoteResponseId: number | null
    shipmentId: number | null
    statusBefore: $Enums.ConsentStatus | null
    statusAfter: $Enums.ConsentStatus | null
    note: string | null
    recordedAt: Date | null
  }

  export type ConsentLogCountAggregateOutputType = {
    id: number
    quoteResponseId: number
    shipmentId: number
    statusBefore: number
    statusAfter: number
    note: number
    recordedAt: number
    _all: number
  }


  export type ConsentLogAvgAggregateInputType = {
    id?: true
    quoteResponseId?: true
    shipmentId?: true
  }

  export type ConsentLogSumAggregateInputType = {
    id?: true
    quoteResponseId?: true
    shipmentId?: true
  }

  export type ConsentLogMinAggregateInputType = {
    id?: true
    quoteResponseId?: true
    shipmentId?: true
    statusBefore?: true
    statusAfter?: true
    note?: true
    recordedAt?: true
  }

  export type ConsentLogMaxAggregateInputType = {
    id?: true
    quoteResponseId?: true
    shipmentId?: true
    statusBefore?: true
    statusAfter?: true
    note?: true
    recordedAt?: true
  }

  export type ConsentLogCountAggregateInputType = {
    id?: true
    quoteResponseId?: true
    shipmentId?: true
    statusBefore?: true
    statusAfter?: true
    note?: true
    recordedAt?: true
    _all?: true
  }

  export type ConsentLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConsentLog to aggregate.
     */
    where?: ConsentLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsentLogs to fetch.
     */
    orderBy?: ConsentLogOrderByWithRelationInput | ConsentLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConsentLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsentLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsentLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConsentLogs
    **/
    _count?: true | ConsentLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConsentLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConsentLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConsentLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConsentLogMaxAggregateInputType
  }

  export type GetConsentLogAggregateType<T extends ConsentLogAggregateArgs> = {
        [P in keyof T & keyof AggregateConsentLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsentLog[P]>
      : GetScalarType<T[P], AggregateConsentLog[P]>
  }




  export type ConsentLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsentLogWhereInput
    orderBy?: ConsentLogOrderByWithAggregationInput | ConsentLogOrderByWithAggregationInput[]
    by: ConsentLogScalarFieldEnum[] | ConsentLogScalarFieldEnum
    having?: ConsentLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConsentLogCountAggregateInputType | true
    _avg?: ConsentLogAvgAggregateInputType
    _sum?: ConsentLogSumAggregateInputType
    _min?: ConsentLogMinAggregateInputType
    _max?: ConsentLogMaxAggregateInputType
  }

  export type ConsentLogGroupByOutputType = {
    id: number
    quoteResponseId: number
    shipmentId: number | null
    statusBefore: $Enums.ConsentStatus
    statusAfter: $Enums.ConsentStatus
    note: string | null
    recordedAt: Date
    _count: ConsentLogCountAggregateOutputType | null
    _avg: ConsentLogAvgAggregateOutputType | null
    _sum: ConsentLogSumAggregateOutputType | null
    _min: ConsentLogMinAggregateOutputType | null
    _max: ConsentLogMaxAggregateOutputType | null
  }

  type GetConsentLogGroupByPayload<T extends ConsentLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConsentLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConsentLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConsentLogGroupByOutputType[P]>
            : GetScalarType<T[P], ConsentLogGroupByOutputType[P]>
        }
      >
    >


  export type ConsentLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quoteResponseId?: boolean
    shipmentId?: boolean
    statusBefore?: boolean
    statusAfter?: boolean
    note?: boolean
    recordedAt?: boolean
    quoteResponse?: boolean | QuoteResponseDefaultArgs<ExtArgs>
    shipment?: boolean | ConsentLog$shipmentArgs<ExtArgs>
  }, ExtArgs["result"]["consentLog"]>

  export type ConsentLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quoteResponseId?: boolean
    shipmentId?: boolean
    statusBefore?: boolean
    statusAfter?: boolean
    note?: boolean
    recordedAt?: boolean
    quoteResponse?: boolean | QuoteResponseDefaultArgs<ExtArgs>
    shipment?: boolean | ConsentLog$shipmentArgs<ExtArgs>
  }, ExtArgs["result"]["consentLog"]>

  export type ConsentLogSelectScalar = {
    id?: boolean
    quoteResponseId?: boolean
    shipmentId?: boolean
    statusBefore?: boolean
    statusAfter?: boolean
    note?: boolean
    recordedAt?: boolean
  }

  export type ConsentLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quoteResponse?: boolean | QuoteResponseDefaultArgs<ExtArgs>
    shipment?: boolean | ConsentLog$shipmentArgs<ExtArgs>
  }
  export type ConsentLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quoteResponse?: boolean | QuoteResponseDefaultArgs<ExtArgs>
    shipment?: boolean | ConsentLog$shipmentArgs<ExtArgs>
  }

  export type $ConsentLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConsentLog"
    objects: {
      quoteResponse: Prisma.$QuoteResponsePayload<ExtArgs>
      shipment: Prisma.$ShipmentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      quoteResponseId: number
      shipmentId: number | null
      statusBefore: $Enums.ConsentStatus
      statusAfter: $Enums.ConsentStatus
      note: string | null
      recordedAt: Date
    }, ExtArgs["result"]["consentLog"]>
    composites: {}
  }

  type ConsentLogGetPayload<S extends boolean | null | undefined | ConsentLogDefaultArgs> = $Result.GetResult<Prisma.$ConsentLogPayload, S>

  type ConsentLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConsentLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConsentLogCountAggregateInputType | true
    }

  export interface ConsentLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConsentLog'], meta: { name: 'ConsentLog' } }
    /**
     * Find zero or one ConsentLog that matches the filter.
     * @param {ConsentLogFindUniqueArgs} args - Arguments to find a ConsentLog
     * @example
     * // Get one ConsentLog
     * const consentLog = await prisma.consentLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConsentLogFindUniqueArgs>(args: SelectSubset<T, ConsentLogFindUniqueArgs<ExtArgs>>): Prisma__ConsentLogClient<$Result.GetResult<Prisma.$ConsentLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ConsentLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConsentLogFindUniqueOrThrowArgs} args - Arguments to find a ConsentLog
     * @example
     * // Get one ConsentLog
     * const consentLog = await prisma.consentLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConsentLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ConsentLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConsentLogClient<$Result.GetResult<Prisma.$ConsentLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ConsentLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentLogFindFirstArgs} args - Arguments to find a ConsentLog
     * @example
     * // Get one ConsentLog
     * const consentLog = await prisma.consentLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConsentLogFindFirstArgs>(args?: SelectSubset<T, ConsentLogFindFirstArgs<ExtArgs>>): Prisma__ConsentLogClient<$Result.GetResult<Prisma.$ConsentLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ConsentLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentLogFindFirstOrThrowArgs} args - Arguments to find a ConsentLog
     * @example
     * // Get one ConsentLog
     * const consentLog = await prisma.consentLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConsentLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ConsentLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConsentLogClient<$Result.GetResult<Prisma.$ConsentLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ConsentLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConsentLogs
     * const consentLogs = await prisma.consentLog.findMany()
     * 
     * // Get first 10 ConsentLogs
     * const consentLogs = await prisma.consentLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const consentLogWithIdOnly = await prisma.consentLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConsentLogFindManyArgs>(args?: SelectSubset<T, ConsentLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsentLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ConsentLog.
     * @param {ConsentLogCreateArgs} args - Arguments to create a ConsentLog.
     * @example
     * // Create one ConsentLog
     * const ConsentLog = await prisma.consentLog.create({
     *   data: {
     *     // ... data to create a ConsentLog
     *   }
     * })
     * 
     */
    create<T extends ConsentLogCreateArgs>(args: SelectSubset<T, ConsentLogCreateArgs<ExtArgs>>): Prisma__ConsentLogClient<$Result.GetResult<Prisma.$ConsentLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ConsentLogs.
     * @param {ConsentLogCreateManyArgs} args - Arguments to create many ConsentLogs.
     * @example
     * // Create many ConsentLogs
     * const consentLog = await prisma.consentLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConsentLogCreateManyArgs>(args?: SelectSubset<T, ConsentLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConsentLogs and returns the data saved in the database.
     * @param {ConsentLogCreateManyAndReturnArgs} args - Arguments to create many ConsentLogs.
     * @example
     * // Create many ConsentLogs
     * const consentLog = await prisma.consentLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConsentLogs and only return the `id`
     * const consentLogWithIdOnly = await prisma.consentLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConsentLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ConsentLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsentLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ConsentLog.
     * @param {ConsentLogDeleteArgs} args - Arguments to delete one ConsentLog.
     * @example
     * // Delete one ConsentLog
     * const ConsentLog = await prisma.consentLog.delete({
     *   where: {
     *     // ... filter to delete one ConsentLog
     *   }
     * })
     * 
     */
    delete<T extends ConsentLogDeleteArgs>(args: SelectSubset<T, ConsentLogDeleteArgs<ExtArgs>>): Prisma__ConsentLogClient<$Result.GetResult<Prisma.$ConsentLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ConsentLog.
     * @param {ConsentLogUpdateArgs} args - Arguments to update one ConsentLog.
     * @example
     * // Update one ConsentLog
     * const consentLog = await prisma.consentLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConsentLogUpdateArgs>(args: SelectSubset<T, ConsentLogUpdateArgs<ExtArgs>>): Prisma__ConsentLogClient<$Result.GetResult<Prisma.$ConsentLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ConsentLogs.
     * @param {ConsentLogDeleteManyArgs} args - Arguments to filter ConsentLogs to delete.
     * @example
     * // Delete a few ConsentLogs
     * const { count } = await prisma.consentLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConsentLogDeleteManyArgs>(args?: SelectSubset<T, ConsentLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConsentLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConsentLogs
     * const consentLog = await prisma.consentLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConsentLogUpdateManyArgs>(args: SelectSubset<T, ConsentLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConsentLog.
     * @param {ConsentLogUpsertArgs} args - Arguments to update or create a ConsentLog.
     * @example
     * // Update or create a ConsentLog
     * const consentLog = await prisma.consentLog.upsert({
     *   create: {
     *     // ... data to create a ConsentLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConsentLog we want to update
     *   }
     * })
     */
    upsert<T extends ConsentLogUpsertArgs>(args: SelectSubset<T, ConsentLogUpsertArgs<ExtArgs>>): Prisma__ConsentLogClient<$Result.GetResult<Prisma.$ConsentLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ConsentLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentLogCountArgs} args - Arguments to filter ConsentLogs to count.
     * @example
     * // Count the number of ConsentLogs
     * const count = await prisma.consentLog.count({
     *   where: {
     *     // ... the filter for the ConsentLogs we want to count
     *   }
     * })
    **/
    count<T extends ConsentLogCountArgs>(
      args?: Subset<T, ConsentLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConsentLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConsentLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConsentLogAggregateArgs>(args: Subset<T, ConsentLogAggregateArgs>): Prisma.PrismaPromise<GetConsentLogAggregateType<T>>

    /**
     * Group by ConsentLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConsentLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConsentLogGroupByArgs['orderBy'] }
        : { orderBy?: ConsentLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConsentLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConsentLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConsentLog model
   */
  readonly fields: ConsentLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConsentLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConsentLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quoteResponse<T extends QuoteResponseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuoteResponseDefaultArgs<ExtArgs>>): Prisma__QuoteResponseClient<$Result.GetResult<Prisma.$QuoteResponsePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    shipment<T extends ConsentLog$shipmentArgs<ExtArgs> = {}>(args?: Subset<T, ConsentLog$shipmentArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConsentLog model
   */ 
  interface ConsentLogFieldRefs {
    readonly id: FieldRef<"ConsentLog", 'Int'>
    readonly quoteResponseId: FieldRef<"ConsentLog", 'Int'>
    readonly shipmentId: FieldRef<"ConsentLog", 'Int'>
    readonly statusBefore: FieldRef<"ConsentLog", 'ConsentStatus'>
    readonly statusAfter: FieldRef<"ConsentLog", 'ConsentStatus'>
    readonly note: FieldRef<"ConsentLog", 'String'>
    readonly recordedAt: FieldRef<"ConsentLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConsentLog findUnique
   */
  export type ConsentLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentLog
     */
    select?: ConsentLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentLogInclude<ExtArgs> | null
    /**
     * Filter, which ConsentLog to fetch.
     */
    where: ConsentLogWhereUniqueInput
  }

  /**
   * ConsentLog findUniqueOrThrow
   */
  export type ConsentLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentLog
     */
    select?: ConsentLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentLogInclude<ExtArgs> | null
    /**
     * Filter, which ConsentLog to fetch.
     */
    where: ConsentLogWhereUniqueInput
  }

  /**
   * ConsentLog findFirst
   */
  export type ConsentLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentLog
     */
    select?: ConsentLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentLogInclude<ExtArgs> | null
    /**
     * Filter, which ConsentLog to fetch.
     */
    where?: ConsentLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsentLogs to fetch.
     */
    orderBy?: ConsentLogOrderByWithRelationInput | ConsentLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConsentLogs.
     */
    cursor?: ConsentLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsentLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsentLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConsentLogs.
     */
    distinct?: ConsentLogScalarFieldEnum | ConsentLogScalarFieldEnum[]
  }

  /**
   * ConsentLog findFirstOrThrow
   */
  export type ConsentLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentLog
     */
    select?: ConsentLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentLogInclude<ExtArgs> | null
    /**
     * Filter, which ConsentLog to fetch.
     */
    where?: ConsentLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsentLogs to fetch.
     */
    orderBy?: ConsentLogOrderByWithRelationInput | ConsentLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConsentLogs.
     */
    cursor?: ConsentLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsentLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsentLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConsentLogs.
     */
    distinct?: ConsentLogScalarFieldEnum | ConsentLogScalarFieldEnum[]
  }

  /**
   * ConsentLog findMany
   */
  export type ConsentLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentLog
     */
    select?: ConsentLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentLogInclude<ExtArgs> | null
    /**
     * Filter, which ConsentLogs to fetch.
     */
    where?: ConsentLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsentLogs to fetch.
     */
    orderBy?: ConsentLogOrderByWithRelationInput | ConsentLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConsentLogs.
     */
    cursor?: ConsentLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsentLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsentLogs.
     */
    skip?: number
    distinct?: ConsentLogScalarFieldEnum | ConsentLogScalarFieldEnum[]
  }

  /**
   * ConsentLog create
   */
  export type ConsentLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentLog
     */
    select?: ConsentLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ConsentLog.
     */
    data: XOR<ConsentLogCreateInput, ConsentLogUncheckedCreateInput>
  }

  /**
   * ConsentLog createMany
   */
  export type ConsentLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConsentLogs.
     */
    data: ConsentLogCreateManyInput | ConsentLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConsentLog createManyAndReturn
   */
  export type ConsentLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentLog
     */
    select?: ConsentLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ConsentLogs.
     */
    data: ConsentLogCreateManyInput | ConsentLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConsentLog update
   */
  export type ConsentLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentLog
     */
    select?: ConsentLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ConsentLog.
     */
    data: XOR<ConsentLogUpdateInput, ConsentLogUncheckedUpdateInput>
    /**
     * Choose, which ConsentLog to update.
     */
    where: ConsentLogWhereUniqueInput
  }

  /**
   * ConsentLog updateMany
   */
  export type ConsentLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConsentLogs.
     */
    data: XOR<ConsentLogUpdateManyMutationInput, ConsentLogUncheckedUpdateManyInput>
    /**
     * Filter which ConsentLogs to update
     */
    where?: ConsentLogWhereInput
  }

  /**
   * ConsentLog upsert
   */
  export type ConsentLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentLog
     */
    select?: ConsentLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ConsentLog to update in case it exists.
     */
    where: ConsentLogWhereUniqueInput
    /**
     * In case the ConsentLog found by the `where` argument doesn't exist, create a new ConsentLog with this data.
     */
    create: XOR<ConsentLogCreateInput, ConsentLogUncheckedCreateInput>
    /**
     * In case the ConsentLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConsentLogUpdateInput, ConsentLogUncheckedUpdateInput>
  }

  /**
   * ConsentLog delete
   */
  export type ConsentLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentLog
     */
    select?: ConsentLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentLogInclude<ExtArgs> | null
    /**
     * Filter which ConsentLog to delete.
     */
    where: ConsentLogWhereUniqueInput
  }

  /**
   * ConsentLog deleteMany
   */
  export type ConsentLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConsentLogs to delete
     */
    where?: ConsentLogWhereInput
  }

  /**
   * ConsentLog.shipment
   */
  export type ConsentLog$shipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    where?: ShipmentWhereInput
  }

  /**
   * ConsentLog without action
   */
  export type ConsentLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentLog
     */
    select?: ConsentLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentLogInclude<ExtArgs> | null
  }


  /**
   * Model Shipment
   */

  export type AggregateShipment = {
    _count: ShipmentCountAggregateOutputType | null
    _avg: ShipmentAvgAggregateOutputType | null
    _sum: ShipmentSumAggregateOutputType | null
    _min: ShipmentMinAggregateOutputType | null
    _max: ShipmentMaxAggregateOutputType | null
  }

  export type ShipmentAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    companyId: number | null
    quoteRequestId: number | null
    transporterQuoteId: number | null
    selectedVendorId: number | null
    agreementId: number | null
    rateCardId: number | null
    fromLat: number | null
    fromLng: number | null
    toLat: number | null
    toLng: number | null
    weight: number | null
    cost: number | null
    distance: number | null
    assignedToId: number | null
    gstInvoiceId: number | null
  }

  export type ShipmentSumAggregateOutputType = {
    id: number | null
    userId: number | null
    companyId: number | null
    quoteRequestId: number | null
    transporterQuoteId: number | null
    selectedVendorId: number | null
    agreementId: number | null
    rateCardId: number | null
    fromLat: number | null
    fromLng: number | null
    toLat: number | null
    toLng: number | null
    weight: number | null
    cost: number | null
    distance: number | null
    assignedToId: number | null
    gstInvoiceId: number | null
  }

  export type ShipmentMinAggregateOutputType = {
    id: number | null
    userId: number | null
    companyId: number | null
    quoteRequestId: number | null
    transporterQuoteId: number | null
    selectedVendorId: number | null
    agreementId: number | null
    rateCardId: number | null
    trackingNumber: string | null
    fromLocation: string | null
    toLocation: string | null
    fromLat: number | null
    fromLng: number | null
    toLat: number | null
    toLng: number | null
    weight: number | null
    shipmentType: string | null
    urgency: string | null
    status: $Enums.ShipmentStatus | null
    bookingStatus: $Enums.BookingStatus | null
    paymentStatus: $Enums.PaymentStatus | null
    cost: number | null
    distance: number | null
    estimatedDelivery: Date | null
    pickupTime: Date | null
    deliveryTime: Date | null
    assignedToId: number | null
    assignedDriver: string | null
    driverPhone: string | null
    driverEta: Date | null
    transporterResponseNotes: string | null
    notes: string | null
    ewayBillNumber: string | null
    gstInvoiceId: number | null
    complianceStatus: $Enums.ComplianceStatus | null
    source: string | null
    podStatus: string | null
    podUrl: string | null
    podNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShipmentMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    companyId: number | null
    quoteRequestId: number | null
    transporterQuoteId: number | null
    selectedVendorId: number | null
    agreementId: number | null
    rateCardId: number | null
    trackingNumber: string | null
    fromLocation: string | null
    toLocation: string | null
    fromLat: number | null
    fromLng: number | null
    toLat: number | null
    toLng: number | null
    weight: number | null
    shipmentType: string | null
    urgency: string | null
    status: $Enums.ShipmentStatus | null
    bookingStatus: $Enums.BookingStatus | null
    paymentStatus: $Enums.PaymentStatus | null
    cost: number | null
    distance: number | null
    estimatedDelivery: Date | null
    pickupTime: Date | null
    deliveryTime: Date | null
    assignedToId: number | null
    assignedDriver: string | null
    driverPhone: string | null
    driverEta: Date | null
    transporterResponseNotes: string | null
    notes: string | null
    ewayBillNumber: string | null
    gstInvoiceId: number | null
    complianceStatus: $Enums.ComplianceStatus | null
    source: string | null
    podStatus: string | null
    podUrl: string | null
    podNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShipmentCountAggregateOutputType = {
    id: number
    userId: number
    companyId: number
    quoteRequestId: number
    transporterQuoteId: number
    selectedVendorId: number
    agreementId: number
    rateCardId: number
    trackingNumber: number
    fromLocation: number
    toLocation: number
    fromLat: number
    fromLng: number
    toLat: number
    toLng: number
    weight: number
    shipmentType: number
    urgency: number
    status: number
    bookingStatus: number
    paymentStatus: number
    cost: number
    distance: number
    estimatedDelivery: number
    pickupTime: number
    deliveryTime: number
    assignedToId: number
    assignedDriver: number
    driverPhone: number
    driverEta: number
    transporterResponseNotes: number
    notes: number
    ewayBillNumber: number
    gstInvoiceId: number
    complianceStatus: number
    source: number
    podStatus: number
    podUrl: number
    podNotes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShipmentAvgAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    quoteRequestId?: true
    transporterQuoteId?: true
    selectedVendorId?: true
    agreementId?: true
    rateCardId?: true
    fromLat?: true
    fromLng?: true
    toLat?: true
    toLng?: true
    weight?: true
    cost?: true
    distance?: true
    assignedToId?: true
    gstInvoiceId?: true
  }

  export type ShipmentSumAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    quoteRequestId?: true
    transporterQuoteId?: true
    selectedVendorId?: true
    agreementId?: true
    rateCardId?: true
    fromLat?: true
    fromLng?: true
    toLat?: true
    toLng?: true
    weight?: true
    cost?: true
    distance?: true
    assignedToId?: true
    gstInvoiceId?: true
  }

  export type ShipmentMinAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    quoteRequestId?: true
    transporterQuoteId?: true
    selectedVendorId?: true
    agreementId?: true
    rateCardId?: true
    trackingNumber?: true
    fromLocation?: true
    toLocation?: true
    fromLat?: true
    fromLng?: true
    toLat?: true
    toLng?: true
    weight?: true
    shipmentType?: true
    urgency?: true
    status?: true
    bookingStatus?: true
    paymentStatus?: true
    cost?: true
    distance?: true
    estimatedDelivery?: true
    pickupTime?: true
    deliveryTime?: true
    assignedToId?: true
    assignedDriver?: true
    driverPhone?: true
    driverEta?: true
    transporterResponseNotes?: true
    notes?: true
    ewayBillNumber?: true
    gstInvoiceId?: true
    complianceStatus?: true
    source?: true
    podStatus?: true
    podUrl?: true
    podNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShipmentMaxAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    quoteRequestId?: true
    transporterQuoteId?: true
    selectedVendorId?: true
    agreementId?: true
    rateCardId?: true
    trackingNumber?: true
    fromLocation?: true
    toLocation?: true
    fromLat?: true
    fromLng?: true
    toLat?: true
    toLng?: true
    weight?: true
    shipmentType?: true
    urgency?: true
    status?: true
    bookingStatus?: true
    paymentStatus?: true
    cost?: true
    distance?: true
    estimatedDelivery?: true
    pickupTime?: true
    deliveryTime?: true
    assignedToId?: true
    assignedDriver?: true
    driverPhone?: true
    driverEta?: true
    transporterResponseNotes?: true
    notes?: true
    ewayBillNumber?: true
    gstInvoiceId?: true
    complianceStatus?: true
    source?: true
    podStatus?: true
    podUrl?: true
    podNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShipmentCountAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    quoteRequestId?: true
    transporterQuoteId?: true
    selectedVendorId?: true
    agreementId?: true
    rateCardId?: true
    trackingNumber?: true
    fromLocation?: true
    toLocation?: true
    fromLat?: true
    fromLng?: true
    toLat?: true
    toLng?: true
    weight?: true
    shipmentType?: true
    urgency?: true
    status?: true
    bookingStatus?: true
    paymentStatus?: true
    cost?: true
    distance?: true
    estimatedDelivery?: true
    pickupTime?: true
    deliveryTime?: true
    assignedToId?: true
    assignedDriver?: true
    driverPhone?: true
    driverEta?: true
    transporterResponseNotes?: true
    notes?: true
    ewayBillNumber?: true
    gstInvoiceId?: true
    complianceStatus?: true
    source?: true
    podStatus?: true
    podUrl?: true
    podNotes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShipmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shipment to aggregate.
     */
    where?: ShipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shipments to fetch.
     */
    orderBy?: ShipmentOrderByWithRelationInput | ShipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shipments
    **/
    _count?: true | ShipmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShipmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShipmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShipmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShipmentMaxAggregateInputType
  }

  export type GetShipmentAggregateType<T extends ShipmentAggregateArgs> = {
        [P in keyof T & keyof AggregateShipment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShipment[P]>
      : GetScalarType<T[P], AggregateShipment[P]>
  }




  export type ShipmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShipmentWhereInput
    orderBy?: ShipmentOrderByWithAggregationInput | ShipmentOrderByWithAggregationInput[]
    by: ShipmentScalarFieldEnum[] | ShipmentScalarFieldEnum
    having?: ShipmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShipmentCountAggregateInputType | true
    _avg?: ShipmentAvgAggregateInputType
    _sum?: ShipmentSumAggregateInputType
    _min?: ShipmentMinAggregateInputType
    _max?: ShipmentMaxAggregateInputType
  }

  export type ShipmentGroupByOutputType = {
    id: number
    userId: number
    companyId: number | null
    quoteRequestId: number | null
    transporterQuoteId: number | null
    selectedVendorId: number | null
    agreementId: number | null
    rateCardId: number | null
    trackingNumber: string | null
    fromLocation: string
    toLocation: string
    fromLat: number | null
    fromLng: number | null
    toLat: number | null
    toLng: number | null
    weight: number | null
    shipmentType: string | null
    urgency: string | null
    status: $Enums.ShipmentStatus
    bookingStatus: $Enums.BookingStatus | null
    paymentStatus: $Enums.PaymentStatus | null
    cost: number | null
    distance: number | null
    estimatedDelivery: Date | null
    pickupTime: Date | null
    deliveryTime: Date | null
    assignedToId: number | null
    assignedDriver: string | null
    driverPhone: string | null
    driverEta: Date | null
    transporterResponseNotes: string | null
    notes: string | null
    ewayBillNumber: string | null
    gstInvoiceId: number | null
    complianceStatus: $Enums.ComplianceStatus
    source: string
    podStatus: string
    podUrl: string | null
    podNotes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ShipmentCountAggregateOutputType | null
    _avg: ShipmentAvgAggregateOutputType | null
    _sum: ShipmentSumAggregateOutputType | null
    _min: ShipmentMinAggregateOutputType | null
    _max: ShipmentMaxAggregateOutputType | null
  }

  type GetShipmentGroupByPayload<T extends ShipmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShipmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShipmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShipmentGroupByOutputType[P]>
            : GetScalarType<T[P], ShipmentGroupByOutputType[P]>
        }
      >
    >


  export type ShipmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    quoteRequestId?: boolean
    transporterQuoteId?: boolean
    selectedVendorId?: boolean
    agreementId?: boolean
    rateCardId?: boolean
    trackingNumber?: boolean
    fromLocation?: boolean
    toLocation?: boolean
    fromLat?: boolean
    fromLng?: boolean
    toLat?: boolean
    toLng?: boolean
    weight?: boolean
    shipmentType?: boolean
    urgency?: boolean
    status?: boolean
    bookingStatus?: boolean
    paymentStatus?: boolean
    cost?: boolean
    distance?: boolean
    estimatedDelivery?: boolean
    pickupTime?: boolean
    deliveryTime?: boolean
    assignedToId?: boolean
    assignedDriver?: boolean
    driverPhone?: boolean
    driverEta?: boolean
    transporterResponseNotes?: boolean
    notes?: boolean
    ewayBillNumber?: boolean
    gstInvoiceId?: boolean
    complianceStatus?: boolean
    source?: boolean
    podStatus?: boolean
    podUrl?: boolean
    podNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | Shipment$companyArgs<ExtArgs>
    quoteRequest?: boolean | Shipment$quoteRequestArgs<ExtArgs>
    transporterQuote?: boolean | Shipment$transporterQuoteArgs<ExtArgs>
    rateCard?: boolean | Shipment$rateCardArgs<ExtArgs>
    vendor?: boolean | Shipment$vendorArgs<ExtArgs>
    assignedTo?: boolean | Shipment$assignedToArgs<ExtArgs>
    statusHistory?: boolean | Shipment$statusHistoryArgs<ExtArgs>
    complianceDocs?: boolean | Shipment$complianceDocsArgs<ExtArgs>
    payments?: boolean | Shipment$paymentsArgs<ExtArgs>
    invoice?: boolean | Shipment$invoiceArgs<ExtArgs>
    consentLogs?: boolean | Shipment$consentLogsArgs<ExtArgs>
    transporterInvoices?: boolean | Shipment$transporterInvoicesArgs<ExtArgs>
    _count?: boolean | ShipmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shipment"]>

  export type ShipmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    quoteRequestId?: boolean
    transporterQuoteId?: boolean
    selectedVendorId?: boolean
    agreementId?: boolean
    rateCardId?: boolean
    trackingNumber?: boolean
    fromLocation?: boolean
    toLocation?: boolean
    fromLat?: boolean
    fromLng?: boolean
    toLat?: boolean
    toLng?: boolean
    weight?: boolean
    shipmentType?: boolean
    urgency?: boolean
    status?: boolean
    bookingStatus?: boolean
    paymentStatus?: boolean
    cost?: boolean
    distance?: boolean
    estimatedDelivery?: boolean
    pickupTime?: boolean
    deliveryTime?: boolean
    assignedToId?: boolean
    assignedDriver?: boolean
    driverPhone?: boolean
    driverEta?: boolean
    transporterResponseNotes?: boolean
    notes?: boolean
    ewayBillNumber?: boolean
    gstInvoiceId?: boolean
    complianceStatus?: boolean
    source?: boolean
    podStatus?: boolean
    podUrl?: boolean
    podNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | Shipment$companyArgs<ExtArgs>
    quoteRequest?: boolean | Shipment$quoteRequestArgs<ExtArgs>
    transporterQuote?: boolean | Shipment$transporterQuoteArgs<ExtArgs>
    rateCard?: boolean | Shipment$rateCardArgs<ExtArgs>
    vendor?: boolean | Shipment$vendorArgs<ExtArgs>
    assignedTo?: boolean | Shipment$assignedToArgs<ExtArgs>
  }, ExtArgs["result"]["shipment"]>

  export type ShipmentSelectScalar = {
    id?: boolean
    userId?: boolean
    companyId?: boolean
    quoteRequestId?: boolean
    transporterQuoteId?: boolean
    selectedVendorId?: boolean
    agreementId?: boolean
    rateCardId?: boolean
    trackingNumber?: boolean
    fromLocation?: boolean
    toLocation?: boolean
    fromLat?: boolean
    fromLng?: boolean
    toLat?: boolean
    toLng?: boolean
    weight?: boolean
    shipmentType?: boolean
    urgency?: boolean
    status?: boolean
    bookingStatus?: boolean
    paymentStatus?: boolean
    cost?: boolean
    distance?: boolean
    estimatedDelivery?: boolean
    pickupTime?: boolean
    deliveryTime?: boolean
    assignedToId?: boolean
    assignedDriver?: boolean
    driverPhone?: boolean
    driverEta?: boolean
    transporterResponseNotes?: boolean
    notes?: boolean
    ewayBillNumber?: boolean
    gstInvoiceId?: boolean
    complianceStatus?: boolean
    source?: boolean
    podStatus?: boolean
    podUrl?: boolean
    podNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShipmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | Shipment$companyArgs<ExtArgs>
    quoteRequest?: boolean | Shipment$quoteRequestArgs<ExtArgs>
    transporterQuote?: boolean | Shipment$transporterQuoteArgs<ExtArgs>
    rateCard?: boolean | Shipment$rateCardArgs<ExtArgs>
    vendor?: boolean | Shipment$vendorArgs<ExtArgs>
    assignedTo?: boolean | Shipment$assignedToArgs<ExtArgs>
    statusHistory?: boolean | Shipment$statusHistoryArgs<ExtArgs>
    complianceDocs?: boolean | Shipment$complianceDocsArgs<ExtArgs>
    payments?: boolean | Shipment$paymentsArgs<ExtArgs>
    invoice?: boolean | Shipment$invoiceArgs<ExtArgs>
    consentLogs?: boolean | Shipment$consentLogsArgs<ExtArgs>
    transporterInvoices?: boolean | Shipment$transporterInvoicesArgs<ExtArgs>
    _count?: boolean | ShipmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ShipmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | Shipment$companyArgs<ExtArgs>
    quoteRequest?: boolean | Shipment$quoteRequestArgs<ExtArgs>
    transporterQuote?: boolean | Shipment$transporterQuoteArgs<ExtArgs>
    rateCard?: boolean | Shipment$rateCardArgs<ExtArgs>
    vendor?: boolean | Shipment$vendorArgs<ExtArgs>
    assignedTo?: boolean | Shipment$assignedToArgs<ExtArgs>
  }

  export type $ShipmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Shipment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs> | null
      quoteRequest: Prisma.$QuoteRequestPayload<ExtArgs> | null
      transporterQuote: Prisma.$QuoteResponsePayload<ExtArgs> | null
      rateCard: Prisma.$RateCardPayload<ExtArgs> | null
      vendor: Prisma.$VendorPayload<ExtArgs> | null
      assignedTo: Prisma.$UserPayload<ExtArgs> | null
      statusHistory: Prisma.$StatusHistoryPayload<ExtArgs>[]
      complianceDocs: Prisma.$ComplianceDocumentPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
      consentLogs: Prisma.$ConsentLogPayload<ExtArgs>[]
      transporterInvoices: Prisma.$TransporterInvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      companyId: number | null
      quoteRequestId: number | null
      transporterQuoteId: number | null
      selectedVendorId: number | null
      agreementId: number | null
      rateCardId: number | null
      trackingNumber: string | null
      fromLocation: string
      toLocation: string
      fromLat: number | null
      fromLng: number | null
      toLat: number | null
      toLng: number | null
      weight: number | null
      shipmentType: string | null
      urgency: string | null
      status: $Enums.ShipmentStatus
      bookingStatus: $Enums.BookingStatus | null
      paymentStatus: $Enums.PaymentStatus | null
      cost: number | null
      distance: number | null
      estimatedDelivery: Date | null
      pickupTime: Date | null
      deliveryTime: Date | null
      assignedToId: number | null
      assignedDriver: string | null
      driverPhone: string | null
      driverEta: Date | null
      transporterResponseNotes: string | null
      notes: string | null
      ewayBillNumber: string | null
      gstInvoiceId: number | null
      complianceStatus: $Enums.ComplianceStatus
      source: string
      podStatus: string
      podUrl: string | null
      podNotes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shipment"]>
    composites: {}
  }

  type ShipmentGetPayload<S extends boolean | null | undefined | ShipmentDefaultArgs> = $Result.GetResult<Prisma.$ShipmentPayload, S>

  type ShipmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ShipmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ShipmentCountAggregateInputType | true
    }

  export interface ShipmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shipment'], meta: { name: 'Shipment' } }
    /**
     * Find zero or one Shipment that matches the filter.
     * @param {ShipmentFindUniqueArgs} args - Arguments to find a Shipment
     * @example
     * // Get one Shipment
     * const shipment = await prisma.shipment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShipmentFindUniqueArgs>(args: SelectSubset<T, ShipmentFindUniqueArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Shipment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ShipmentFindUniqueOrThrowArgs} args - Arguments to find a Shipment
     * @example
     * // Get one Shipment
     * const shipment = await prisma.shipment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShipmentFindUniqueOrThrowArgs>(args: SelectSubset<T, ShipmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Shipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentFindFirstArgs} args - Arguments to find a Shipment
     * @example
     * // Get one Shipment
     * const shipment = await prisma.shipment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShipmentFindFirstArgs>(args?: SelectSubset<T, ShipmentFindFirstArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Shipment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentFindFirstOrThrowArgs} args - Arguments to find a Shipment
     * @example
     * // Get one Shipment
     * const shipment = await prisma.shipment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShipmentFindFirstOrThrowArgs>(args?: SelectSubset<T, ShipmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Shipments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shipments
     * const shipments = await prisma.shipment.findMany()
     * 
     * // Get first 10 Shipments
     * const shipments = await prisma.shipment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shipmentWithIdOnly = await prisma.shipment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShipmentFindManyArgs>(args?: SelectSubset<T, ShipmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Shipment.
     * @param {ShipmentCreateArgs} args - Arguments to create a Shipment.
     * @example
     * // Create one Shipment
     * const Shipment = await prisma.shipment.create({
     *   data: {
     *     // ... data to create a Shipment
     *   }
     * })
     * 
     */
    create<T extends ShipmentCreateArgs>(args: SelectSubset<T, ShipmentCreateArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Shipments.
     * @param {ShipmentCreateManyArgs} args - Arguments to create many Shipments.
     * @example
     * // Create many Shipments
     * const shipment = await prisma.shipment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShipmentCreateManyArgs>(args?: SelectSubset<T, ShipmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Shipments and returns the data saved in the database.
     * @param {ShipmentCreateManyAndReturnArgs} args - Arguments to create many Shipments.
     * @example
     * // Create many Shipments
     * const shipment = await prisma.shipment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Shipments and only return the `id`
     * const shipmentWithIdOnly = await prisma.shipment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShipmentCreateManyAndReturnArgs>(args?: SelectSubset<T, ShipmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Shipment.
     * @param {ShipmentDeleteArgs} args - Arguments to delete one Shipment.
     * @example
     * // Delete one Shipment
     * const Shipment = await prisma.shipment.delete({
     *   where: {
     *     // ... filter to delete one Shipment
     *   }
     * })
     * 
     */
    delete<T extends ShipmentDeleteArgs>(args: SelectSubset<T, ShipmentDeleteArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Shipment.
     * @param {ShipmentUpdateArgs} args - Arguments to update one Shipment.
     * @example
     * // Update one Shipment
     * const shipment = await prisma.shipment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShipmentUpdateArgs>(args: SelectSubset<T, ShipmentUpdateArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Shipments.
     * @param {ShipmentDeleteManyArgs} args - Arguments to filter Shipments to delete.
     * @example
     * // Delete a few Shipments
     * const { count } = await prisma.shipment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShipmentDeleteManyArgs>(args?: SelectSubset<T, ShipmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shipments
     * const shipment = await prisma.shipment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShipmentUpdateManyArgs>(args: SelectSubset<T, ShipmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Shipment.
     * @param {ShipmentUpsertArgs} args - Arguments to update or create a Shipment.
     * @example
     * // Update or create a Shipment
     * const shipment = await prisma.shipment.upsert({
     *   create: {
     *     // ... data to create a Shipment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shipment we want to update
     *   }
     * })
     */
    upsert<T extends ShipmentUpsertArgs>(args: SelectSubset<T, ShipmentUpsertArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Shipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentCountArgs} args - Arguments to filter Shipments to count.
     * @example
     * // Count the number of Shipments
     * const count = await prisma.shipment.count({
     *   where: {
     *     // ... the filter for the Shipments we want to count
     *   }
     * })
    **/
    count<T extends ShipmentCountArgs>(
      args?: Subset<T, ShipmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShipmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShipmentAggregateArgs>(args: Subset<T, ShipmentAggregateArgs>): Prisma.PrismaPromise<GetShipmentAggregateType<T>>

    /**
     * Group by Shipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShipmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShipmentGroupByArgs['orderBy'] }
        : { orderBy?: ShipmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShipmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShipmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shipment model
   */
  readonly fields: ShipmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shipment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShipmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    company<T extends Shipment$companyArgs<ExtArgs> = {}>(args?: Subset<T, Shipment$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    quoteRequest<T extends Shipment$quoteRequestArgs<ExtArgs> = {}>(args?: Subset<T, Shipment$quoteRequestArgs<ExtArgs>>): Prisma__QuoteRequestClient<$Result.GetResult<Prisma.$QuoteRequestPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    transporterQuote<T extends Shipment$transporterQuoteArgs<ExtArgs> = {}>(args?: Subset<T, Shipment$transporterQuoteArgs<ExtArgs>>): Prisma__QuoteResponseClient<$Result.GetResult<Prisma.$QuoteResponsePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    rateCard<T extends Shipment$rateCardArgs<ExtArgs> = {}>(args?: Subset<T, Shipment$rateCardArgs<ExtArgs>>): Prisma__RateCardClient<$Result.GetResult<Prisma.$RateCardPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    vendor<T extends Shipment$vendorArgs<ExtArgs> = {}>(args?: Subset<T, Shipment$vendorArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    assignedTo<T extends Shipment$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, Shipment$assignedToArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    statusHistory<T extends Shipment$statusHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Shipment$statusHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatusHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    complianceDocs<T extends Shipment$complianceDocsArgs<ExtArgs> = {}>(args?: Subset<T, Shipment$complianceDocsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplianceDocumentPayload<ExtArgs>, T, "findMany"> | Null>
    payments<T extends Shipment$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Shipment$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    invoice<T extends Shipment$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, Shipment$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    consentLogs<T extends Shipment$consentLogsArgs<ExtArgs> = {}>(args?: Subset<T, Shipment$consentLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsentLogPayload<ExtArgs>, T, "findMany"> | Null>
    transporterInvoices<T extends Shipment$transporterInvoicesArgs<ExtArgs> = {}>(args?: Subset<T, Shipment$transporterInvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransporterInvoicePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Shipment model
   */ 
  interface ShipmentFieldRefs {
    readonly id: FieldRef<"Shipment", 'Int'>
    readonly userId: FieldRef<"Shipment", 'Int'>
    readonly companyId: FieldRef<"Shipment", 'Int'>
    readonly quoteRequestId: FieldRef<"Shipment", 'Int'>
    readonly transporterQuoteId: FieldRef<"Shipment", 'Int'>
    readonly selectedVendorId: FieldRef<"Shipment", 'Int'>
    readonly agreementId: FieldRef<"Shipment", 'Int'>
    readonly rateCardId: FieldRef<"Shipment", 'Int'>
    readonly trackingNumber: FieldRef<"Shipment", 'String'>
    readonly fromLocation: FieldRef<"Shipment", 'String'>
    readonly toLocation: FieldRef<"Shipment", 'String'>
    readonly fromLat: FieldRef<"Shipment", 'Float'>
    readonly fromLng: FieldRef<"Shipment", 'Float'>
    readonly toLat: FieldRef<"Shipment", 'Float'>
    readonly toLng: FieldRef<"Shipment", 'Float'>
    readonly weight: FieldRef<"Shipment", 'Float'>
    readonly shipmentType: FieldRef<"Shipment", 'String'>
    readonly urgency: FieldRef<"Shipment", 'String'>
    readonly status: FieldRef<"Shipment", 'ShipmentStatus'>
    readonly bookingStatus: FieldRef<"Shipment", 'BookingStatus'>
    readonly paymentStatus: FieldRef<"Shipment", 'PaymentStatus'>
    readonly cost: FieldRef<"Shipment", 'Float'>
    readonly distance: FieldRef<"Shipment", 'Float'>
    readonly estimatedDelivery: FieldRef<"Shipment", 'DateTime'>
    readonly pickupTime: FieldRef<"Shipment", 'DateTime'>
    readonly deliveryTime: FieldRef<"Shipment", 'DateTime'>
    readonly assignedToId: FieldRef<"Shipment", 'Int'>
    readonly assignedDriver: FieldRef<"Shipment", 'String'>
    readonly driverPhone: FieldRef<"Shipment", 'String'>
    readonly driverEta: FieldRef<"Shipment", 'DateTime'>
    readonly transporterResponseNotes: FieldRef<"Shipment", 'String'>
    readonly notes: FieldRef<"Shipment", 'String'>
    readonly ewayBillNumber: FieldRef<"Shipment", 'String'>
    readonly gstInvoiceId: FieldRef<"Shipment", 'Int'>
    readonly complianceStatus: FieldRef<"Shipment", 'ComplianceStatus'>
    readonly source: FieldRef<"Shipment", 'String'>
    readonly podStatus: FieldRef<"Shipment", 'String'>
    readonly podUrl: FieldRef<"Shipment", 'String'>
    readonly podNotes: FieldRef<"Shipment", 'String'>
    readonly createdAt: FieldRef<"Shipment", 'DateTime'>
    readonly updatedAt: FieldRef<"Shipment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Shipment findUnique
   */
  export type ShipmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * Filter, which Shipment to fetch.
     */
    where: ShipmentWhereUniqueInput
  }

  /**
   * Shipment findUniqueOrThrow
   */
  export type ShipmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * Filter, which Shipment to fetch.
     */
    where: ShipmentWhereUniqueInput
  }

  /**
   * Shipment findFirst
   */
  export type ShipmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * Filter, which Shipment to fetch.
     */
    where?: ShipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shipments to fetch.
     */
    orderBy?: ShipmentOrderByWithRelationInput | ShipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shipments.
     */
    cursor?: ShipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shipments.
     */
    distinct?: ShipmentScalarFieldEnum | ShipmentScalarFieldEnum[]
  }

  /**
   * Shipment findFirstOrThrow
   */
  export type ShipmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * Filter, which Shipment to fetch.
     */
    where?: ShipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shipments to fetch.
     */
    orderBy?: ShipmentOrderByWithRelationInput | ShipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shipments.
     */
    cursor?: ShipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shipments.
     */
    distinct?: ShipmentScalarFieldEnum | ShipmentScalarFieldEnum[]
  }

  /**
   * Shipment findMany
   */
  export type ShipmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * Filter, which Shipments to fetch.
     */
    where?: ShipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shipments to fetch.
     */
    orderBy?: ShipmentOrderByWithRelationInput | ShipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shipments.
     */
    cursor?: ShipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shipments.
     */
    skip?: number
    distinct?: ShipmentScalarFieldEnum | ShipmentScalarFieldEnum[]
  }

  /**
   * Shipment create
   */
  export type ShipmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Shipment.
     */
    data: XOR<ShipmentCreateInput, ShipmentUncheckedCreateInput>
  }

  /**
   * Shipment createMany
   */
  export type ShipmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shipments.
     */
    data: ShipmentCreateManyInput | ShipmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shipment createManyAndReturn
   */
  export type ShipmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Shipments.
     */
    data: ShipmentCreateManyInput | ShipmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Shipment update
   */
  export type ShipmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Shipment.
     */
    data: XOR<ShipmentUpdateInput, ShipmentUncheckedUpdateInput>
    /**
     * Choose, which Shipment to update.
     */
    where: ShipmentWhereUniqueInput
  }

  /**
   * Shipment updateMany
   */
  export type ShipmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shipments.
     */
    data: XOR<ShipmentUpdateManyMutationInput, ShipmentUncheckedUpdateManyInput>
    /**
     * Filter which Shipments to update
     */
    where?: ShipmentWhereInput
  }

  /**
   * Shipment upsert
   */
  export type ShipmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Shipment to update in case it exists.
     */
    where: ShipmentWhereUniqueInput
    /**
     * In case the Shipment found by the `where` argument doesn't exist, create a new Shipment with this data.
     */
    create: XOR<ShipmentCreateInput, ShipmentUncheckedCreateInput>
    /**
     * In case the Shipment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShipmentUpdateInput, ShipmentUncheckedUpdateInput>
  }

  /**
   * Shipment delete
   */
  export type ShipmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * Filter which Shipment to delete.
     */
    where: ShipmentWhereUniqueInput
  }

  /**
   * Shipment deleteMany
   */
  export type ShipmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shipments to delete
     */
    where?: ShipmentWhereInput
  }

  /**
   * Shipment.company
   */
  export type Shipment$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * Shipment.quoteRequest
   */
  export type Shipment$quoteRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteRequest
     */
    select?: QuoteRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteRequestInclude<ExtArgs> | null
    where?: QuoteRequestWhereInput
  }

  /**
   * Shipment.transporterQuote
   */
  export type Shipment$transporterQuoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteResponse
     */
    select?: QuoteResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteResponseInclude<ExtArgs> | null
    where?: QuoteResponseWhereInput
  }

  /**
   * Shipment.rateCard
   */
  export type Shipment$rateCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateCard
     */
    select?: RateCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RateCardInclude<ExtArgs> | null
    where?: RateCardWhereInput
  }

  /**
   * Shipment.vendor
   */
  export type Shipment$vendorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    where?: VendorWhereInput
  }

  /**
   * Shipment.assignedTo
   */
  export type Shipment$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Shipment.statusHistory
   */
  export type Shipment$statusHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusHistory
     */
    select?: StatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusHistoryInclude<ExtArgs> | null
    where?: StatusHistoryWhereInput
    orderBy?: StatusHistoryOrderByWithRelationInput | StatusHistoryOrderByWithRelationInput[]
    cursor?: StatusHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StatusHistoryScalarFieldEnum | StatusHistoryScalarFieldEnum[]
  }

  /**
   * Shipment.complianceDocs
   */
  export type Shipment$complianceDocsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceDocument
     */
    select?: ComplianceDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceDocumentInclude<ExtArgs> | null
    where?: ComplianceDocumentWhereInput
    orderBy?: ComplianceDocumentOrderByWithRelationInput | ComplianceDocumentOrderByWithRelationInput[]
    cursor?: ComplianceDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplianceDocumentScalarFieldEnum | ComplianceDocumentScalarFieldEnum[]
  }

  /**
   * Shipment.payments
   */
  export type Shipment$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Shipment.invoice
   */
  export type Shipment$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * Shipment.consentLogs
   */
  export type Shipment$consentLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentLog
     */
    select?: ConsentLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentLogInclude<ExtArgs> | null
    where?: ConsentLogWhereInput
    orderBy?: ConsentLogOrderByWithRelationInput | ConsentLogOrderByWithRelationInput[]
    cursor?: ConsentLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConsentLogScalarFieldEnum | ConsentLogScalarFieldEnum[]
  }

  /**
   * Shipment.transporterInvoices
   */
  export type Shipment$transporterInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransporterInvoice
     */
    select?: TransporterInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransporterInvoiceInclude<ExtArgs> | null
    where?: TransporterInvoiceWhereInput
    orderBy?: TransporterInvoiceOrderByWithRelationInput | TransporterInvoiceOrderByWithRelationInput[]
    cursor?: TransporterInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransporterInvoiceScalarFieldEnum | TransporterInvoiceScalarFieldEnum[]
  }

  /**
   * Shipment without action
   */
  export type ShipmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
  }


  /**
   * Model StatusHistory
   */

  export type AggregateStatusHistory = {
    _count: StatusHistoryCountAggregateOutputType | null
    _avg: StatusHistoryAvgAggregateOutputType | null
    _sum: StatusHistorySumAggregateOutputType | null
    _min: StatusHistoryMinAggregateOutputType | null
    _max: StatusHistoryMaxAggregateOutputType | null
  }

  export type StatusHistoryAvgAggregateOutputType = {
    id: number | null
    shipmentId: number | null
    latitude: number | null
    longitude: number | null
    updatedBy: number | null
  }

  export type StatusHistorySumAggregateOutputType = {
    id: number | null
    shipmentId: number | null
    latitude: number | null
    longitude: number | null
    updatedBy: number | null
  }

  export type StatusHistoryMinAggregateOutputType = {
    id: number | null
    shipmentId: number | null
    status: $Enums.ShipmentStatus | null
    notes: string | null
    latitude: number | null
    longitude: number | null
    location: string | null
    updatedBy: number | null
    timestamp: Date | null
  }

  export type StatusHistoryMaxAggregateOutputType = {
    id: number | null
    shipmentId: number | null
    status: $Enums.ShipmentStatus | null
    notes: string | null
    latitude: number | null
    longitude: number | null
    location: string | null
    updatedBy: number | null
    timestamp: Date | null
  }

  export type StatusHistoryCountAggregateOutputType = {
    id: number
    shipmentId: number
    status: number
    notes: number
    latitude: number
    longitude: number
    location: number
    updatedBy: number
    timestamp: number
    _all: number
  }


  export type StatusHistoryAvgAggregateInputType = {
    id?: true
    shipmentId?: true
    latitude?: true
    longitude?: true
    updatedBy?: true
  }

  export type StatusHistorySumAggregateInputType = {
    id?: true
    shipmentId?: true
    latitude?: true
    longitude?: true
    updatedBy?: true
  }

  export type StatusHistoryMinAggregateInputType = {
    id?: true
    shipmentId?: true
    status?: true
    notes?: true
    latitude?: true
    longitude?: true
    location?: true
    updatedBy?: true
    timestamp?: true
  }

  export type StatusHistoryMaxAggregateInputType = {
    id?: true
    shipmentId?: true
    status?: true
    notes?: true
    latitude?: true
    longitude?: true
    location?: true
    updatedBy?: true
    timestamp?: true
  }

  export type StatusHistoryCountAggregateInputType = {
    id?: true
    shipmentId?: true
    status?: true
    notes?: true
    latitude?: true
    longitude?: true
    location?: true
    updatedBy?: true
    timestamp?: true
    _all?: true
  }

  export type StatusHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StatusHistory to aggregate.
     */
    where?: StatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusHistories to fetch.
     */
    orderBy?: StatusHistoryOrderByWithRelationInput | StatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StatusHistories
    **/
    _count?: true | StatusHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StatusHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StatusHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StatusHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StatusHistoryMaxAggregateInputType
  }

  export type GetStatusHistoryAggregateType<T extends StatusHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateStatusHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStatusHistory[P]>
      : GetScalarType<T[P], AggregateStatusHistory[P]>
  }




  export type StatusHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StatusHistoryWhereInput
    orderBy?: StatusHistoryOrderByWithAggregationInput | StatusHistoryOrderByWithAggregationInput[]
    by: StatusHistoryScalarFieldEnum[] | StatusHistoryScalarFieldEnum
    having?: StatusHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StatusHistoryCountAggregateInputType | true
    _avg?: StatusHistoryAvgAggregateInputType
    _sum?: StatusHistorySumAggregateInputType
    _min?: StatusHistoryMinAggregateInputType
    _max?: StatusHistoryMaxAggregateInputType
  }

  export type StatusHistoryGroupByOutputType = {
    id: number
    shipmentId: number
    status: $Enums.ShipmentStatus
    notes: string | null
    latitude: number | null
    longitude: number | null
    location: string | null
    updatedBy: number | null
    timestamp: Date
    _count: StatusHistoryCountAggregateOutputType | null
    _avg: StatusHistoryAvgAggregateOutputType | null
    _sum: StatusHistorySumAggregateOutputType | null
    _min: StatusHistoryMinAggregateOutputType | null
    _max: StatusHistoryMaxAggregateOutputType | null
  }

  type GetStatusHistoryGroupByPayload<T extends StatusHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StatusHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StatusHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StatusHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], StatusHistoryGroupByOutputType[P]>
        }
      >
    >


  export type StatusHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shipmentId?: boolean
    status?: boolean
    notes?: boolean
    latitude?: boolean
    longitude?: boolean
    location?: boolean
    updatedBy?: boolean
    timestamp?: boolean
    shipment?: boolean | ShipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["statusHistory"]>

  export type StatusHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shipmentId?: boolean
    status?: boolean
    notes?: boolean
    latitude?: boolean
    longitude?: boolean
    location?: boolean
    updatedBy?: boolean
    timestamp?: boolean
    shipment?: boolean | ShipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["statusHistory"]>

  export type StatusHistorySelectScalar = {
    id?: boolean
    shipmentId?: boolean
    status?: boolean
    notes?: boolean
    latitude?: boolean
    longitude?: boolean
    location?: boolean
    updatedBy?: boolean
    timestamp?: boolean
  }

  export type StatusHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shipment?: boolean | ShipmentDefaultArgs<ExtArgs>
  }
  export type StatusHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shipment?: boolean | ShipmentDefaultArgs<ExtArgs>
  }

  export type $StatusHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StatusHistory"
    objects: {
      shipment: Prisma.$ShipmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      shipmentId: number
      status: $Enums.ShipmentStatus
      notes: string | null
      latitude: number | null
      longitude: number | null
      location: string | null
      updatedBy: number | null
      timestamp: Date
    }, ExtArgs["result"]["statusHistory"]>
    composites: {}
  }

  type StatusHistoryGetPayload<S extends boolean | null | undefined | StatusHistoryDefaultArgs> = $Result.GetResult<Prisma.$StatusHistoryPayload, S>

  type StatusHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StatusHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StatusHistoryCountAggregateInputType | true
    }

  export interface StatusHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StatusHistory'], meta: { name: 'StatusHistory' } }
    /**
     * Find zero or one StatusHistory that matches the filter.
     * @param {StatusHistoryFindUniqueArgs} args - Arguments to find a StatusHistory
     * @example
     * // Get one StatusHistory
     * const statusHistory = await prisma.statusHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StatusHistoryFindUniqueArgs>(args: SelectSubset<T, StatusHistoryFindUniqueArgs<ExtArgs>>): Prisma__StatusHistoryClient<$Result.GetResult<Prisma.$StatusHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StatusHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StatusHistoryFindUniqueOrThrowArgs} args - Arguments to find a StatusHistory
     * @example
     * // Get one StatusHistory
     * const statusHistory = await prisma.statusHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StatusHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, StatusHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StatusHistoryClient<$Result.GetResult<Prisma.$StatusHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StatusHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusHistoryFindFirstArgs} args - Arguments to find a StatusHistory
     * @example
     * // Get one StatusHistory
     * const statusHistory = await prisma.statusHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StatusHistoryFindFirstArgs>(args?: SelectSubset<T, StatusHistoryFindFirstArgs<ExtArgs>>): Prisma__StatusHistoryClient<$Result.GetResult<Prisma.$StatusHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StatusHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusHistoryFindFirstOrThrowArgs} args - Arguments to find a StatusHistory
     * @example
     * // Get one StatusHistory
     * const statusHistory = await prisma.statusHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StatusHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, StatusHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__StatusHistoryClient<$Result.GetResult<Prisma.$StatusHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StatusHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StatusHistories
     * const statusHistories = await prisma.statusHistory.findMany()
     * 
     * // Get first 10 StatusHistories
     * const statusHistories = await prisma.statusHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const statusHistoryWithIdOnly = await prisma.statusHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StatusHistoryFindManyArgs>(args?: SelectSubset<T, StatusHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatusHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StatusHistory.
     * @param {StatusHistoryCreateArgs} args - Arguments to create a StatusHistory.
     * @example
     * // Create one StatusHistory
     * const StatusHistory = await prisma.statusHistory.create({
     *   data: {
     *     // ... data to create a StatusHistory
     *   }
     * })
     * 
     */
    create<T extends StatusHistoryCreateArgs>(args: SelectSubset<T, StatusHistoryCreateArgs<ExtArgs>>): Prisma__StatusHistoryClient<$Result.GetResult<Prisma.$StatusHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StatusHistories.
     * @param {StatusHistoryCreateManyArgs} args - Arguments to create many StatusHistories.
     * @example
     * // Create many StatusHistories
     * const statusHistory = await prisma.statusHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StatusHistoryCreateManyArgs>(args?: SelectSubset<T, StatusHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StatusHistories and returns the data saved in the database.
     * @param {StatusHistoryCreateManyAndReturnArgs} args - Arguments to create many StatusHistories.
     * @example
     * // Create many StatusHistories
     * const statusHistory = await prisma.statusHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StatusHistories and only return the `id`
     * const statusHistoryWithIdOnly = await prisma.statusHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StatusHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, StatusHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatusHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StatusHistory.
     * @param {StatusHistoryDeleteArgs} args - Arguments to delete one StatusHistory.
     * @example
     * // Delete one StatusHistory
     * const StatusHistory = await prisma.statusHistory.delete({
     *   where: {
     *     // ... filter to delete one StatusHistory
     *   }
     * })
     * 
     */
    delete<T extends StatusHistoryDeleteArgs>(args: SelectSubset<T, StatusHistoryDeleteArgs<ExtArgs>>): Prisma__StatusHistoryClient<$Result.GetResult<Prisma.$StatusHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StatusHistory.
     * @param {StatusHistoryUpdateArgs} args - Arguments to update one StatusHistory.
     * @example
     * // Update one StatusHistory
     * const statusHistory = await prisma.statusHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StatusHistoryUpdateArgs>(args: SelectSubset<T, StatusHistoryUpdateArgs<ExtArgs>>): Prisma__StatusHistoryClient<$Result.GetResult<Prisma.$StatusHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StatusHistories.
     * @param {StatusHistoryDeleteManyArgs} args - Arguments to filter StatusHistories to delete.
     * @example
     * // Delete a few StatusHistories
     * const { count } = await prisma.statusHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StatusHistoryDeleteManyArgs>(args?: SelectSubset<T, StatusHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StatusHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StatusHistories
     * const statusHistory = await prisma.statusHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StatusHistoryUpdateManyArgs>(args: SelectSubset<T, StatusHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StatusHistory.
     * @param {StatusHistoryUpsertArgs} args - Arguments to update or create a StatusHistory.
     * @example
     * // Update or create a StatusHistory
     * const statusHistory = await prisma.statusHistory.upsert({
     *   create: {
     *     // ... data to create a StatusHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StatusHistory we want to update
     *   }
     * })
     */
    upsert<T extends StatusHistoryUpsertArgs>(args: SelectSubset<T, StatusHistoryUpsertArgs<ExtArgs>>): Prisma__StatusHistoryClient<$Result.GetResult<Prisma.$StatusHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StatusHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusHistoryCountArgs} args - Arguments to filter StatusHistories to count.
     * @example
     * // Count the number of StatusHistories
     * const count = await prisma.statusHistory.count({
     *   where: {
     *     // ... the filter for the StatusHistories we want to count
     *   }
     * })
    **/
    count<T extends StatusHistoryCountArgs>(
      args?: Subset<T, StatusHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StatusHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StatusHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StatusHistoryAggregateArgs>(args: Subset<T, StatusHistoryAggregateArgs>): Prisma.PrismaPromise<GetStatusHistoryAggregateType<T>>

    /**
     * Group by StatusHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StatusHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StatusHistoryGroupByArgs['orderBy'] }
        : { orderBy?: StatusHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StatusHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatusHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StatusHistory model
   */
  readonly fields: StatusHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StatusHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StatusHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    shipment<T extends ShipmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShipmentDefaultArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StatusHistory model
   */ 
  interface StatusHistoryFieldRefs {
    readonly id: FieldRef<"StatusHistory", 'Int'>
    readonly shipmentId: FieldRef<"StatusHistory", 'Int'>
    readonly status: FieldRef<"StatusHistory", 'ShipmentStatus'>
    readonly notes: FieldRef<"StatusHistory", 'String'>
    readonly latitude: FieldRef<"StatusHistory", 'Float'>
    readonly longitude: FieldRef<"StatusHistory", 'Float'>
    readonly location: FieldRef<"StatusHistory", 'String'>
    readonly updatedBy: FieldRef<"StatusHistory", 'Int'>
    readonly timestamp: FieldRef<"StatusHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StatusHistory findUnique
   */
  export type StatusHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusHistory
     */
    select?: StatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which StatusHistory to fetch.
     */
    where: StatusHistoryWhereUniqueInput
  }

  /**
   * StatusHistory findUniqueOrThrow
   */
  export type StatusHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusHistory
     */
    select?: StatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which StatusHistory to fetch.
     */
    where: StatusHistoryWhereUniqueInput
  }

  /**
   * StatusHistory findFirst
   */
  export type StatusHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusHistory
     */
    select?: StatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which StatusHistory to fetch.
     */
    where?: StatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusHistories to fetch.
     */
    orderBy?: StatusHistoryOrderByWithRelationInput | StatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StatusHistories.
     */
    cursor?: StatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StatusHistories.
     */
    distinct?: StatusHistoryScalarFieldEnum | StatusHistoryScalarFieldEnum[]
  }

  /**
   * StatusHistory findFirstOrThrow
   */
  export type StatusHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusHistory
     */
    select?: StatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which StatusHistory to fetch.
     */
    where?: StatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusHistories to fetch.
     */
    orderBy?: StatusHistoryOrderByWithRelationInput | StatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StatusHistories.
     */
    cursor?: StatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StatusHistories.
     */
    distinct?: StatusHistoryScalarFieldEnum | StatusHistoryScalarFieldEnum[]
  }

  /**
   * StatusHistory findMany
   */
  export type StatusHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusHistory
     */
    select?: StatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which StatusHistories to fetch.
     */
    where?: StatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusHistories to fetch.
     */
    orderBy?: StatusHistoryOrderByWithRelationInput | StatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StatusHistories.
     */
    cursor?: StatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusHistories.
     */
    skip?: number
    distinct?: StatusHistoryScalarFieldEnum | StatusHistoryScalarFieldEnum[]
  }

  /**
   * StatusHistory create
   */
  export type StatusHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusHistory
     */
    select?: StatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a StatusHistory.
     */
    data: XOR<StatusHistoryCreateInput, StatusHistoryUncheckedCreateInput>
  }

  /**
   * StatusHistory createMany
   */
  export type StatusHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StatusHistories.
     */
    data: StatusHistoryCreateManyInput | StatusHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StatusHistory createManyAndReturn
   */
  export type StatusHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusHistory
     */
    select?: StatusHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StatusHistories.
     */
    data: StatusHistoryCreateManyInput | StatusHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StatusHistory update
   */
  export type StatusHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusHistory
     */
    select?: StatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a StatusHistory.
     */
    data: XOR<StatusHistoryUpdateInput, StatusHistoryUncheckedUpdateInput>
    /**
     * Choose, which StatusHistory to update.
     */
    where: StatusHistoryWhereUniqueInput
  }

  /**
   * StatusHistory updateMany
   */
  export type StatusHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StatusHistories.
     */
    data: XOR<StatusHistoryUpdateManyMutationInput, StatusHistoryUncheckedUpdateManyInput>
    /**
     * Filter which StatusHistories to update
     */
    where?: StatusHistoryWhereInput
  }

  /**
   * StatusHistory upsert
   */
  export type StatusHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusHistory
     */
    select?: StatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the StatusHistory to update in case it exists.
     */
    where: StatusHistoryWhereUniqueInput
    /**
     * In case the StatusHistory found by the `where` argument doesn't exist, create a new StatusHistory with this data.
     */
    create: XOR<StatusHistoryCreateInput, StatusHistoryUncheckedCreateInput>
    /**
     * In case the StatusHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StatusHistoryUpdateInput, StatusHistoryUncheckedUpdateInput>
  }

  /**
   * StatusHistory delete
   */
  export type StatusHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusHistory
     */
    select?: StatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusHistoryInclude<ExtArgs> | null
    /**
     * Filter which StatusHistory to delete.
     */
    where: StatusHistoryWhereUniqueInput
  }

  /**
   * StatusHistory deleteMany
   */
  export type StatusHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StatusHistories to delete
     */
    where?: StatusHistoryWhereInput
  }

  /**
   * StatusHistory without action
   */
  export type StatusHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusHistory
     */
    select?: StatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusHistoryInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    id: number | null
    shipmentId: number | null
    subtotal: number | null
    taxTotal: number | null
    grandTotal: number | null
    companyId: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    id: number | null
    shipmentId: number | null
    subtotal: number | null
    taxTotal: number | null
    grandTotal: number | null
    companyId: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: number | null
    shipmentId: number | null
    invoiceNumber: string | null
    status: $Enums.InvoiceStatus | null
    issuedAt: Date | null
    dueDate: Date | null
    subtotal: number | null
    taxTotal: number | null
    grandTotal: number | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: number | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: number | null
    shipmentId: number | null
    invoiceNumber: string | null
    status: $Enums.InvoiceStatus | null
    issuedAt: Date | null
    dueDate: Date | null
    subtotal: number | null
    taxTotal: number | null
    grandTotal: number | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: number | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    shipmentId: number
    invoiceNumber: number
    status: number
    issuedAt: number
    dueDate: number
    subtotal: number
    taxTotal: number
    grandTotal: number
    lineItems: number
    metadata: number
    createdAt: number
    updatedAt: number
    companyId: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    id?: true
    shipmentId?: true
    subtotal?: true
    taxTotal?: true
    grandTotal?: true
    companyId?: true
  }

  export type InvoiceSumAggregateInputType = {
    id?: true
    shipmentId?: true
    subtotal?: true
    taxTotal?: true
    grandTotal?: true
    companyId?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    shipmentId?: true
    invoiceNumber?: true
    status?: true
    issuedAt?: true
    dueDate?: true
    subtotal?: true
    taxTotal?: true
    grandTotal?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    shipmentId?: true
    invoiceNumber?: true
    status?: true
    issuedAt?: true
    dueDate?: true
    subtotal?: true
    taxTotal?: true
    grandTotal?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    shipmentId?: true
    invoiceNumber?: true
    status?: true
    issuedAt?: true
    dueDate?: true
    subtotal?: true
    taxTotal?: true
    grandTotal?: true
    lineItems?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: number
    shipmentId: number
    invoiceNumber: string
    status: $Enums.InvoiceStatus
    issuedAt: Date | null
    dueDate: Date | null
    subtotal: number
    taxTotal: number
    grandTotal: number
    lineItems: JsonValue
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    companyId: number | null
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shipmentId?: boolean
    invoiceNumber?: boolean
    status?: boolean
    issuedAt?: boolean
    dueDate?: boolean
    subtotal?: boolean
    taxTotal?: boolean
    grandTotal?: boolean
    lineItems?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    shipment?: boolean | ShipmentDefaultArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    Company?: boolean | Invoice$CompanyArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shipmentId?: boolean
    invoiceNumber?: boolean
    status?: boolean
    issuedAt?: boolean
    dueDate?: boolean
    subtotal?: boolean
    taxTotal?: boolean
    grandTotal?: boolean
    lineItems?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    shipment?: boolean | ShipmentDefaultArgs<ExtArgs>
    Company?: boolean | Invoice$CompanyArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    shipmentId?: boolean
    invoiceNumber?: boolean
    status?: boolean
    issuedAt?: boolean
    dueDate?: boolean
    subtotal?: boolean
    taxTotal?: boolean
    grandTotal?: boolean
    lineItems?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
  }

  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shipment?: boolean | ShipmentDefaultArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    Company?: boolean | Invoice$CompanyArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shipment?: boolean | ShipmentDefaultArgs<ExtArgs>
    Company?: boolean | Invoice$CompanyArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      shipment: Prisma.$ShipmentPayload<ExtArgs>
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      Company: Prisma.$CompanyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      shipmentId: number
      invoiceNumber: string
      status: $Enums.InvoiceStatus
      issuedAt: Date | null
      dueDate: Date | null
      subtotal: number
      taxTotal: number
      grandTotal: number
      lineItems: Prisma.JsonValue
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      companyId: number | null
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    shipment<T extends ShipmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShipmentDefaultArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    payments<T extends Invoice$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    Company<T extends Invoice$CompanyArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$CompanyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */ 
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'Int'>
    readonly shipmentId: FieldRef<"Invoice", 'Int'>
    readonly invoiceNumber: FieldRef<"Invoice", 'String'>
    readonly status: FieldRef<"Invoice", 'InvoiceStatus'>
    readonly issuedAt: FieldRef<"Invoice", 'DateTime'>
    readonly dueDate: FieldRef<"Invoice", 'DateTime'>
    readonly subtotal: FieldRef<"Invoice", 'Float'>
    readonly taxTotal: FieldRef<"Invoice", 'Float'>
    readonly grandTotal: FieldRef<"Invoice", 'Float'>
    readonly lineItems: FieldRef<"Invoice", 'Json'>
    readonly metadata: FieldRef<"Invoice", 'Json'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
    readonly companyId: FieldRef<"Invoice", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice.payments
   */
  export type Invoice$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Invoice.Company
   */
  export type Invoice$CompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    id: number | null
    shipmentId: number | null
    invoiceId: number | null
    amount: number | null
    tdsAmount: number | null
    tcsAmount: number | null
    rcmLiability: number | null
  }

  export type PaymentSumAggregateOutputType = {
    id: number | null
    shipmentId: number | null
    invoiceId: number | null
    amount: number | null
    tdsAmount: number | null
    tcsAmount: number | null
    rcmLiability: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: number | null
    shipmentId: number | null
    invoiceId: number | null
    amount: number | null
    currency: string | null
    status: $Enums.PaymentStatus | null
    gateway: string | null
    transactionRef: string | null
    authorizedAt: Date | null
    capturedAt: Date | null
    failureReason: string | null
    tdsAmount: number | null
    tcsAmount: number | null
    rcmLiability: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: number | null
    shipmentId: number | null
    invoiceId: number | null
    amount: number | null
    currency: string | null
    status: $Enums.PaymentStatus | null
    gateway: string | null
    transactionRef: string | null
    authorizedAt: Date | null
    capturedAt: Date | null
    failureReason: string | null
    tdsAmount: number | null
    tcsAmount: number | null
    rcmLiability: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    shipmentId: number
    invoiceId: number
    amount: number
    currency: number
    status: number
    gateway: number
    transactionRef: number
    authorizedAt: number
    capturedAt: number
    failureReason: number
    metadata: number
    tdsAmount: number
    tcsAmount: number
    rcmLiability: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    id?: true
    shipmentId?: true
    invoiceId?: true
    amount?: true
    tdsAmount?: true
    tcsAmount?: true
    rcmLiability?: true
  }

  export type PaymentSumAggregateInputType = {
    id?: true
    shipmentId?: true
    invoiceId?: true
    amount?: true
    tdsAmount?: true
    tcsAmount?: true
    rcmLiability?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    shipmentId?: true
    invoiceId?: true
    amount?: true
    currency?: true
    status?: true
    gateway?: true
    transactionRef?: true
    authorizedAt?: true
    capturedAt?: true
    failureReason?: true
    tdsAmount?: true
    tcsAmount?: true
    rcmLiability?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    shipmentId?: true
    invoiceId?: true
    amount?: true
    currency?: true
    status?: true
    gateway?: true
    transactionRef?: true
    authorizedAt?: true
    capturedAt?: true
    failureReason?: true
    tdsAmount?: true
    tcsAmount?: true
    rcmLiability?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    shipmentId?: true
    invoiceId?: true
    amount?: true
    currency?: true
    status?: true
    gateway?: true
    transactionRef?: true
    authorizedAt?: true
    capturedAt?: true
    failureReason?: true
    metadata?: true
    tdsAmount?: true
    tcsAmount?: true
    rcmLiability?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: number
    shipmentId: number
    invoiceId: number
    amount: number
    currency: string
    status: $Enums.PaymentStatus
    gateway: string
    transactionRef: string | null
    authorizedAt: Date | null
    capturedAt: Date | null
    failureReason: string | null
    metadata: JsonValue | null
    tdsAmount: number | null
    tcsAmount: number | null
    rcmLiability: number | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shipmentId?: boolean
    invoiceId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    gateway?: boolean
    transactionRef?: boolean
    authorizedAt?: boolean
    capturedAt?: boolean
    failureReason?: boolean
    metadata?: boolean
    tdsAmount?: boolean
    tcsAmount?: boolean
    rcmLiability?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shipment?: boolean | ShipmentDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    events?: boolean | Payment$eventsArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shipmentId?: boolean
    invoiceId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    gateway?: boolean
    transactionRef?: boolean
    authorizedAt?: boolean
    capturedAt?: boolean
    failureReason?: boolean
    metadata?: boolean
    tdsAmount?: boolean
    tcsAmount?: boolean
    rcmLiability?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shipment?: boolean | ShipmentDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    shipmentId?: boolean
    invoiceId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    gateway?: boolean
    transactionRef?: boolean
    authorizedAt?: boolean
    capturedAt?: boolean
    failureReason?: boolean
    metadata?: boolean
    tdsAmount?: boolean
    tcsAmount?: boolean
    rcmLiability?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shipment?: boolean | ShipmentDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    events?: boolean | Payment$eventsArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shipment?: boolean | ShipmentDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      shipment: Prisma.$ShipmentPayload<ExtArgs>
      invoice: Prisma.$InvoicePayload<ExtArgs>
      events: Prisma.$PaymentEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      shipmentId: number
      invoiceId: number
      amount: number
      currency: string
      status: $Enums.PaymentStatus
      gateway: string
      transactionRef: string | null
      authorizedAt: Date | null
      capturedAt: Date | null
      failureReason: string | null
      metadata: Prisma.JsonValue | null
      tdsAmount: number | null
      tcsAmount: number | null
      rcmLiability: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    shipment<T extends ShipmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShipmentDefaultArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    events<T extends Payment$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Payment$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentEventPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'Int'>
    readonly shipmentId: FieldRef<"Payment", 'Int'>
    readonly invoiceId: FieldRef<"Payment", 'Int'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly gateway: FieldRef<"Payment", 'String'>
    readonly transactionRef: FieldRef<"Payment", 'String'>
    readonly authorizedAt: FieldRef<"Payment", 'DateTime'>
    readonly capturedAt: FieldRef<"Payment", 'DateTime'>
    readonly failureReason: FieldRef<"Payment", 'String'>
    readonly metadata: FieldRef<"Payment", 'Json'>
    readonly tdsAmount: FieldRef<"Payment", 'Float'>
    readonly tcsAmount: FieldRef<"Payment", 'Float'>
    readonly rcmLiability: FieldRef<"Payment", 'Float'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment.events
   */
  export type Payment$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentEvent
     */
    select?: PaymentEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentEventInclude<ExtArgs> | null
    where?: PaymentEventWhereInput
    orderBy?: PaymentEventOrderByWithRelationInput | PaymentEventOrderByWithRelationInput[]
    cursor?: PaymentEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentEventScalarFieldEnum | PaymentEventScalarFieldEnum[]
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model PaymentEvent
   */

  export type AggregatePaymentEvent = {
    _count: PaymentEventCountAggregateOutputType | null
    _avg: PaymentEventAvgAggregateOutputType | null
    _sum: PaymentEventSumAggregateOutputType | null
    _min: PaymentEventMinAggregateOutputType | null
    _max: PaymentEventMaxAggregateOutputType | null
  }

  export type PaymentEventAvgAggregateOutputType = {
    id: number | null
    paymentId: number | null
  }

  export type PaymentEventSumAggregateOutputType = {
    id: number | null
    paymentId: number | null
  }

  export type PaymentEventMinAggregateOutputType = {
    id: number | null
    paymentId: number | null
    eventType: string | null
    recordedAt: Date | null
  }

  export type PaymentEventMaxAggregateOutputType = {
    id: number | null
    paymentId: number | null
    eventType: string | null
    recordedAt: Date | null
  }

  export type PaymentEventCountAggregateOutputType = {
    id: number
    paymentId: number
    eventType: number
    details: number
    recordedAt: number
    _all: number
  }


  export type PaymentEventAvgAggregateInputType = {
    id?: true
    paymentId?: true
  }

  export type PaymentEventSumAggregateInputType = {
    id?: true
    paymentId?: true
  }

  export type PaymentEventMinAggregateInputType = {
    id?: true
    paymentId?: true
    eventType?: true
    recordedAt?: true
  }

  export type PaymentEventMaxAggregateInputType = {
    id?: true
    paymentId?: true
    eventType?: true
    recordedAt?: true
  }

  export type PaymentEventCountAggregateInputType = {
    id?: true
    paymentId?: true
    eventType?: true
    details?: true
    recordedAt?: true
    _all?: true
  }

  export type PaymentEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentEvent to aggregate.
     */
    where?: PaymentEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentEvents to fetch.
     */
    orderBy?: PaymentEventOrderByWithRelationInput | PaymentEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentEvents
    **/
    _count?: true | PaymentEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentEventMaxAggregateInputType
  }

  export type GetPaymentEventAggregateType<T extends PaymentEventAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentEvent[P]>
      : GetScalarType<T[P], AggregatePaymentEvent[P]>
  }




  export type PaymentEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentEventWhereInput
    orderBy?: PaymentEventOrderByWithAggregationInput | PaymentEventOrderByWithAggregationInput[]
    by: PaymentEventScalarFieldEnum[] | PaymentEventScalarFieldEnum
    having?: PaymentEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentEventCountAggregateInputType | true
    _avg?: PaymentEventAvgAggregateInputType
    _sum?: PaymentEventSumAggregateInputType
    _min?: PaymentEventMinAggregateInputType
    _max?: PaymentEventMaxAggregateInputType
  }

  export type PaymentEventGroupByOutputType = {
    id: number
    paymentId: number
    eventType: string
    details: JsonValue | null
    recordedAt: Date
    _count: PaymentEventCountAggregateOutputType | null
    _avg: PaymentEventAvgAggregateOutputType | null
    _sum: PaymentEventSumAggregateOutputType | null
    _min: PaymentEventMinAggregateOutputType | null
    _max: PaymentEventMaxAggregateOutputType | null
  }

  type GetPaymentEventGroupByPayload<T extends PaymentEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentEventGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentEventGroupByOutputType[P]>
        }
      >
    >


  export type PaymentEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentId?: boolean
    eventType?: boolean
    details?: boolean
    recordedAt?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentEvent"]>

  export type PaymentEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentId?: boolean
    eventType?: boolean
    details?: boolean
    recordedAt?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentEvent"]>

  export type PaymentEventSelectScalar = {
    id?: boolean
    paymentId?: boolean
    eventType?: boolean
    details?: boolean
    recordedAt?: boolean
  }

  export type PaymentEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }
  export type PaymentEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }

  export type $PaymentEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentEvent"
    objects: {
      payment: Prisma.$PaymentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      paymentId: number
      eventType: string
      details: Prisma.JsonValue | null
      recordedAt: Date
    }, ExtArgs["result"]["paymentEvent"]>
    composites: {}
  }

  type PaymentEventGetPayload<S extends boolean | null | undefined | PaymentEventDefaultArgs> = $Result.GetResult<Prisma.$PaymentEventPayload, S>

  type PaymentEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentEventCountAggregateInputType | true
    }

  export interface PaymentEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentEvent'], meta: { name: 'PaymentEvent' } }
    /**
     * Find zero or one PaymentEvent that matches the filter.
     * @param {PaymentEventFindUniqueArgs} args - Arguments to find a PaymentEvent
     * @example
     * // Get one PaymentEvent
     * const paymentEvent = await prisma.paymentEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentEventFindUniqueArgs>(args: SelectSubset<T, PaymentEventFindUniqueArgs<ExtArgs>>): Prisma__PaymentEventClient<$Result.GetResult<Prisma.$PaymentEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PaymentEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentEventFindUniqueOrThrowArgs} args - Arguments to find a PaymentEvent
     * @example
     * // Get one PaymentEvent
     * const paymentEvent = await prisma.paymentEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentEventFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentEventClient<$Result.GetResult<Prisma.$PaymentEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PaymentEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentEventFindFirstArgs} args - Arguments to find a PaymentEvent
     * @example
     * // Get one PaymentEvent
     * const paymentEvent = await prisma.paymentEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentEventFindFirstArgs>(args?: SelectSubset<T, PaymentEventFindFirstArgs<ExtArgs>>): Prisma__PaymentEventClient<$Result.GetResult<Prisma.$PaymentEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PaymentEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentEventFindFirstOrThrowArgs} args - Arguments to find a PaymentEvent
     * @example
     * // Get one PaymentEvent
     * const paymentEvent = await prisma.paymentEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentEventFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentEventClient<$Result.GetResult<Prisma.$PaymentEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PaymentEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentEvents
     * const paymentEvents = await prisma.paymentEvent.findMany()
     * 
     * // Get first 10 PaymentEvents
     * const paymentEvents = await prisma.paymentEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentEventWithIdOnly = await prisma.paymentEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentEventFindManyArgs>(args?: SelectSubset<T, PaymentEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PaymentEvent.
     * @param {PaymentEventCreateArgs} args - Arguments to create a PaymentEvent.
     * @example
     * // Create one PaymentEvent
     * const PaymentEvent = await prisma.paymentEvent.create({
     *   data: {
     *     // ... data to create a PaymentEvent
     *   }
     * })
     * 
     */
    create<T extends PaymentEventCreateArgs>(args: SelectSubset<T, PaymentEventCreateArgs<ExtArgs>>): Prisma__PaymentEventClient<$Result.GetResult<Prisma.$PaymentEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PaymentEvents.
     * @param {PaymentEventCreateManyArgs} args - Arguments to create many PaymentEvents.
     * @example
     * // Create many PaymentEvents
     * const paymentEvent = await prisma.paymentEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentEventCreateManyArgs>(args?: SelectSubset<T, PaymentEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentEvents and returns the data saved in the database.
     * @param {PaymentEventCreateManyAndReturnArgs} args - Arguments to create many PaymentEvents.
     * @example
     * // Create many PaymentEvents
     * const paymentEvent = await prisma.paymentEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentEvents and only return the `id`
     * const paymentEventWithIdOnly = await prisma.paymentEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentEventCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PaymentEvent.
     * @param {PaymentEventDeleteArgs} args - Arguments to delete one PaymentEvent.
     * @example
     * // Delete one PaymentEvent
     * const PaymentEvent = await prisma.paymentEvent.delete({
     *   where: {
     *     // ... filter to delete one PaymentEvent
     *   }
     * })
     * 
     */
    delete<T extends PaymentEventDeleteArgs>(args: SelectSubset<T, PaymentEventDeleteArgs<ExtArgs>>): Prisma__PaymentEventClient<$Result.GetResult<Prisma.$PaymentEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PaymentEvent.
     * @param {PaymentEventUpdateArgs} args - Arguments to update one PaymentEvent.
     * @example
     * // Update one PaymentEvent
     * const paymentEvent = await prisma.paymentEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentEventUpdateArgs>(args: SelectSubset<T, PaymentEventUpdateArgs<ExtArgs>>): Prisma__PaymentEventClient<$Result.GetResult<Prisma.$PaymentEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PaymentEvents.
     * @param {PaymentEventDeleteManyArgs} args - Arguments to filter PaymentEvents to delete.
     * @example
     * // Delete a few PaymentEvents
     * const { count } = await prisma.paymentEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentEventDeleteManyArgs>(args?: SelectSubset<T, PaymentEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentEvents
     * const paymentEvent = await prisma.paymentEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentEventUpdateManyArgs>(args: SelectSubset<T, PaymentEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PaymentEvent.
     * @param {PaymentEventUpsertArgs} args - Arguments to update or create a PaymentEvent.
     * @example
     * // Update or create a PaymentEvent
     * const paymentEvent = await prisma.paymentEvent.upsert({
     *   create: {
     *     // ... data to create a PaymentEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentEvent we want to update
     *   }
     * })
     */
    upsert<T extends PaymentEventUpsertArgs>(args: SelectSubset<T, PaymentEventUpsertArgs<ExtArgs>>): Prisma__PaymentEventClient<$Result.GetResult<Prisma.$PaymentEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PaymentEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentEventCountArgs} args - Arguments to filter PaymentEvents to count.
     * @example
     * // Count the number of PaymentEvents
     * const count = await prisma.paymentEvent.count({
     *   where: {
     *     // ... the filter for the PaymentEvents we want to count
     *   }
     * })
    **/
    count<T extends PaymentEventCountArgs>(
      args?: Subset<T, PaymentEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentEventAggregateArgs>(args: Subset<T, PaymentEventAggregateArgs>): Prisma.PrismaPromise<GetPaymentEventAggregateType<T>>

    /**
     * Group by PaymentEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentEventGroupByArgs['orderBy'] }
        : { orderBy?: PaymentEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentEvent model
   */
  readonly fields: PaymentEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payment<T extends PaymentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentDefaultArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentEvent model
   */ 
  interface PaymentEventFieldRefs {
    readonly id: FieldRef<"PaymentEvent", 'Int'>
    readonly paymentId: FieldRef<"PaymentEvent", 'Int'>
    readonly eventType: FieldRef<"PaymentEvent", 'String'>
    readonly details: FieldRef<"PaymentEvent", 'Json'>
    readonly recordedAt: FieldRef<"PaymentEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentEvent findUnique
   */
  export type PaymentEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentEvent
     */
    select?: PaymentEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentEventInclude<ExtArgs> | null
    /**
     * Filter, which PaymentEvent to fetch.
     */
    where: PaymentEventWhereUniqueInput
  }

  /**
   * PaymentEvent findUniqueOrThrow
   */
  export type PaymentEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentEvent
     */
    select?: PaymentEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentEventInclude<ExtArgs> | null
    /**
     * Filter, which PaymentEvent to fetch.
     */
    where: PaymentEventWhereUniqueInput
  }

  /**
   * PaymentEvent findFirst
   */
  export type PaymentEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentEvent
     */
    select?: PaymentEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentEventInclude<ExtArgs> | null
    /**
     * Filter, which PaymentEvent to fetch.
     */
    where?: PaymentEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentEvents to fetch.
     */
    orderBy?: PaymentEventOrderByWithRelationInput | PaymentEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentEvents.
     */
    cursor?: PaymentEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentEvents.
     */
    distinct?: PaymentEventScalarFieldEnum | PaymentEventScalarFieldEnum[]
  }

  /**
   * PaymentEvent findFirstOrThrow
   */
  export type PaymentEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentEvent
     */
    select?: PaymentEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentEventInclude<ExtArgs> | null
    /**
     * Filter, which PaymentEvent to fetch.
     */
    where?: PaymentEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentEvents to fetch.
     */
    orderBy?: PaymentEventOrderByWithRelationInput | PaymentEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentEvents.
     */
    cursor?: PaymentEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentEvents.
     */
    distinct?: PaymentEventScalarFieldEnum | PaymentEventScalarFieldEnum[]
  }

  /**
   * PaymentEvent findMany
   */
  export type PaymentEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentEvent
     */
    select?: PaymentEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentEventInclude<ExtArgs> | null
    /**
     * Filter, which PaymentEvents to fetch.
     */
    where?: PaymentEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentEvents to fetch.
     */
    orderBy?: PaymentEventOrderByWithRelationInput | PaymentEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentEvents.
     */
    cursor?: PaymentEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentEvents.
     */
    skip?: number
    distinct?: PaymentEventScalarFieldEnum | PaymentEventScalarFieldEnum[]
  }

  /**
   * PaymentEvent create
   */
  export type PaymentEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentEvent
     */
    select?: PaymentEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentEventInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentEvent.
     */
    data: XOR<PaymentEventCreateInput, PaymentEventUncheckedCreateInput>
  }

  /**
   * PaymentEvent createMany
   */
  export type PaymentEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentEvents.
     */
    data: PaymentEventCreateManyInput | PaymentEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentEvent createManyAndReturn
   */
  export type PaymentEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentEvent
     */
    select?: PaymentEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PaymentEvents.
     */
    data: PaymentEventCreateManyInput | PaymentEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentEvent update
   */
  export type PaymentEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentEvent
     */
    select?: PaymentEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentEventInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentEvent.
     */
    data: XOR<PaymentEventUpdateInput, PaymentEventUncheckedUpdateInput>
    /**
     * Choose, which PaymentEvent to update.
     */
    where: PaymentEventWhereUniqueInput
  }

  /**
   * PaymentEvent updateMany
   */
  export type PaymentEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentEvents.
     */
    data: XOR<PaymentEventUpdateManyMutationInput, PaymentEventUncheckedUpdateManyInput>
    /**
     * Filter which PaymentEvents to update
     */
    where?: PaymentEventWhereInput
  }

  /**
   * PaymentEvent upsert
   */
  export type PaymentEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentEvent
     */
    select?: PaymentEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentEventInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentEvent to update in case it exists.
     */
    where: PaymentEventWhereUniqueInput
    /**
     * In case the PaymentEvent found by the `where` argument doesn't exist, create a new PaymentEvent with this data.
     */
    create: XOR<PaymentEventCreateInput, PaymentEventUncheckedCreateInput>
    /**
     * In case the PaymentEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentEventUpdateInput, PaymentEventUncheckedUpdateInput>
  }

  /**
   * PaymentEvent delete
   */
  export type PaymentEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentEvent
     */
    select?: PaymentEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentEventInclude<ExtArgs> | null
    /**
     * Filter which PaymentEvent to delete.
     */
    where: PaymentEventWhereUniqueInput
  }

  /**
   * PaymentEvent deleteMany
   */
  export type PaymentEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentEvents to delete
     */
    where?: PaymentEventWhereInput
  }

  /**
   * PaymentEvent without action
   */
  export type PaymentEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentEvent
     */
    select?: PaymentEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentEventInclude<ExtArgs> | null
  }


  /**
   * Model TransporterInvoice
   */

  export type AggregateTransporterInvoice = {
    _count: TransporterInvoiceCountAggregateOutputType | null
    _avg: TransporterInvoiceAvgAggregateOutputType | null
    _sum: TransporterInvoiceSumAggregateOutputType | null
    _min: TransporterInvoiceMinAggregateOutputType | null
    _max: TransporterInvoiceMaxAggregateOutputType | null
  }

  export type TransporterInvoiceAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
    shipmentId: number | null
    invoiceAmount: number | null
    approvedById: number | null
  }

  export type TransporterInvoiceSumAggregateOutputType = {
    id: number | null
    companyId: number | null
    shipmentId: number | null
    invoiceAmount: number | null
    approvedById: number | null
  }

  export type TransporterInvoiceMinAggregateOutputType = {
    id: number | null
    companyId: number | null
    shipmentId: number | null
    invoiceNumber: string | null
    invoiceDate: Date | null
    invoiceAmount: number | null
    invoiceUrl: string | null
    approvalStatus: string | null
    rejectionNotes: string | null
    postedToErpAt: Date | null
    approvedById: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransporterInvoiceMaxAggregateOutputType = {
    id: number | null
    companyId: number | null
    shipmentId: number | null
    invoiceNumber: string | null
    invoiceDate: Date | null
    invoiceAmount: number | null
    invoiceUrl: string | null
    approvalStatus: string | null
    rejectionNotes: string | null
    postedToErpAt: Date | null
    approvedById: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransporterInvoiceCountAggregateOutputType = {
    id: number
    companyId: number
    shipmentId: number
    invoiceNumber: number
    invoiceDate: number
    invoiceAmount: number
    invoiceUrl: number
    approvalStatus: number
    rejectionNotes: number
    postedToErpAt: number
    approvedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransporterInvoiceAvgAggregateInputType = {
    id?: true
    companyId?: true
    shipmentId?: true
    invoiceAmount?: true
    approvedById?: true
  }

  export type TransporterInvoiceSumAggregateInputType = {
    id?: true
    companyId?: true
    shipmentId?: true
    invoiceAmount?: true
    approvedById?: true
  }

  export type TransporterInvoiceMinAggregateInputType = {
    id?: true
    companyId?: true
    shipmentId?: true
    invoiceNumber?: true
    invoiceDate?: true
    invoiceAmount?: true
    invoiceUrl?: true
    approvalStatus?: true
    rejectionNotes?: true
    postedToErpAt?: true
    approvedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransporterInvoiceMaxAggregateInputType = {
    id?: true
    companyId?: true
    shipmentId?: true
    invoiceNumber?: true
    invoiceDate?: true
    invoiceAmount?: true
    invoiceUrl?: true
    approvalStatus?: true
    rejectionNotes?: true
    postedToErpAt?: true
    approvedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransporterInvoiceCountAggregateInputType = {
    id?: true
    companyId?: true
    shipmentId?: true
    invoiceNumber?: true
    invoiceDate?: true
    invoiceAmount?: true
    invoiceUrl?: true
    approvalStatus?: true
    rejectionNotes?: true
    postedToErpAt?: true
    approvedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransporterInvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransporterInvoice to aggregate.
     */
    where?: TransporterInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransporterInvoices to fetch.
     */
    orderBy?: TransporterInvoiceOrderByWithRelationInput | TransporterInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransporterInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransporterInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransporterInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransporterInvoices
    **/
    _count?: true | TransporterInvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransporterInvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransporterInvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransporterInvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransporterInvoiceMaxAggregateInputType
  }

  export type GetTransporterInvoiceAggregateType<T extends TransporterInvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateTransporterInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransporterInvoice[P]>
      : GetScalarType<T[P], AggregateTransporterInvoice[P]>
  }




  export type TransporterInvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransporterInvoiceWhereInput
    orderBy?: TransporterInvoiceOrderByWithAggregationInput | TransporterInvoiceOrderByWithAggregationInput[]
    by: TransporterInvoiceScalarFieldEnum[] | TransporterInvoiceScalarFieldEnum
    having?: TransporterInvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransporterInvoiceCountAggregateInputType | true
    _avg?: TransporterInvoiceAvgAggregateInputType
    _sum?: TransporterInvoiceSumAggregateInputType
    _min?: TransporterInvoiceMinAggregateInputType
    _max?: TransporterInvoiceMaxAggregateInputType
  }

  export type TransporterInvoiceGroupByOutputType = {
    id: number
    companyId: number
    shipmentId: number
    invoiceNumber: string
    invoiceDate: Date
    invoiceAmount: number
    invoiceUrl: string
    approvalStatus: string
    rejectionNotes: string | null
    postedToErpAt: Date | null
    approvedById: number | null
    createdAt: Date
    updatedAt: Date
    _count: TransporterInvoiceCountAggregateOutputType | null
    _avg: TransporterInvoiceAvgAggregateOutputType | null
    _sum: TransporterInvoiceSumAggregateOutputType | null
    _min: TransporterInvoiceMinAggregateOutputType | null
    _max: TransporterInvoiceMaxAggregateOutputType | null
  }

  type GetTransporterInvoiceGroupByPayload<T extends TransporterInvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransporterInvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransporterInvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransporterInvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], TransporterInvoiceGroupByOutputType[P]>
        }
      >
    >


  export type TransporterInvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    shipmentId?: boolean
    invoiceNumber?: boolean
    invoiceDate?: boolean
    invoiceAmount?: boolean
    invoiceUrl?: boolean
    approvalStatus?: boolean
    rejectionNotes?: boolean
    postedToErpAt?: boolean
    approvedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    shipment?: boolean | ShipmentDefaultArgs<ExtArgs>
    approvedBy?: boolean | TransporterInvoice$approvedByArgs<ExtArgs>
  }, ExtArgs["result"]["transporterInvoice"]>

  export type TransporterInvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    shipmentId?: boolean
    invoiceNumber?: boolean
    invoiceDate?: boolean
    invoiceAmount?: boolean
    invoiceUrl?: boolean
    approvalStatus?: boolean
    rejectionNotes?: boolean
    postedToErpAt?: boolean
    approvedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    shipment?: boolean | ShipmentDefaultArgs<ExtArgs>
    approvedBy?: boolean | TransporterInvoice$approvedByArgs<ExtArgs>
  }, ExtArgs["result"]["transporterInvoice"]>

  export type TransporterInvoiceSelectScalar = {
    id?: boolean
    companyId?: boolean
    shipmentId?: boolean
    invoiceNumber?: boolean
    invoiceDate?: boolean
    invoiceAmount?: boolean
    invoiceUrl?: boolean
    approvalStatus?: boolean
    rejectionNotes?: boolean
    postedToErpAt?: boolean
    approvedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransporterInvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    shipment?: boolean | ShipmentDefaultArgs<ExtArgs>
    approvedBy?: boolean | TransporterInvoice$approvedByArgs<ExtArgs>
  }
  export type TransporterInvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    shipment?: boolean | ShipmentDefaultArgs<ExtArgs>
    approvedBy?: boolean | TransporterInvoice$approvedByArgs<ExtArgs>
  }

  export type $TransporterInvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransporterInvoice"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      shipment: Prisma.$ShipmentPayload<ExtArgs>
      approvedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      companyId: number
      shipmentId: number
      invoiceNumber: string
      invoiceDate: Date
      invoiceAmount: number
      invoiceUrl: string
      approvalStatus: string
      rejectionNotes: string | null
      postedToErpAt: Date | null
      approvedById: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transporterInvoice"]>
    composites: {}
  }

  type TransporterInvoiceGetPayload<S extends boolean | null | undefined | TransporterInvoiceDefaultArgs> = $Result.GetResult<Prisma.$TransporterInvoicePayload, S>

  type TransporterInvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TransporterInvoiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransporterInvoiceCountAggregateInputType | true
    }

  export interface TransporterInvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransporterInvoice'], meta: { name: 'TransporterInvoice' } }
    /**
     * Find zero or one TransporterInvoice that matches the filter.
     * @param {TransporterInvoiceFindUniqueArgs} args - Arguments to find a TransporterInvoice
     * @example
     * // Get one TransporterInvoice
     * const transporterInvoice = await prisma.transporterInvoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransporterInvoiceFindUniqueArgs>(args: SelectSubset<T, TransporterInvoiceFindUniqueArgs<ExtArgs>>): Prisma__TransporterInvoiceClient<$Result.GetResult<Prisma.$TransporterInvoicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TransporterInvoice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TransporterInvoiceFindUniqueOrThrowArgs} args - Arguments to find a TransporterInvoice
     * @example
     * // Get one TransporterInvoice
     * const transporterInvoice = await prisma.transporterInvoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransporterInvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, TransporterInvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransporterInvoiceClient<$Result.GetResult<Prisma.$TransporterInvoicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TransporterInvoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransporterInvoiceFindFirstArgs} args - Arguments to find a TransporterInvoice
     * @example
     * // Get one TransporterInvoice
     * const transporterInvoice = await prisma.transporterInvoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransporterInvoiceFindFirstArgs>(args?: SelectSubset<T, TransporterInvoiceFindFirstArgs<ExtArgs>>): Prisma__TransporterInvoiceClient<$Result.GetResult<Prisma.$TransporterInvoicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TransporterInvoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransporterInvoiceFindFirstOrThrowArgs} args - Arguments to find a TransporterInvoice
     * @example
     * // Get one TransporterInvoice
     * const transporterInvoice = await prisma.transporterInvoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransporterInvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, TransporterInvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransporterInvoiceClient<$Result.GetResult<Prisma.$TransporterInvoicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TransporterInvoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransporterInvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransporterInvoices
     * const transporterInvoices = await prisma.transporterInvoice.findMany()
     * 
     * // Get first 10 TransporterInvoices
     * const transporterInvoices = await prisma.transporterInvoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transporterInvoiceWithIdOnly = await prisma.transporterInvoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransporterInvoiceFindManyArgs>(args?: SelectSubset<T, TransporterInvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransporterInvoicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TransporterInvoice.
     * @param {TransporterInvoiceCreateArgs} args - Arguments to create a TransporterInvoice.
     * @example
     * // Create one TransporterInvoice
     * const TransporterInvoice = await prisma.transporterInvoice.create({
     *   data: {
     *     // ... data to create a TransporterInvoice
     *   }
     * })
     * 
     */
    create<T extends TransporterInvoiceCreateArgs>(args: SelectSubset<T, TransporterInvoiceCreateArgs<ExtArgs>>): Prisma__TransporterInvoiceClient<$Result.GetResult<Prisma.$TransporterInvoicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TransporterInvoices.
     * @param {TransporterInvoiceCreateManyArgs} args - Arguments to create many TransporterInvoices.
     * @example
     * // Create many TransporterInvoices
     * const transporterInvoice = await prisma.transporterInvoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransporterInvoiceCreateManyArgs>(args?: SelectSubset<T, TransporterInvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TransporterInvoices and returns the data saved in the database.
     * @param {TransporterInvoiceCreateManyAndReturnArgs} args - Arguments to create many TransporterInvoices.
     * @example
     * // Create many TransporterInvoices
     * const transporterInvoice = await prisma.transporterInvoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TransporterInvoices and only return the `id`
     * const transporterInvoiceWithIdOnly = await prisma.transporterInvoice.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransporterInvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, TransporterInvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransporterInvoicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TransporterInvoice.
     * @param {TransporterInvoiceDeleteArgs} args - Arguments to delete one TransporterInvoice.
     * @example
     * // Delete one TransporterInvoice
     * const TransporterInvoice = await prisma.transporterInvoice.delete({
     *   where: {
     *     // ... filter to delete one TransporterInvoice
     *   }
     * })
     * 
     */
    delete<T extends TransporterInvoiceDeleteArgs>(args: SelectSubset<T, TransporterInvoiceDeleteArgs<ExtArgs>>): Prisma__TransporterInvoiceClient<$Result.GetResult<Prisma.$TransporterInvoicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TransporterInvoice.
     * @param {TransporterInvoiceUpdateArgs} args - Arguments to update one TransporterInvoice.
     * @example
     * // Update one TransporterInvoice
     * const transporterInvoice = await prisma.transporterInvoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransporterInvoiceUpdateArgs>(args: SelectSubset<T, TransporterInvoiceUpdateArgs<ExtArgs>>): Prisma__TransporterInvoiceClient<$Result.GetResult<Prisma.$TransporterInvoicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TransporterInvoices.
     * @param {TransporterInvoiceDeleteManyArgs} args - Arguments to filter TransporterInvoices to delete.
     * @example
     * // Delete a few TransporterInvoices
     * const { count } = await prisma.transporterInvoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransporterInvoiceDeleteManyArgs>(args?: SelectSubset<T, TransporterInvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransporterInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransporterInvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransporterInvoices
     * const transporterInvoice = await prisma.transporterInvoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransporterInvoiceUpdateManyArgs>(args: SelectSubset<T, TransporterInvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TransporterInvoice.
     * @param {TransporterInvoiceUpsertArgs} args - Arguments to update or create a TransporterInvoice.
     * @example
     * // Update or create a TransporterInvoice
     * const transporterInvoice = await prisma.transporterInvoice.upsert({
     *   create: {
     *     // ... data to create a TransporterInvoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransporterInvoice we want to update
     *   }
     * })
     */
    upsert<T extends TransporterInvoiceUpsertArgs>(args: SelectSubset<T, TransporterInvoiceUpsertArgs<ExtArgs>>): Prisma__TransporterInvoiceClient<$Result.GetResult<Prisma.$TransporterInvoicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TransporterInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransporterInvoiceCountArgs} args - Arguments to filter TransporterInvoices to count.
     * @example
     * // Count the number of TransporterInvoices
     * const count = await prisma.transporterInvoice.count({
     *   where: {
     *     // ... the filter for the TransporterInvoices we want to count
     *   }
     * })
    **/
    count<T extends TransporterInvoiceCountArgs>(
      args?: Subset<T, TransporterInvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransporterInvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransporterInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransporterInvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransporterInvoiceAggregateArgs>(args: Subset<T, TransporterInvoiceAggregateArgs>): Prisma.PrismaPromise<GetTransporterInvoiceAggregateType<T>>

    /**
     * Group by TransporterInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransporterInvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransporterInvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransporterInvoiceGroupByArgs['orderBy'] }
        : { orderBy?: TransporterInvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransporterInvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransporterInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransporterInvoice model
   */
  readonly fields: TransporterInvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransporterInvoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransporterInvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    shipment<T extends ShipmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShipmentDefaultArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    approvedBy<T extends TransporterInvoice$approvedByArgs<ExtArgs> = {}>(args?: Subset<T, TransporterInvoice$approvedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransporterInvoice model
   */ 
  interface TransporterInvoiceFieldRefs {
    readonly id: FieldRef<"TransporterInvoice", 'Int'>
    readonly companyId: FieldRef<"TransporterInvoice", 'Int'>
    readonly shipmentId: FieldRef<"TransporterInvoice", 'Int'>
    readonly invoiceNumber: FieldRef<"TransporterInvoice", 'String'>
    readonly invoiceDate: FieldRef<"TransporterInvoice", 'DateTime'>
    readonly invoiceAmount: FieldRef<"TransporterInvoice", 'Float'>
    readonly invoiceUrl: FieldRef<"TransporterInvoice", 'String'>
    readonly approvalStatus: FieldRef<"TransporterInvoice", 'String'>
    readonly rejectionNotes: FieldRef<"TransporterInvoice", 'String'>
    readonly postedToErpAt: FieldRef<"TransporterInvoice", 'DateTime'>
    readonly approvedById: FieldRef<"TransporterInvoice", 'Int'>
    readonly createdAt: FieldRef<"TransporterInvoice", 'DateTime'>
    readonly updatedAt: FieldRef<"TransporterInvoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TransporterInvoice findUnique
   */
  export type TransporterInvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransporterInvoice
     */
    select?: TransporterInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransporterInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which TransporterInvoice to fetch.
     */
    where: TransporterInvoiceWhereUniqueInput
  }

  /**
   * TransporterInvoice findUniqueOrThrow
   */
  export type TransporterInvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransporterInvoice
     */
    select?: TransporterInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransporterInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which TransporterInvoice to fetch.
     */
    where: TransporterInvoiceWhereUniqueInput
  }

  /**
   * TransporterInvoice findFirst
   */
  export type TransporterInvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransporterInvoice
     */
    select?: TransporterInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransporterInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which TransporterInvoice to fetch.
     */
    where?: TransporterInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransporterInvoices to fetch.
     */
    orderBy?: TransporterInvoiceOrderByWithRelationInput | TransporterInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransporterInvoices.
     */
    cursor?: TransporterInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransporterInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransporterInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransporterInvoices.
     */
    distinct?: TransporterInvoiceScalarFieldEnum | TransporterInvoiceScalarFieldEnum[]
  }

  /**
   * TransporterInvoice findFirstOrThrow
   */
  export type TransporterInvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransporterInvoice
     */
    select?: TransporterInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransporterInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which TransporterInvoice to fetch.
     */
    where?: TransporterInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransporterInvoices to fetch.
     */
    orderBy?: TransporterInvoiceOrderByWithRelationInput | TransporterInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransporterInvoices.
     */
    cursor?: TransporterInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransporterInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransporterInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransporterInvoices.
     */
    distinct?: TransporterInvoiceScalarFieldEnum | TransporterInvoiceScalarFieldEnum[]
  }

  /**
   * TransporterInvoice findMany
   */
  export type TransporterInvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransporterInvoice
     */
    select?: TransporterInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransporterInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which TransporterInvoices to fetch.
     */
    where?: TransporterInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransporterInvoices to fetch.
     */
    orderBy?: TransporterInvoiceOrderByWithRelationInput | TransporterInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransporterInvoices.
     */
    cursor?: TransporterInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransporterInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransporterInvoices.
     */
    skip?: number
    distinct?: TransporterInvoiceScalarFieldEnum | TransporterInvoiceScalarFieldEnum[]
  }

  /**
   * TransporterInvoice create
   */
  export type TransporterInvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransporterInvoice
     */
    select?: TransporterInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransporterInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a TransporterInvoice.
     */
    data: XOR<TransporterInvoiceCreateInput, TransporterInvoiceUncheckedCreateInput>
  }

  /**
   * TransporterInvoice createMany
   */
  export type TransporterInvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransporterInvoices.
     */
    data: TransporterInvoiceCreateManyInput | TransporterInvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransporterInvoice createManyAndReturn
   */
  export type TransporterInvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransporterInvoice
     */
    select?: TransporterInvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TransporterInvoices.
     */
    data: TransporterInvoiceCreateManyInput | TransporterInvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransporterInvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransporterInvoice update
   */
  export type TransporterInvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransporterInvoice
     */
    select?: TransporterInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransporterInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a TransporterInvoice.
     */
    data: XOR<TransporterInvoiceUpdateInput, TransporterInvoiceUncheckedUpdateInput>
    /**
     * Choose, which TransporterInvoice to update.
     */
    where: TransporterInvoiceWhereUniqueInput
  }

  /**
   * TransporterInvoice updateMany
   */
  export type TransporterInvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransporterInvoices.
     */
    data: XOR<TransporterInvoiceUpdateManyMutationInput, TransporterInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which TransporterInvoices to update
     */
    where?: TransporterInvoiceWhereInput
  }

  /**
   * TransporterInvoice upsert
   */
  export type TransporterInvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransporterInvoice
     */
    select?: TransporterInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransporterInvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the TransporterInvoice to update in case it exists.
     */
    where: TransporterInvoiceWhereUniqueInput
    /**
     * In case the TransporterInvoice found by the `where` argument doesn't exist, create a new TransporterInvoice with this data.
     */
    create: XOR<TransporterInvoiceCreateInput, TransporterInvoiceUncheckedCreateInput>
    /**
     * In case the TransporterInvoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransporterInvoiceUpdateInput, TransporterInvoiceUncheckedUpdateInput>
  }

  /**
   * TransporterInvoice delete
   */
  export type TransporterInvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransporterInvoice
     */
    select?: TransporterInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransporterInvoiceInclude<ExtArgs> | null
    /**
     * Filter which TransporterInvoice to delete.
     */
    where: TransporterInvoiceWhereUniqueInput
  }

  /**
   * TransporterInvoice deleteMany
   */
  export type TransporterInvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransporterInvoices to delete
     */
    where?: TransporterInvoiceWhereInput
  }

  /**
   * TransporterInvoice.approvedBy
   */
  export type TransporterInvoice$approvedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * TransporterInvoice without action
   */
  export type TransporterInvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransporterInvoice
     */
    select?: TransporterInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransporterInvoiceInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    userId: number | null
    title: string | null
    message: string | null
    type: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    title: string | null
    message: string | null
    type: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    message: number
    type: number
    metadata: number
    isRead: number
    createdAt: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    metadata?: true
    isRead?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: number
    userId: number
    title: string
    message: string
    type: string
    metadata: JsonValue | null
    isRead: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    metadata?: boolean
    isRead?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    metadata?: boolean
    isRead?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    metadata?: boolean
    isRead?: boolean
    createdAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      title: string
      message: string
      type: string
      metadata: Prisma.JsonValue | null
      isRead: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'Int'>
    readonly userId: FieldRef<"Notification", 'Int'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly metadata: FieldRef<"Notification", 'Json'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    entityId: number | null
  }

  export type AuditLogSumAggregateOutputType = {
    id: number | null
    userId: number | null
    entityId: number | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: number | null
    userId: number | null
    action: string | null
    entityType: string | null
    entityId: number | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    action: string | null
    entityType: string | null
    entityId: number | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    entityType: number
    entityId: number
    details: number
    createdAt: number
    _all: number
  }


  export type AuditLogAvgAggregateInputType = {
    id?: true
    userId?: true
    entityId?: true
  }

  export type AuditLogSumAggregateInputType = {
    id?: true
    userId?: true
    entityId?: true
  }

  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    details?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _avg?: AuditLogAvgAggregateInputType
    _sum?: AuditLogSumAggregateInputType
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: number
    userId: number | null
    action: string
    entityType: string
    entityId: number | null
    details: JsonValue | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    details?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    details?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    details?: boolean
    createdAt?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
      action: string
      entityType: string
      entityId: number | null
      details: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'Int'>
    readonly userId: FieldRef<"AuditLog", 'Int'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'Int'>
    readonly details: FieldRef<"AuditLog", 'Json'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model ComplianceDocument
   */

  export type AggregateComplianceDocument = {
    _count: ComplianceDocumentCountAggregateOutputType | null
    _avg: ComplianceDocumentAvgAggregateOutputType | null
    _sum: ComplianceDocumentSumAggregateOutputType | null
    _min: ComplianceDocumentMinAggregateOutputType | null
    _max: ComplianceDocumentMaxAggregateOutputType | null
  }

  export type ComplianceDocumentAvgAggregateOutputType = {
    id: number | null
    shipmentId: number | null
  }

  export type ComplianceDocumentSumAggregateOutputType = {
    id: number | null
    shipmentId: number | null
  }

  export type ComplianceDocumentMinAggregateOutputType = {
    id: number | null
    shipmentId: number | null
    type: $Enums.DocumentType | null
    status: $Enums.ComplianceStatus | null
    issuedAt: Date | null
    fileUrl: string | null
    remarks: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComplianceDocumentMaxAggregateOutputType = {
    id: number | null
    shipmentId: number | null
    type: $Enums.DocumentType | null
    status: $Enums.ComplianceStatus | null
    issuedAt: Date | null
    fileUrl: string | null
    remarks: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComplianceDocumentCountAggregateOutputType = {
    id: number
    shipmentId: number
    type: number
    status: number
    issuedAt: number
    fileUrl: number
    payload: number
    metadata: number
    remarks: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ComplianceDocumentAvgAggregateInputType = {
    id?: true
    shipmentId?: true
  }

  export type ComplianceDocumentSumAggregateInputType = {
    id?: true
    shipmentId?: true
  }

  export type ComplianceDocumentMinAggregateInputType = {
    id?: true
    shipmentId?: true
    type?: true
    status?: true
    issuedAt?: true
    fileUrl?: true
    remarks?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComplianceDocumentMaxAggregateInputType = {
    id?: true
    shipmentId?: true
    type?: true
    status?: true
    issuedAt?: true
    fileUrl?: true
    remarks?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComplianceDocumentCountAggregateInputType = {
    id?: true
    shipmentId?: true
    type?: true
    status?: true
    issuedAt?: true
    fileUrl?: true
    payload?: true
    metadata?: true
    remarks?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ComplianceDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComplianceDocument to aggregate.
     */
    where?: ComplianceDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplianceDocuments to fetch.
     */
    orderBy?: ComplianceDocumentOrderByWithRelationInput | ComplianceDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComplianceDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplianceDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplianceDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ComplianceDocuments
    **/
    _count?: true | ComplianceDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComplianceDocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComplianceDocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComplianceDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComplianceDocumentMaxAggregateInputType
  }

  export type GetComplianceDocumentAggregateType<T extends ComplianceDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateComplianceDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComplianceDocument[P]>
      : GetScalarType<T[P], AggregateComplianceDocument[P]>
  }




  export type ComplianceDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplianceDocumentWhereInput
    orderBy?: ComplianceDocumentOrderByWithAggregationInput | ComplianceDocumentOrderByWithAggregationInput[]
    by: ComplianceDocumentScalarFieldEnum[] | ComplianceDocumentScalarFieldEnum
    having?: ComplianceDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComplianceDocumentCountAggregateInputType | true
    _avg?: ComplianceDocumentAvgAggregateInputType
    _sum?: ComplianceDocumentSumAggregateInputType
    _min?: ComplianceDocumentMinAggregateInputType
    _max?: ComplianceDocumentMaxAggregateInputType
  }

  export type ComplianceDocumentGroupByOutputType = {
    id: number
    shipmentId: number
    type: $Enums.DocumentType
    status: $Enums.ComplianceStatus
    issuedAt: Date | null
    fileUrl: string | null
    payload: JsonValue | null
    metadata: JsonValue | null
    remarks: string | null
    createdAt: Date
    updatedAt: Date
    _count: ComplianceDocumentCountAggregateOutputType | null
    _avg: ComplianceDocumentAvgAggregateOutputType | null
    _sum: ComplianceDocumentSumAggregateOutputType | null
    _min: ComplianceDocumentMinAggregateOutputType | null
    _max: ComplianceDocumentMaxAggregateOutputType | null
  }

  type GetComplianceDocumentGroupByPayload<T extends ComplianceDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComplianceDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComplianceDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComplianceDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], ComplianceDocumentGroupByOutputType[P]>
        }
      >
    >


  export type ComplianceDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shipmentId?: boolean
    type?: boolean
    status?: boolean
    issuedAt?: boolean
    fileUrl?: boolean
    payload?: boolean
    metadata?: boolean
    remarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shipment?: boolean | ShipmentDefaultArgs<ExtArgs>
    events?: boolean | ComplianceDocument$eventsArgs<ExtArgs>
    _count?: boolean | ComplianceDocumentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complianceDocument"]>

  export type ComplianceDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shipmentId?: boolean
    type?: boolean
    status?: boolean
    issuedAt?: boolean
    fileUrl?: boolean
    payload?: boolean
    metadata?: boolean
    remarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shipment?: boolean | ShipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complianceDocument"]>

  export type ComplianceDocumentSelectScalar = {
    id?: boolean
    shipmentId?: boolean
    type?: boolean
    status?: boolean
    issuedAt?: boolean
    fileUrl?: boolean
    payload?: boolean
    metadata?: boolean
    remarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ComplianceDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shipment?: boolean | ShipmentDefaultArgs<ExtArgs>
    events?: boolean | ComplianceDocument$eventsArgs<ExtArgs>
    _count?: boolean | ComplianceDocumentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ComplianceDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shipment?: boolean | ShipmentDefaultArgs<ExtArgs>
  }

  export type $ComplianceDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ComplianceDocument"
    objects: {
      shipment: Prisma.$ShipmentPayload<ExtArgs>
      events: Prisma.$ComplianceEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      shipmentId: number
      type: $Enums.DocumentType
      status: $Enums.ComplianceStatus
      issuedAt: Date | null
      fileUrl: string | null
      payload: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
      remarks: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["complianceDocument"]>
    composites: {}
  }

  type ComplianceDocumentGetPayload<S extends boolean | null | undefined | ComplianceDocumentDefaultArgs> = $Result.GetResult<Prisma.$ComplianceDocumentPayload, S>

  type ComplianceDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ComplianceDocumentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ComplianceDocumentCountAggregateInputType | true
    }

  export interface ComplianceDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ComplianceDocument'], meta: { name: 'ComplianceDocument' } }
    /**
     * Find zero or one ComplianceDocument that matches the filter.
     * @param {ComplianceDocumentFindUniqueArgs} args - Arguments to find a ComplianceDocument
     * @example
     * // Get one ComplianceDocument
     * const complianceDocument = await prisma.complianceDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComplianceDocumentFindUniqueArgs>(args: SelectSubset<T, ComplianceDocumentFindUniqueArgs<ExtArgs>>): Prisma__ComplianceDocumentClient<$Result.GetResult<Prisma.$ComplianceDocumentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ComplianceDocument that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ComplianceDocumentFindUniqueOrThrowArgs} args - Arguments to find a ComplianceDocument
     * @example
     * // Get one ComplianceDocument
     * const complianceDocument = await prisma.complianceDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComplianceDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, ComplianceDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComplianceDocumentClient<$Result.GetResult<Prisma.$ComplianceDocumentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ComplianceDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceDocumentFindFirstArgs} args - Arguments to find a ComplianceDocument
     * @example
     * // Get one ComplianceDocument
     * const complianceDocument = await prisma.complianceDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComplianceDocumentFindFirstArgs>(args?: SelectSubset<T, ComplianceDocumentFindFirstArgs<ExtArgs>>): Prisma__ComplianceDocumentClient<$Result.GetResult<Prisma.$ComplianceDocumentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ComplianceDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceDocumentFindFirstOrThrowArgs} args - Arguments to find a ComplianceDocument
     * @example
     * // Get one ComplianceDocument
     * const complianceDocument = await prisma.complianceDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComplianceDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, ComplianceDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComplianceDocumentClient<$Result.GetResult<Prisma.$ComplianceDocumentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ComplianceDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ComplianceDocuments
     * const complianceDocuments = await prisma.complianceDocument.findMany()
     * 
     * // Get first 10 ComplianceDocuments
     * const complianceDocuments = await prisma.complianceDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const complianceDocumentWithIdOnly = await prisma.complianceDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComplianceDocumentFindManyArgs>(args?: SelectSubset<T, ComplianceDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplianceDocumentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ComplianceDocument.
     * @param {ComplianceDocumentCreateArgs} args - Arguments to create a ComplianceDocument.
     * @example
     * // Create one ComplianceDocument
     * const ComplianceDocument = await prisma.complianceDocument.create({
     *   data: {
     *     // ... data to create a ComplianceDocument
     *   }
     * })
     * 
     */
    create<T extends ComplianceDocumentCreateArgs>(args: SelectSubset<T, ComplianceDocumentCreateArgs<ExtArgs>>): Prisma__ComplianceDocumentClient<$Result.GetResult<Prisma.$ComplianceDocumentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ComplianceDocuments.
     * @param {ComplianceDocumentCreateManyArgs} args - Arguments to create many ComplianceDocuments.
     * @example
     * // Create many ComplianceDocuments
     * const complianceDocument = await prisma.complianceDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComplianceDocumentCreateManyArgs>(args?: SelectSubset<T, ComplianceDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ComplianceDocuments and returns the data saved in the database.
     * @param {ComplianceDocumentCreateManyAndReturnArgs} args - Arguments to create many ComplianceDocuments.
     * @example
     * // Create many ComplianceDocuments
     * const complianceDocument = await prisma.complianceDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ComplianceDocuments and only return the `id`
     * const complianceDocumentWithIdOnly = await prisma.complianceDocument.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComplianceDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, ComplianceDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplianceDocumentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ComplianceDocument.
     * @param {ComplianceDocumentDeleteArgs} args - Arguments to delete one ComplianceDocument.
     * @example
     * // Delete one ComplianceDocument
     * const ComplianceDocument = await prisma.complianceDocument.delete({
     *   where: {
     *     // ... filter to delete one ComplianceDocument
     *   }
     * })
     * 
     */
    delete<T extends ComplianceDocumentDeleteArgs>(args: SelectSubset<T, ComplianceDocumentDeleteArgs<ExtArgs>>): Prisma__ComplianceDocumentClient<$Result.GetResult<Prisma.$ComplianceDocumentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ComplianceDocument.
     * @param {ComplianceDocumentUpdateArgs} args - Arguments to update one ComplianceDocument.
     * @example
     * // Update one ComplianceDocument
     * const complianceDocument = await prisma.complianceDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComplianceDocumentUpdateArgs>(args: SelectSubset<T, ComplianceDocumentUpdateArgs<ExtArgs>>): Prisma__ComplianceDocumentClient<$Result.GetResult<Prisma.$ComplianceDocumentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ComplianceDocuments.
     * @param {ComplianceDocumentDeleteManyArgs} args - Arguments to filter ComplianceDocuments to delete.
     * @example
     * // Delete a few ComplianceDocuments
     * const { count } = await prisma.complianceDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComplianceDocumentDeleteManyArgs>(args?: SelectSubset<T, ComplianceDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComplianceDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ComplianceDocuments
     * const complianceDocument = await prisma.complianceDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComplianceDocumentUpdateManyArgs>(args: SelectSubset<T, ComplianceDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ComplianceDocument.
     * @param {ComplianceDocumentUpsertArgs} args - Arguments to update or create a ComplianceDocument.
     * @example
     * // Update or create a ComplianceDocument
     * const complianceDocument = await prisma.complianceDocument.upsert({
     *   create: {
     *     // ... data to create a ComplianceDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ComplianceDocument we want to update
     *   }
     * })
     */
    upsert<T extends ComplianceDocumentUpsertArgs>(args: SelectSubset<T, ComplianceDocumentUpsertArgs<ExtArgs>>): Prisma__ComplianceDocumentClient<$Result.GetResult<Prisma.$ComplianceDocumentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ComplianceDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceDocumentCountArgs} args - Arguments to filter ComplianceDocuments to count.
     * @example
     * // Count the number of ComplianceDocuments
     * const count = await prisma.complianceDocument.count({
     *   where: {
     *     // ... the filter for the ComplianceDocuments we want to count
     *   }
     * })
    **/
    count<T extends ComplianceDocumentCountArgs>(
      args?: Subset<T, ComplianceDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComplianceDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ComplianceDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComplianceDocumentAggregateArgs>(args: Subset<T, ComplianceDocumentAggregateArgs>): Prisma.PrismaPromise<GetComplianceDocumentAggregateType<T>>

    /**
     * Group by ComplianceDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComplianceDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComplianceDocumentGroupByArgs['orderBy'] }
        : { orderBy?: ComplianceDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComplianceDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComplianceDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ComplianceDocument model
   */
  readonly fields: ComplianceDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ComplianceDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComplianceDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    shipment<T extends ShipmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShipmentDefaultArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    events<T extends ComplianceDocument$eventsArgs<ExtArgs> = {}>(args?: Subset<T, ComplianceDocument$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplianceEventPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ComplianceDocument model
   */ 
  interface ComplianceDocumentFieldRefs {
    readonly id: FieldRef<"ComplianceDocument", 'Int'>
    readonly shipmentId: FieldRef<"ComplianceDocument", 'Int'>
    readonly type: FieldRef<"ComplianceDocument", 'DocumentType'>
    readonly status: FieldRef<"ComplianceDocument", 'ComplianceStatus'>
    readonly issuedAt: FieldRef<"ComplianceDocument", 'DateTime'>
    readonly fileUrl: FieldRef<"ComplianceDocument", 'String'>
    readonly payload: FieldRef<"ComplianceDocument", 'Json'>
    readonly metadata: FieldRef<"ComplianceDocument", 'Json'>
    readonly remarks: FieldRef<"ComplianceDocument", 'String'>
    readonly createdAt: FieldRef<"ComplianceDocument", 'DateTime'>
    readonly updatedAt: FieldRef<"ComplianceDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ComplianceDocument findUnique
   */
  export type ComplianceDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceDocument
     */
    select?: ComplianceDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ComplianceDocument to fetch.
     */
    where: ComplianceDocumentWhereUniqueInput
  }

  /**
   * ComplianceDocument findUniqueOrThrow
   */
  export type ComplianceDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceDocument
     */
    select?: ComplianceDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ComplianceDocument to fetch.
     */
    where: ComplianceDocumentWhereUniqueInput
  }

  /**
   * ComplianceDocument findFirst
   */
  export type ComplianceDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceDocument
     */
    select?: ComplianceDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ComplianceDocument to fetch.
     */
    where?: ComplianceDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplianceDocuments to fetch.
     */
    orderBy?: ComplianceDocumentOrderByWithRelationInput | ComplianceDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComplianceDocuments.
     */
    cursor?: ComplianceDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplianceDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplianceDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComplianceDocuments.
     */
    distinct?: ComplianceDocumentScalarFieldEnum | ComplianceDocumentScalarFieldEnum[]
  }

  /**
   * ComplianceDocument findFirstOrThrow
   */
  export type ComplianceDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceDocument
     */
    select?: ComplianceDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ComplianceDocument to fetch.
     */
    where?: ComplianceDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplianceDocuments to fetch.
     */
    orderBy?: ComplianceDocumentOrderByWithRelationInput | ComplianceDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComplianceDocuments.
     */
    cursor?: ComplianceDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplianceDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplianceDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComplianceDocuments.
     */
    distinct?: ComplianceDocumentScalarFieldEnum | ComplianceDocumentScalarFieldEnum[]
  }

  /**
   * ComplianceDocument findMany
   */
  export type ComplianceDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceDocument
     */
    select?: ComplianceDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ComplianceDocuments to fetch.
     */
    where?: ComplianceDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplianceDocuments to fetch.
     */
    orderBy?: ComplianceDocumentOrderByWithRelationInput | ComplianceDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ComplianceDocuments.
     */
    cursor?: ComplianceDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplianceDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplianceDocuments.
     */
    skip?: number
    distinct?: ComplianceDocumentScalarFieldEnum | ComplianceDocumentScalarFieldEnum[]
  }

  /**
   * ComplianceDocument create
   */
  export type ComplianceDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceDocument
     */
    select?: ComplianceDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a ComplianceDocument.
     */
    data: XOR<ComplianceDocumentCreateInput, ComplianceDocumentUncheckedCreateInput>
  }

  /**
   * ComplianceDocument createMany
   */
  export type ComplianceDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ComplianceDocuments.
     */
    data: ComplianceDocumentCreateManyInput | ComplianceDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ComplianceDocument createManyAndReturn
   */
  export type ComplianceDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceDocument
     */
    select?: ComplianceDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ComplianceDocuments.
     */
    data: ComplianceDocumentCreateManyInput | ComplianceDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ComplianceDocument update
   */
  export type ComplianceDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceDocument
     */
    select?: ComplianceDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a ComplianceDocument.
     */
    data: XOR<ComplianceDocumentUpdateInput, ComplianceDocumentUncheckedUpdateInput>
    /**
     * Choose, which ComplianceDocument to update.
     */
    where: ComplianceDocumentWhereUniqueInput
  }

  /**
   * ComplianceDocument updateMany
   */
  export type ComplianceDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ComplianceDocuments.
     */
    data: XOR<ComplianceDocumentUpdateManyMutationInput, ComplianceDocumentUncheckedUpdateManyInput>
    /**
     * Filter which ComplianceDocuments to update
     */
    where?: ComplianceDocumentWhereInput
  }

  /**
   * ComplianceDocument upsert
   */
  export type ComplianceDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceDocument
     */
    select?: ComplianceDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the ComplianceDocument to update in case it exists.
     */
    where: ComplianceDocumentWhereUniqueInput
    /**
     * In case the ComplianceDocument found by the `where` argument doesn't exist, create a new ComplianceDocument with this data.
     */
    create: XOR<ComplianceDocumentCreateInput, ComplianceDocumentUncheckedCreateInput>
    /**
     * In case the ComplianceDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComplianceDocumentUpdateInput, ComplianceDocumentUncheckedUpdateInput>
  }

  /**
   * ComplianceDocument delete
   */
  export type ComplianceDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceDocument
     */
    select?: ComplianceDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceDocumentInclude<ExtArgs> | null
    /**
     * Filter which ComplianceDocument to delete.
     */
    where: ComplianceDocumentWhereUniqueInput
  }

  /**
   * ComplianceDocument deleteMany
   */
  export type ComplianceDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComplianceDocuments to delete
     */
    where?: ComplianceDocumentWhereInput
  }

  /**
   * ComplianceDocument.events
   */
  export type ComplianceDocument$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceEvent
     */
    select?: ComplianceEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceEventInclude<ExtArgs> | null
    where?: ComplianceEventWhereInput
    orderBy?: ComplianceEventOrderByWithRelationInput | ComplianceEventOrderByWithRelationInput[]
    cursor?: ComplianceEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplianceEventScalarFieldEnum | ComplianceEventScalarFieldEnum[]
  }

  /**
   * ComplianceDocument without action
   */
  export type ComplianceDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceDocument
     */
    select?: ComplianceDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceDocumentInclude<ExtArgs> | null
  }


  /**
   * Model ComplianceEvent
   */

  export type AggregateComplianceEvent = {
    _count: ComplianceEventCountAggregateOutputType | null
    _avg: ComplianceEventAvgAggregateOutputType | null
    _sum: ComplianceEventSumAggregateOutputType | null
    _min: ComplianceEventMinAggregateOutputType | null
    _max: ComplianceEventMaxAggregateOutputType | null
  }

  export type ComplianceEventAvgAggregateOutputType = {
    id: number | null
    documentId: number | null
  }

  export type ComplianceEventSumAggregateOutputType = {
    id: number | null
    documentId: number | null
  }

  export type ComplianceEventMinAggregateOutputType = {
    id: number | null
    documentId: number | null
    eventType: string | null
    recordedAt: Date | null
  }

  export type ComplianceEventMaxAggregateOutputType = {
    id: number | null
    documentId: number | null
    eventType: string | null
    recordedAt: Date | null
  }

  export type ComplianceEventCountAggregateOutputType = {
    id: number
    documentId: number
    eventType: number
    details: number
    recordedAt: number
    _all: number
  }


  export type ComplianceEventAvgAggregateInputType = {
    id?: true
    documentId?: true
  }

  export type ComplianceEventSumAggregateInputType = {
    id?: true
    documentId?: true
  }

  export type ComplianceEventMinAggregateInputType = {
    id?: true
    documentId?: true
    eventType?: true
    recordedAt?: true
  }

  export type ComplianceEventMaxAggregateInputType = {
    id?: true
    documentId?: true
    eventType?: true
    recordedAt?: true
  }

  export type ComplianceEventCountAggregateInputType = {
    id?: true
    documentId?: true
    eventType?: true
    details?: true
    recordedAt?: true
    _all?: true
  }

  export type ComplianceEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComplianceEvent to aggregate.
     */
    where?: ComplianceEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplianceEvents to fetch.
     */
    orderBy?: ComplianceEventOrderByWithRelationInput | ComplianceEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComplianceEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplianceEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplianceEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ComplianceEvents
    **/
    _count?: true | ComplianceEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComplianceEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComplianceEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComplianceEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComplianceEventMaxAggregateInputType
  }

  export type GetComplianceEventAggregateType<T extends ComplianceEventAggregateArgs> = {
        [P in keyof T & keyof AggregateComplianceEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComplianceEvent[P]>
      : GetScalarType<T[P], AggregateComplianceEvent[P]>
  }




  export type ComplianceEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplianceEventWhereInput
    orderBy?: ComplianceEventOrderByWithAggregationInput | ComplianceEventOrderByWithAggregationInput[]
    by: ComplianceEventScalarFieldEnum[] | ComplianceEventScalarFieldEnum
    having?: ComplianceEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComplianceEventCountAggregateInputType | true
    _avg?: ComplianceEventAvgAggregateInputType
    _sum?: ComplianceEventSumAggregateInputType
    _min?: ComplianceEventMinAggregateInputType
    _max?: ComplianceEventMaxAggregateInputType
  }

  export type ComplianceEventGroupByOutputType = {
    id: number
    documentId: number
    eventType: string
    details: JsonValue | null
    recordedAt: Date
    _count: ComplianceEventCountAggregateOutputType | null
    _avg: ComplianceEventAvgAggregateOutputType | null
    _sum: ComplianceEventSumAggregateOutputType | null
    _min: ComplianceEventMinAggregateOutputType | null
    _max: ComplianceEventMaxAggregateOutputType | null
  }

  type GetComplianceEventGroupByPayload<T extends ComplianceEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComplianceEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComplianceEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComplianceEventGroupByOutputType[P]>
            : GetScalarType<T[P], ComplianceEventGroupByOutputType[P]>
        }
      >
    >


  export type ComplianceEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    eventType?: boolean
    details?: boolean
    recordedAt?: boolean
    document?: boolean | ComplianceDocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complianceEvent"]>

  export type ComplianceEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    eventType?: boolean
    details?: boolean
    recordedAt?: boolean
    document?: boolean | ComplianceDocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complianceEvent"]>

  export type ComplianceEventSelectScalar = {
    id?: boolean
    documentId?: boolean
    eventType?: boolean
    details?: boolean
    recordedAt?: boolean
  }

  export type ComplianceEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | ComplianceDocumentDefaultArgs<ExtArgs>
  }
  export type ComplianceEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | ComplianceDocumentDefaultArgs<ExtArgs>
  }

  export type $ComplianceEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ComplianceEvent"
    objects: {
      document: Prisma.$ComplianceDocumentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      documentId: number
      eventType: string
      details: Prisma.JsonValue | null
      recordedAt: Date
    }, ExtArgs["result"]["complianceEvent"]>
    composites: {}
  }

  type ComplianceEventGetPayload<S extends boolean | null | undefined | ComplianceEventDefaultArgs> = $Result.GetResult<Prisma.$ComplianceEventPayload, S>

  type ComplianceEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ComplianceEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ComplianceEventCountAggregateInputType | true
    }

  export interface ComplianceEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ComplianceEvent'], meta: { name: 'ComplianceEvent' } }
    /**
     * Find zero or one ComplianceEvent that matches the filter.
     * @param {ComplianceEventFindUniqueArgs} args - Arguments to find a ComplianceEvent
     * @example
     * // Get one ComplianceEvent
     * const complianceEvent = await prisma.complianceEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComplianceEventFindUniqueArgs>(args: SelectSubset<T, ComplianceEventFindUniqueArgs<ExtArgs>>): Prisma__ComplianceEventClient<$Result.GetResult<Prisma.$ComplianceEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ComplianceEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ComplianceEventFindUniqueOrThrowArgs} args - Arguments to find a ComplianceEvent
     * @example
     * // Get one ComplianceEvent
     * const complianceEvent = await prisma.complianceEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComplianceEventFindUniqueOrThrowArgs>(args: SelectSubset<T, ComplianceEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComplianceEventClient<$Result.GetResult<Prisma.$ComplianceEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ComplianceEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceEventFindFirstArgs} args - Arguments to find a ComplianceEvent
     * @example
     * // Get one ComplianceEvent
     * const complianceEvent = await prisma.complianceEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComplianceEventFindFirstArgs>(args?: SelectSubset<T, ComplianceEventFindFirstArgs<ExtArgs>>): Prisma__ComplianceEventClient<$Result.GetResult<Prisma.$ComplianceEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ComplianceEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceEventFindFirstOrThrowArgs} args - Arguments to find a ComplianceEvent
     * @example
     * // Get one ComplianceEvent
     * const complianceEvent = await prisma.complianceEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComplianceEventFindFirstOrThrowArgs>(args?: SelectSubset<T, ComplianceEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComplianceEventClient<$Result.GetResult<Prisma.$ComplianceEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ComplianceEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ComplianceEvents
     * const complianceEvents = await prisma.complianceEvent.findMany()
     * 
     * // Get first 10 ComplianceEvents
     * const complianceEvents = await prisma.complianceEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const complianceEventWithIdOnly = await prisma.complianceEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComplianceEventFindManyArgs>(args?: SelectSubset<T, ComplianceEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplianceEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ComplianceEvent.
     * @param {ComplianceEventCreateArgs} args - Arguments to create a ComplianceEvent.
     * @example
     * // Create one ComplianceEvent
     * const ComplianceEvent = await prisma.complianceEvent.create({
     *   data: {
     *     // ... data to create a ComplianceEvent
     *   }
     * })
     * 
     */
    create<T extends ComplianceEventCreateArgs>(args: SelectSubset<T, ComplianceEventCreateArgs<ExtArgs>>): Prisma__ComplianceEventClient<$Result.GetResult<Prisma.$ComplianceEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ComplianceEvents.
     * @param {ComplianceEventCreateManyArgs} args - Arguments to create many ComplianceEvents.
     * @example
     * // Create many ComplianceEvents
     * const complianceEvent = await prisma.complianceEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComplianceEventCreateManyArgs>(args?: SelectSubset<T, ComplianceEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ComplianceEvents and returns the data saved in the database.
     * @param {ComplianceEventCreateManyAndReturnArgs} args - Arguments to create many ComplianceEvents.
     * @example
     * // Create many ComplianceEvents
     * const complianceEvent = await prisma.complianceEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ComplianceEvents and only return the `id`
     * const complianceEventWithIdOnly = await prisma.complianceEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComplianceEventCreateManyAndReturnArgs>(args?: SelectSubset<T, ComplianceEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplianceEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ComplianceEvent.
     * @param {ComplianceEventDeleteArgs} args - Arguments to delete one ComplianceEvent.
     * @example
     * // Delete one ComplianceEvent
     * const ComplianceEvent = await prisma.complianceEvent.delete({
     *   where: {
     *     // ... filter to delete one ComplianceEvent
     *   }
     * })
     * 
     */
    delete<T extends ComplianceEventDeleteArgs>(args: SelectSubset<T, ComplianceEventDeleteArgs<ExtArgs>>): Prisma__ComplianceEventClient<$Result.GetResult<Prisma.$ComplianceEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ComplianceEvent.
     * @param {ComplianceEventUpdateArgs} args - Arguments to update one ComplianceEvent.
     * @example
     * // Update one ComplianceEvent
     * const complianceEvent = await prisma.complianceEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComplianceEventUpdateArgs>(args: SelectSubset<T, ComplianceEventUpdateArgs<ExtArgs>>): Prisma__ComplianceEventClient<$Result.GetResult<Prisma.$ComplianceEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ComplianceEvents.
     * @param {ComplianceEventDeleteManyArgs} args - Arguments to filter ComplianceEvents to delete.
     * @example
     * // Delete a few ComplianceEvents
     * const { count } = await prisma.complianceEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComplianceEventDeleteManyArgs>(args?: SelectSubset<T, ComplianceEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComplianceEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ComplianceEvents
     * const complianceEvent = await prisma.complianceEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComplianceEventUpdateManyArgs>(args: SelectSubset<T, ComplianceEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ComplianceEvent.
     * @param {ComplianceEventUpsertArgs} args - Arguments to update or create a ComplianceEvent.
     * @example
     * // Update or create a ComplianceEvent
     * const complianceEvent = await prisma.complianceEvent.upsert({
     *   create: {
     *     // ... data to create a ComplianceEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ComplianceEvent we want to update
     *   }
     * })
     */
    upsert<T extends ComplianceEventUpsertArgs>(args: SelectSubset<T, ComplianceEventUpsertArgs<ExtArgs>>): Prisma__ComplianceEventClient<$Result.GetResult<Prisma.$ComplianceEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ComplianceEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceEventCountArgs} args - Arguments to filter ComplianceEvents to count.
     * @example
     * // Count the number of ComplianceEvents
     * const count = await prisma.complianceEvent.count({
     *   where: {
     *     // ... the filter for the ComplianceEvents we want to count
     *   }
     * })
    **/
    count<T extends ComplianceEventCountArgs>(
      args?: Subset<T, ComplianceEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComplianceEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ComplianceEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComplianceEventAggregateArgs>(args: Subset<T, ComplianceEventAggregateArgs>): Prisma.PrismaPromise<GetComplianceEventAggregateType<T>>

    /**
     * Group by ComplianceEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComplianceEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComplianceEventGroupByArgs['orderBy'] }
        : { orderBy?: ComplianceEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComplianceEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComplianceEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ComplianceEvent model
   */
  readonly fields: ComplianceEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ComplianceEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComplianceEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    document<T extends ComplianceDocumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComplianceDocumentDefaultArgs<ExtArgs>>): Prisma__ComplianceDocumentClient<$Result.GetResult<Prisma.$ComplianceDocumentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ComplianceEvent model
   */ 
  interface ComplianceEventFieldRefs {
    readonly id: FieldRef<"ComplianceEvent", 'Int'>
    readonly documentId: FieldRef<"ComplianceEvent", 'Int'>
    readonly eventType: FieldRef<"ComplianceEvent", 'String'>
    readonly details: FieldRef<"ComplianceEvent", 'Json'>
    readonly recordedAt: FieldRef<"ComplianceEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ComplianceEvent findUnique
   */
  export type ComplianceEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceEvent
     */
    select?: ComplianceEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceEventInclude<ExtArgs> | null
    /**
     * Filter, which ComplianceEvent to fetch.
     */
    where: ComplianceEventWhereUniqueInput
  }

  /**
   * ComplianceEvent findUniqueOrThrow
   */
  export type ComplianceEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceEvent
     */
    select?: ComplianceEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceEventInclude<ExtArgs> | null
    /**
     * Filter, which ComplianceEvent to fetch.
     */
    where: ComplianceEventWhereUniqueInput
  }

  /**
   * ComplianceEvent findFirst
   */
  export type ComplianceEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceEvent
     */
    select?: ComplianceEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceEventInclude<ExtArgs> | null
    /**
     * Filter, which ComplianceEvent to fetch.
     */
    where?: ComplianceEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplianceEvents to fetch.
     */
    orderBy?: ComplianceEventOrderByWithRelationInput | ComplianceEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComplianceEvents.
     */
    cursor?: ComplianceEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplianceEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplianceEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComplianceEvents.
     */
    distinct?: ComplianceEventScalarFieldEnum | ComplianceEventScalarFieldEnum[]
  }

  /**
   * ComplianceEvent findFirstOrThrow
   */
  export type ComplianceEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceEvent
     */
    select?: ComplianceEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceEventInclude<ExtArgs> | null
    /**
     * Filter, which ComplianceEvent to fetch.
     */
    where?: ComplianceEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplianceEvents to fetch.
     */
    orderBy?: ComplianceEventOrderByWithRelationInput | ComplianceEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComplianceEvents.
     */
    cursor?: ComplianceEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplianceEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplianceEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComplianceEvents.
     */
    distinct?: ComplianceEventScalarFieldEnum | ComplianceEventScalarFieldEnum[]
  }

  /**
   * ComplianceEvent findMany
   */
  export type ComplianceEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceEvent
     */
    select?: ComplianceEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceEventInclude<ExtArgs> | null
    /**
     * Filter, which ComplianceEvents to fetch.
     */
    where?: ComplianceEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplianceEvents to fetch.
     */
    orderBy?: ComplianceEventOrderByWithRelationInput | ComplianceEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ComplianceEvents.
     */
    cursor?: ComplianceEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplianceEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplianceEvents.
     */
    skip?: number
    distinct?: ComplianceEventScalarFieldEnum | ComplianceEventScalarFieldEnum[]
  }

  /**
   * ComplianceEvent create
   */
  export type ComplianceEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceEvent
     */
    select?: ComplianceEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceEventInclude<ExtArgs> | null
    /**
     * The data needed to create a ComplianceEvent.
     */
    data: XOR<ComplianceEventCreateInput, ComplianceEventUncheckedCreateInput>
  }

  /**
   * ComplianceEvent createMany
   */
  export type ComplianceEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ComplianceEvents.
     */
    data: ComplianceEventCreateManyInput | ComplianceEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ComplianceEvent createManyAndReturn
   */
  export type ComplianceEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceEvent
     */
    select?: ComplianceEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ComplianceEvents.
     */
    data: ComplianceEventCreateManyInput | ComplianceEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ComplianceEvent update
   */
  export type ComplianceEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceEvent
     */
    select?: ComplianceEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceEventInclude<ExtArgs> | null
    /**
     * The data needed to update a ComplianceEvent.
     */
    data: XOR<ComplianceEventUpdateInput, ComplianceEventUncheckedUpdateInput>
    /**
     * Choose, which ComplianceEvent to update.
     */
    where: ComplianceEventWhereUniqueInput
  }

  /**
   * ComplianceEvent updateMany
   */
  export type ComplianceEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ComplianceEvents.
     */
    data: XOR<ComplianceEventUpdateManyMutationInput, ComplianceEventUncheckedUpdateManyInput>
    /**
     * Filter which ComplianceEvents to update
     */
    where?: ComplianceEventWhereInput
  }

  /**
   * ComplianceEvent upsert
   */
  export type ComplianceEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceEvent
     */
    select?: ComplianceEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceEventInclude<ExtArgs> | null
    /**
     * The filter to search for the ComplianceEvent to update in case it exists.
     */
    where: ComplianceEventWhereUniqueInput
    /**
     * In case the ComplianceEvent found by the `where` argument doesn't exist, create a new ComplianceEvent with this data.
     */
    create: XOR<ComplianceEventCreateInput, ComplianceEventUncheckedCreateInput>
    /**
     * In case the ComplianceEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComplianceEventUpdateInput, ComplianceEventUncheckedUpdateInput>
  }

  /**
   * ComplianceEvent delete
   */
  export type ComplianceEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceEvent
     */
    select?: ComplianceEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceEventInclude<ExtArgs> | null
    /**
     * Filter which ComplianceEvent to delete.
     */
    where: ComplianceEventWhereUniqueInput
  }

  /**
   * ComplianceEvent deleteMany
   */
  export type ComplianceEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComplianceEvents to delete
     */
    where?: ComplianceEventWhereInput
  }

  /**
   * ComplianceEvent without action
   */
  export type ComplianceEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceEvent
     */
    select?: ComplianceEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceEventInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    webhookSecret: 'webhookSecret',
    plan: 'plan',
    subscriptionStatus: 'subscriptionStatus',
    billingEmail: 'billingEmail',
    billingCustomerId: 'billingCustomerId',
    trialEndsAt: 'trialEndsAt',
    settings: 'settings',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const CompanyProfileScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    legalName: 'legalName',
    gstin: 'gstin',
    pan: 'pan',
    tan: 'tan',
    addressLine1: 'addressLine1',
    addressLine2: 'addressLine2',
    city: 'city',
    state: 'state',
    postalCode: 'postalCode',
    country: 'country',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyProfileScalarFieldEnum = (typeof CompanyProfileScalarFieldEnum)[keyof typeof CompanyProfileScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    name: 'name',
    phone: 'phone',
    role: 'role',
    approvalStatus: 'approvalStatus',
    approvalNote: 'approvalNote',
    rejectionReason: 'rejectionReason',
    reviewedById: 'reviewedById',
    reviewedAt: 'reviewedAt',
    isActive: 'isActive',
    vendorId: 'vendorId',
    companyId: 'companyId',
    lastLoginAt: 'lastLoginAt',
    notificationPreferences: 'notificationPreferences',
    twoFactorEnabled: 'twoFactorEnabled',
    twoFactorChannel: 'twoFactorChannel',
    allowedIpRanges: 'allowedIpRanges',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const PasswordResetTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tokenHash: 'tokenHash',
    expiresAt: 'expiresAt',
    used: 'used',
    createdAt: 'createdAt'
  };

  export type PasswordResetTokenScalarFieldEnum = (typeof PasswordResetTokenScalarFieldEnum)[keyof typeof PasswordResetTokenScalarFieldEnum]


  export const TwoFactorChallengeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    codeHash: 'codeHash',
    expiresAt: 'expiresAt',
    consumed: 'consumed',
    createdAt: 'createdAt'
  };

  export type TwoFactorChallengeScalarFieldEnum = (typeof TwoFactorChallengeScalarFieldEnum)[keyof typeof TwoFactorChallengeScalarFieldEnum]


  export const UserConsentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    consentType: 'consentType',
    status: 'status',
    metadata: 'metadata',
    recordedAt: 'recordedAt'
  };

  export type UserConsentScalarFieldEnum = (typeof UserConsentScalarFieldEnum)[keyof typeof UserConsentScalarFieldEnum]


  export const VendorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    baseRate: 'baseRate',
    rating: 'rating',
    speed: 'speed',
    isActive: 'isActive',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VendorScalarFieldEnum = (typeof VendorScalarFieldEnum)[keyof typeof VendorScalarFieldEnum]


  export const VendorProfileScalarFieldEnum: {
    id: 'id',
    vendorId: 'vendorId',
    legalName: 'legalName',
    gstin: 'gstin',
    pan: 'pan',
    tan: 'tan',
    addressLine1: 'addressLine1',
    addressLine2: 'addressLine2',
    city: 'city',
    state: 'state',
    postalCode: 'postalCode',
    country: 'country',
    rcmEligible: 'rcmEligible',
    gstRegistrationType: 'gstRegistrationType',
    contactPerson: 'contactPerson',
    contactEmail: 'contactEmail',
    contactPhone: 'contactPhone',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VendorProfileScalarFieldEnum = (typeof VendorProfileScalarFieldEnum)[keyof typeof VendorProfileScalarFieldEnum]


  export const DriverScalarFieldEnum: {
    id: 'id',
    vendorId: 'vendorId',
    name: 'name',
    phone: 'phone',
    licenseNumber: 'licenseNumber',
    vehicleNumber: 'vehicleNumber',
    notes: 'notes',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DriverScalarFieldEnum = (typeof DriverScalarFieldEnum)[keyof typeof DriverScalarFieldEnum]


  export const AgreementScalarFieldEnum: {
    id: 'id',
    vendorId: 'vendorId',
    title: 'title',
    referenceCode: 'referenceCode',
    status: 'status',
    effectiveFrom: 'effectiveFrom',
    effectiveTo: 'effectiveTo',
    notes: 'notes',
    reviewedById: 'reviewedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId'
  };

  export type AgreementScalarFieldEnum = (typeof AgreementScalarFieldEnum)[keyof typeof AgreementScalarFieldEnum]


  export const RateCardScalarFieldEnum: {
    id: 'id',
    agreementId: 'agreementId',
    routeName: 'routeName',
    origin: 'origin',
    destination: 'destination',
    distanceKm: 'distanceKm',
    ratePerKm: 'ratePerKm',
    uom: 'uom',
    vehicleType: 'vehicleType',
    effectiveFrom: 'effectiveFrom',
    remarks: 'remarks',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    vendorId: 'vendorId'
  };

  export type RateCardScalarFieldEnum = (typeof RateCardScalarFieldEnum)[keyof typeof RateCardScalarFieldEnum]


  export const QuoteRequestScalarFieldEnum: {
    id: 'id',
    createdByUserId: 'createdByUserId',
    fromLocation: 'fromLocation',
    toLocation: 'toLocation',
    fromLat: 'fromLat',
    fromLng: 'fromLng',
    toLat: 'toLat',
    toLng: 'toLng',
    weight: 'weight',
    shipmentType: 'shipmentType',
    urgency: 'urgency',
    status: 'status',
    notes: 'notes',
    approvedResponseId: 'approvedResponseId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuoteRequestScalarFieldEnum = (typeof QuoteRequestScalarFieldEnum)[keyof typeof QuoteRequestScalarFieldEnum]


  export const QuoteResponseScalarFieldEnum: {
    id: 'id',
    quoteRequestId: 'quoteRequestId',
    vendorId: 'vendorId',
    quotedPrice: 'quotedPrice',
    estimatedDelivery: 'estimatedDelivery',
    expiresAt: 'expiresAt',
    status: 'status',
    consentStatus: 'consentStatus',
    notes: 'notes',
    transporterNotes: 'transporterNotes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuoteResponseScalarFieldEnum = (typeof QuoteResponseScalarFieldEnum)[keyof typeof QuoteResponseScalarFieldEnum]


  export const ConsentLogScalarFieldEnum: {
    id: 'id',
    quoteResponseId: 'quoteResponseId',
    shipmentId: 'shipmentId',
    statusBefore: 'statusBefore',
    statusAfter: 'statusAfter',
    note: 'note',
    recordedAt: 'recordedAt'
  };

  export type ConsentLogScalarFieldEnum = (typeof ConsentLogScalarFieldEnum)[keyof typeof ConsentLogScalarFieldEnum]


  export const ShipmentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    companyId: 'companyId',
    quoteRequestId: 'quoteRequestId',
    transporterQuoteId: 'transporterQuoteId',
    selectedVendorId: 'selectedVendorId',
    agreementId: 'agreementId',
    rateCardId: 'rateCardId',
    trackingNumber: 'trackingNumber',
    fromLocation: 'fromLocation',
    toLocation: 'toLocation',
    fromLat: 'fromLat',
    fromLng: 'fromLng',
    toLat: 'toLat',
    toLng: 'toLng',
    weight: 'weight',
    shipmentType: 'shipmentType',
    urgency: 'urgency',
    status: 'status',
    bookingStatus: 'bookingStatus',
    paymentStatus: 'paymentStatus',
    cost: 'cost',
    distance: 'distance',
    estimatedDelivery: 'estimatedDelivery',
    pickupTime: 'pickupTime',
    deliveryTime: 'deliveryTime',
    assignedToId: 'assignedToId',
    assignedDriver: 'assignedDriver',
    driverPhone: 'driverPhone',
    driverEta: 'driverEta',
    transporterResponseNotes: 'transporterResponseNotes',
    notes: 'notes',
    ewayBillNumber: 'ewayBillNumber',
    gstInvoiceId: 'gstInvoiceId',
    complianceStatus: 'complianceStatus',
    source: 'source',
    podStatus: 'podStatus',
    podUrl: 'podUrl',
    podNotes: 'podNotes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShipmentScalarFieldEnum = (typeof ShipmentScalarFieldEnum)[keyof typeof ShipmentScalarFieldEnum]


  export const StatusHistoryScalarFieldEnum: {
    id: 'id',
    shipmentId: 'shipmentId',
    status: 'status',
    notes: 'notes',
    latitude: 'latitude',
    longitude: 'longitude',
    location: 'location',
    updatedBy: 'updatedBy',
    timestamp: 'timestamp'
  };

  export type StatusHistoryScalarFieldEnum = (typeof StatusHistoryScalarFieldEnum)[keyof typeof StatusHistoryScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    shipmentId: 'shipmentId',
    invoiceNumber: 'invoiceNumber',
    status: 'status',
    issuedAt: 'issuedAt',
    dueDate: 'dueDate',
    subtotal: 'subtotal',
    taxTotal: 'taxTotal',
    grandTotal: 'grandTotal',
    lineItems: 'lineItems',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    shipmentId: 'shipmentId',
    invoiceId: 'invoiceId',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    gateway: 'gateway',
    transactionRef: 'transactionRef',
    authorizedAt: 'authorizedAt',
    capturedAt: 'capturedAt',
    failureReason: 'failureReason',
    metadata: 'metadata',
    tdsAmount: 'tdsAmount',
    tcsAmount: 'tcsAmount',
    rcmLiability: 'rcmLiability',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const PaymentEventScalarFieldEnum: {
    id: 'id',
    paymentId: 'paymentId',
    eventType: 'eventType',
    details: 'details',
    recordedAt: 'recordedAt'
  };

  export type PaymentEventScalarFieldEnum = (typeof PaymentEventScalarFieldEnum)[keyof typeof PaymentEventScalarFieldEnum]


  export const TransporterInvoiceScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    shipmentId: 'shipmentId',
    invoiceNumber: 'invoiceNumber',
    invoiceDate: 'invoiceDate',
    invoiceAmount: 'invoiceAmount',
    invoiceUrl: 'invoiceUrl',
    approvalStatus: 'approvalStatus',
    rejectionNotes: 'rejectionNotes',
    postedToErpAt: 'postedToErpAt',
    approvedById: 'approvedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransporterInvoiceScalarFieldEnum = (typeof TransporterInvoiceScalarFieldEnum)[keyof typeof TransporterInvoiceScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    message: 'message',
    type: 'type',
    metadata: 'metadata',
    isRead: 'isRead',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    details: 'details',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const ComplianceDocumentScalarFieldEnum: {
    id: 'id',
    shipmentId: 'shipmentId',
    type: 'type',
    status: 'status',
    issuedAt: 'issuedAt',
    fileUrl: 'fileUrl',
    payload: 'payload',
    metadata: 'metadata',
    remarks: 'remarks',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ComplianceDocumentScalarFieldEnum = (typeof ComplianceDocumentScalarFieldEnum)[keyof typeof ComplianceDocumentScalarFieldEnum]


  export const ComplianceEventScalarFieldEnum: {
    id: 'id',
    documentId: 'documentId',
    eventType: 'eventType',
    details: 'details',
    recordedAt: 'recordedAt'
  };

  export type ComplianceEventScalarFieldEnum = (typeof ComplianceEventScalarFieldEnum)[keyof typeof ComplianceEventScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'ApprovalStatus'
   */
  export type EnumApprovalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApprovalStatus'>
    


  /**
   * Reference to a field of type 'ApprovalStatus[]'
   */
  export type ListEnumApprovalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApprovalStatus[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ConsentStatus'
   */
  export type EnumConsentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConsentStatus'>
    


  /**
   * Reference to a field of type 'ConsentStatus[]'
   */
  export type ListEnumConsentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConsentStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'QuoteStatus'
   */
  export type EnumQuoteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuoteStatus'>
    


  /**
   * Reference to a field of type 'QuoteStatus[]'
   */
  export type ListEnumQuoteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuoteStatus[]'>
    


  /**
   * Reference to a field of type 'QuoteResponseStatus'
   */
  export type EnumQuoteResponseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuoteResponseStatus'>
    


  /**
   * Reference to a field of type 'QuoteResponseStatus[]'
   */
  export type ListEnumQuoteResponseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuoteResponseStatus[]'>
    


  /**
   * Reference to a field of type 'ShipmentStatus'
   */
  export type EnumShipmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShipmentStatus'>
    


  /**
   * Reference to a field of type 'ShipmentStatus[]'
   */
  export type ListEnumShipmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShipmentStatus[]'>
    


  /**
   * Reference to a field of type 'BookingStatus'
   */
  export type EnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus'>
    


  /**
   * Reference to a field of type 'BookingStatus[]'
   */
  export type ListEnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'ComplianceStatus'
   */
  export type EnumComplianceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComplianceStatus'>
    


  /**
   * Reference to a field of type 'ComplianceStatus[]'
   */
  export type ListEnumComplianceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComplianceStatus[]'>
    


  /**
   * Reference to a field of type 'InvoiceStatus'
   */
  export type EnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus'>
    


  /**
   * Reference to a field of type 'InvoiceStatus[]'
   */
  export type ListEnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus[]'>
    


  /**
   * Reference to a field of type 'DocumentType'
   */
  export type EnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType'>
    


  /**
   * Reference to a field of type 'DocumentType[]'
   */
  export type ListEnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType[]'>
    
  /**
   * Deep Input Types
   */


  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: IntFilter<"Company"> | number
    name?: StringFilter<"Company"> | string
    webhookSecret?: StringFilter<"Company"> | string
    plan?: StringFilter<"Company"> | string
    subscriptionStatus?: StringFilter<"Company"> | string
    billingEmail?: StringNullableFilter<"Company"> | string | null
    billingCustomerId?: StringNullableFilter<"Company"> | string | null
    trialEndsAt?: DateTimeNullableFilter<"Company"> | Date | string | null
    settings?: JsonNullableFilter<"Company">
    status?: StringFilter<"Company"> | string
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    users?: UserListRelationFilter
    shipments?: ShipmentListRelationFilter
    agreements?: AgreementListRelationFilter
    transporterInvoices?: TransporterInvoiceListRelationFilter
    invoices?: InvoiceListRelationFilter
    profiles?: CompanyProfileListRelationFilter
    vendors?: VendorListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    webhookSecret?: SortOrder
    plan?: SortOrder
    subscriptionStatus?: SortOrder
    billingEmail?: SortOrderInput | SortOrder
    billingCustomerId?: SortOrderInput | SortOrder
    trialEndsAt?: SortOrderInput | SortOrder
    settings?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    shipments?: ShipmentOrderByRelationAggregateInput
    agreements?: AgreementOrderByRelationAggregateInput
    transporterInvoices?: TransporterInvoiceOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    profiles?: CompanyProfileOrderByRelationAggregateInput
    vendors?: VendorOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    name?: StringFilter<"Company"> | string
    webhookSecret?: StringFilter<"Company"> | string
    plan?: StringFilter<"Company"> | string
    subscriptionStatus?: StringFilter<"Company"> | string
    billingEmail?: StringNullableFilter<"Company"> | string | null
    billingCustomerId?: StringNullableFilter<"Company"> | string | null
    trialEndsAt?: DateTimeNullableFilter<"Company"> | Date | string | null
    settings?: JsonNullableFilter<"Company">
    status?: StringFilter<"Company"> | string
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    users?: UserListRelationFilter
    shipments?: ShipmentListRelationFilter
    agreements?: AgreementListRelationFilter
    transporterInvoices?: TransporterInvoiceListRelationFilter
    invoices?: InvoiceListRelationFilter
    profiles?: CompanyProfileListRelationFilter
    vendors?: VendorListRelationFilter
  }, "id">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    webhookSecret?: SortOrder
    plan?: SortOrder
    subscriptionStatus?: SortOrder
    billingEmail?: SortOrderInput | SortOrder
    billingCustomerId?: SortOrderInput | SortOrder
    trialEndsAt?: SortOrderInput | SortOrder
    settings?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _avg?: CompanyAvgOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
    _sum?: CompanySumOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Company"> | number
    name?: StringWithAggregatesFilter<"Company"> | string
    webhookSecret?: StringWithAggregatesFilter<"Company"> | string
    plan?: StringWithAggregatesFilter<"Company"> | string
    subscriptionStatus?: StringWithAggregatesFilter<"Company"> | string
    billingEmail?: StringNullableWithAggregatesFilter<"Company"> | string | null
    billingCustomerId?: StringNullableWithAggregatesFilter<"Company"> | string | null
    trialEndsAt?: DateTimeNullableWithAggregatesFilter<"Company"> | Date | string | null
    settings?: JsonNullableWithAggregatesFilter<"Company">
    status?: StringWithAggregatesFilter<"Company"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
  }

  export type CompanyProfileWhereInput = {
    AND?: CompanyProfileWhereInput | CompanyProfileWhereInput[]
    OR?: CompanyProfileWhereInput[]
    NOT?: CompanyProfileWhereInput | CompanyProfileWhereInput[]
    id?: IntFilter<"CompanyProfile"> | number
    companyId?: IntNullableFilter<"CompanyProfile"> | number | null
    legalName?: StringNullableFilter<"CompanyProfile"> | string | null
    gstin?: StringNullableFilter<"CompanyProfile"> | string | null
    pan?: StringNullableFilter<"CompanyProfile"> | string | null
    tan?: StringNullableFilter<"CompanyProfile"> | string | null
    addressLine1?: StringNullableFilter<"CompanyProfile"> | string | null
    addressLine2?: StringNullableFilter<"CompanyProfile"> | string | null
    city?: StringNullableFilter<"CompanyProfile"> | string | null
    state?: StringNullableFilter<"CompanyProfile"> | string | null
    postalCode?: StringNullableFilter<"CompanyProfile"> | string | null
    country?: StringNullableFilter<"CompanyProfile"> | string | null
    createdAt?: DateTimeFilter<"CompanyProfile"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyProfile"> | Date | string
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
  }

  export type CompanyProfileOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrderInput | SortOrder
    legalName?: SortOrderInput | SortOrder
    gstin?: SortOrderInput | SortOrder
    pan?: SortOrderInput | SortOrder
    tan?: SortOrderInput | SortOrder
    addressLine1?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type CompanyProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CompanyProfileWhereInput | CompanyProfileWhereInput[]
    OR?: CompanyProfileWhereInput[]
    NOT?: CompanyProfileWhereInput | CompanyProfileWhereInput[]
    companyId?: IntNullableFilter<"CompanyProfile"> | number | null
    legalName?: StringNullableFilter<"CompanyProfile"> | string | null
    gstin?: StringNullableFilter<"CompanyProfile"> | string | null
    pan?: StringNullableFilter<"CompanyProfile"> | string | null
    tan?: StringNullableFilter<"CompanyProfile"> | string | null
    addressLine1?: StringNullableFilter<"CompanyProfile"> | string | null
    addressLine2?: StringNullableFilter<"CompanyProfile"> | string | null
    city?: StringNullableFilter<"CompanyProfile"> | string | null
    state?: StringNullableFilter<"CompanyProfile"> | string | null
    postalCode?: StringNullableFilter<"CompanyProfile"> | string | null
    country?: StringNullableFilter<"CompanyProfile"> | string | null
    createdAt?: DateTimeFilter<"CompanyProfile"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyProfile"> | Date | string
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
  }, "id">

  export type CompanyProfileOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrderInput | SortOrder
    legalName?: SortOrderInput | SortOrder
    gstin?: SortOrderInput | SortOrder
    pan?: SortOrderInput | SortOrder
    tan?: SortOrderInput | SortOrder
    addressLine1?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyProfileCountOrderByAggregateInput
    _avg?: CompanyProfileAvgOrderByAggregateInput
    _max?: CompanyProfileMaxOrderByAggregateInput
    _min?: CompanyProfileMinOrderByAggregateInput
    _sum?: CompanyProfileSumOrderByAggregateInput
  }

  export type CompanyProfileScalarWhereWithAggregatesInput = {
    AND?: CompanyProfileScalarWhereWithAggregatesInput | CompanyProfileScalarWhereWithAggregatesInput[]
    OR?: CompanyProfileScalarWhereWithAggregatesInput[]
    NOT?: CompanyProfileScalarWhereWithAggregatesInput | CompanyProfileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CompanyProfile"> | number
    companyId?: IntNullableWithAggregatesFilter<"CompanyProfile"> | number | null
    legalName?: StringNullableWithAggregatesFilter<"CompanyProfile"> | string | null
    gstin?: StringNullableWithAggregatesFilter<"CompanyProfile"> | string | null
    pan?: StringNullableWithAggregatesFilter<"CompanyProfile"> | string | null
    tan?: StringNullableWithAggregatesFilter<"CompanyProfile"> | string | null
    addressLine1?: StringNullableWithAggregatesFilter<"CompanyProfile"> | string | null
    addressLine2?: StringNullableWithAggregatesFilter<"CompanyProfile"> | string | null
    city?: StringNullableWithAggregatesFilter<"CompanyProfile"> | string | null
    state?: StringNullableWithAggregatesFilter<"CompanyProfile"> | string | null
    postalCode?: StringNullableWithAggregatesFilter<"CompanyProfile"> | string | null
    country?: StringNullableWithAggregatesFilter<"CompanyProfile"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CompanyProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CompanyProfile"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    approvalStatus?: EnumApprovalStatusFilter<"User"> | $Enums.ApprovalStatus
    approvalNote?: StringNullableFilter<"User"> | string | null
    rejectionReason?: StringNullableFilter<"User"> | string | null
    reviewedById?: IntNullableFilter<"User"> | number | null
    reviewedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isActive?: BoolFilter<"User"> | boolean
    vendorId?: IntNullableFilter<"User"> | number | null
    companyId?: IntNullableFilter<"User"> | number | null
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    notificationPreferences?: JsonNullableFilter<"User">
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorChannel?: StringNullableFilter<"User"> | string | null
    allowedIpRanges?: JsonNullableFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
    vendor?: XOR<VendorNullableRelationFilter, VendorWhereInput> | null
    shipments?: ShipmentListRelationFilter
    assignedShipments?: ShipmentListRelationFilter
    notifications?: NotificationListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    agreementsReviewed?: AgreementListRelationFilter
    transporterInvoices?: TransporterInvoiceListRelationFilter
    QuoteRequest?: QuoteRequestListRelationFilter
    passwordResetTokens?: PasswordResetTokenListRelationFilter
    twoFactorChallenges?: TwoFactorChallengeListRelationFilter
    userConsents?: UserConsentListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    role?: SortOrder
    approvalStatus?: SortOrder
    approvalNote?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    reviewedById?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    vendorId?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    notificationPreferences?: SortOrderInput | SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorChannel?: SortOrderInput | SortOrder
    allowedIpRanges?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    vendor?: VendorOrderByWithRelationInput
    shipments?: ShipmentOrderByRelationAggregateInput
    assignedShipments?: ShipmentOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    agreementsReviewed?: AgreementOrderByRelationAggregateInput
    transporterInvoices?: TransporterInvoiceOrderByRelationAggregateInput
    QuoteRequest?: QuoteRequestOrderByRelationAggregateInput
    passwordResetTokens?: PasswordResetTokenOrderByRelationAggregateInput
    twoFactorChallenges?: TwoFactorChallengeOrderByRelationAggregateInput
    userConsents?: UserConsentOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    approvalStatus?: EnumApprovalStatusFilter<"User"> | $Enums.ApprovalStatus
    approvalNote?: StringNullableFilter<"User"> | string | null
    rejectionReason?: StringNullableFilter<"User"> | string | null
    reviewedById?: IntNullableFilter<"User"> | number | null
    reviewedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isActive?: BoolFilter<"User"> | boolean
    vendorId?: IntNullableFilter<"User"> | number | null
    companyId?: IntNullableFilter<"User"> | number | null
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    notificationPreferences?: JsonNullableFilter<"User">
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorChannel?: StringNullableFilter<"User"> | string | null
    allowedIpRanges?: JsonNullableFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
    vendor?: XOR<VendorNullableRelationFilter, VendorWhereInput> | null
    shipments?: ShipmentListRelationFilter
    assignedShipments?: ShipmentListRelationFilter
    notifications?: NotificationListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    agreementsReviewed?: AgreementListRelationFilter
    transporterInvoices?: TransporterInvoiceListRelationFilter
    QuoteRequest?: QuoteRequestListRelationFilter
    passwordResetTokens?: PasswordResetTokenListRelationFilter
    twoFactorChallenges?: TwoFactorChallengeListRelationFilter
    userConsents?: UserConsentListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    role?: SortOrder
    approvalStatus?: SortOrder
    approvalNote?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    reviewedById?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    vendorId?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    notificationPreferences?: SortOrderInput | SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorChannel?: SortOrderInput | SortOrder
    allowedIpRanges?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    approvalStatus?: EnumApprovalStatusWithAggregatesFilter<"User"> | $Enums.ApprovalStatus
    approvalNote?: StringNullableWithAggregatesFilter<"User"> | string | null
    rejectionReason?: StringNullableWithAggregatesFilter<"User"> | string | null
    reviewedById?: IntNullableWithAggregatesFilter<"User"> | number | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    vendorId?: IntNullableWithAggregatesFilter<"User"> | number | null
    companyId?: IntNullableWithAggregatesFilter<"User"> | number | null
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    notificationPreferences?: JsonNullableWithAggregatesFilter<"User">
    twoFactorEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    twoFactorChannel?: StringNullableWithAggregatesFilter<"User"> | string | null
    allowedIpRanges?: JsonNullableWithAggregatesFilter<"User">
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type PasswordResetTokenWhereInput = {
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    id?: IntFilter<"PasswordResetToken"> | number
    userId?: IntFilter<"PasswordResetToken"> | number
    tokenHash?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    used?: BoolFilter<"PasswordResetToken"> | boolean
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PasswordResetTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PasswordResetTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    tokenHash?: string
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    userId?: IntFilter<"PasswordResetToken"> | number
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    used?: BoolFilter<"PasswordResetToken"> | boolean
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "tokenHash">

  export type PasswordResetTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
    _count?: PasswordResetTokenCountOrderByAggregateInput
    _avg?: PasswordResetTokenAvgOrderByAggregateInput
    _max?: PasswordResetTokenMaxOrderByAggregateInput
    _min?: PasswordResetTokenMinOrderByAggregateInput
    _sum?: PasswordResetTokenSumOrderByAggregateInput
  }

  export type PasswordResetTokenScalarWhereWithAggregatesInput = {
    AND?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    OR?: PasswordResetTokenScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PasswordResetToken"> | number
    userId?: IntWithAggregatesFilter<"PasswordResetToken"> | number
    tokenHash?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
    used?: BoolWithAggregatesFilter<"PasswordResetToken"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
  }

  export type TwoFactorChallengeWhereInput = {
    AND?: TwoFactorChallengeWhereInput | TwoFactorChallengeWhereInput[]
    OR?: TwoFactorChallengeWhereInput[]
    NOT?: TwoFactorChallengeWhereInput | TwoFactorChallengeWhereInput[]
    id?: IntFilter<"TwoFactorChallenge"> | number
    userId?: IntFilter<"TwoFactorChallenge"> | number
    codeHash?: StringFilter<"TwoFactorChallenge"> | string
    expiresAt?: DateTimeFilter<"TwoFactorChallenge"> | Date | string
    consumed?: BoolFilter<"TwoFactorChallenge"> | boolean
    createdAt?: DateTimeFilter<"TwoFactorChallenge"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TwoFactorChallengeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    codeHash?: SortOrder
    expiresAt?: SortOrder
    consumed?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TwoFactorChallengeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TwoFactorChallengeWhereInput | TwoFactorChallengeWhereInput[]
    OR?: TwoFactorChallengeWhereInput[]
    NOT?: TwoFactorChallengeWhereInput | TwoFactorChallengeWhereInput[]
    userId?: IntFilter<"TwoFactorChallenge"> | number
    codeHash?: StringFilter<"TwoFactorChallenge"> | string
    expiresAt?: DateTimeFilter<"TwoFactorChallenge"> | Date | string
    consumed?: BoolFilter<"TwoFactorChallenge"> | boolean
    createdAt?: DateTimeFilter<"TwoFactorChallenge"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type TwoFactorChallengeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    codeHash?: SortOrder
    expiresAt?: SortOrder
    consumed?: SortOrder
    createdAt?: SortOrder
    _count?: TwoFactorChallengeCountOrderByAggregateInput
    _avg?: TwoFactorChallengeAvgOrderByAggregateInput
    _max?: TwoFactorChallengeMaxOrderByAggregateInput
    _min?: TwoFactorChallengeMinOrderByAggregateInput
    _sum?: TwoFactorChallengeSumOrderByAggregateInput
  }

  export type TwoFactorChallengeScalarWhereWithAggregatesInput = {
    AND?: TwoFactorChallengeScalarWhereWithAggregatesInput | TwoFactorChallengeScalarWhereWithAggregatesInput[]
    OR?: TwoFactorChallengeScalarWhereWithAggregatesInput[]
    NOT?: TwoFactorChallengeScalarWhereWithAggregatesInput | TwoFactorChallengeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TwoFactorChallenge"> | number
    userId?: IntWithAggregatesFilter<"TwoFactorChallenge"> | number
    codeHash?: StringWithAggregatesFilter<"TwoFactorChallenge"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"TwoFactorChallenge"> | Date | string
    consumed?: BoolWithAggregatesFilter<"TwoFactorChallenge"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TwoFactorChallenge"> | Date | string
  }

  export type UserConsentWhereInput = {
    AND?: UserConsentWhereInput | UserConsentWhereInput[]
    OR?: UserConsentWhereInput[]
    NOT?: UserConsentWhereInput | UserConsentWhereInput[]
    id?: IntFilter<"UserConsent"> | number
    userId?: IntFilter<"UserConsent"> | number
    consentType?: StringFilter<"UserConsent"> | string
    status?: EnumConsentStatusFilter<"UserConsent"> | $Enums.ConsentStatus
    metadata?: JsonNullableFilter<"UserConsent">
    recordedAt?: DateTimeFilter<"UserConsent"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserConsentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    consentType?: SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    recordedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserConsentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserConsentWhereInput | UserConsentWhereInput[]
    OR?: UserConsentWhereInput[]
    NOT?: UserConsentWhereInput | UserConsentWhereInput[]
    userId?: IntFilter<"UserConsent"> | number
    consentType?: StringFilter<"UserConsent"> | string
    status?: EnumConsentStatusFilter<"UserConsent"> | $Enums.ConsentStatus
    metadata?: JsonNullableFilter<"UserConsent">
    recordedAt?: DateTimeFilter<"UserConsent"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type UserConsentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    consentType?: SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    recordedAt?: SortOrder
    _count?: UserConsentCountOrderByAggregateInput
    _avg?: UserConsentAvgOrderByAggregateInput
    _max?: UserConsentMaxOrderByAggregateInput
    _min?: UserConsentMinOrderByAggregateInput
    _sum?: UserConsentSumOrderByAggregateInput
  }

  export type UserConsentScalarWhereWithAggregatesInput = {
    AND?: UserConsentScalarWhereWithAggregatesInput | UserConsentScalarWhereWithAggregatesInput[]
    OR?: UserConsentScalarWhereWithAggregatesInput[]
    NOT?: UserConsentScalarWhereWithAggregatesInput | UserConsentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserConsent"> | number
    userId?: IntWithAggregatesFilter<"UserConsent"> | number
    consentType?: StringWithAggregatesFilter<"UserConsent"> | string
    status?: EnumConsentStatusWithAggregatesFilter<"UserConsent"> | $Enums.ConsentStatus
    metadata?: JsonNullableWithAggregatesFilter<"UserConsent">
    recordedAt?: DateTimeWithAggregatesFilter<"UserConsent"> | Date | string
  }

  export type VendorWhereInput = {
    AND?: VendorWhereInput | VendorWhereInput[]
    OR?: VendorWhereInput[]
    NOT?: VendorWhereInput | VendorWhereInput[]
    id?: IntFilter<"Vendor"> | number
    name?: StringFilter<"Vendor"> | string
    email?: StringNullableFilter<"Vendor"> | string | null
    phone?: StringNullableFilter<"Vendor"> | string | null
    baseRate?: FloatNullableFilter<"Vendor"> | number | null
    rating?: FloatNullableFilter<"Vendor"> | number | null
    speed?: FloatNullableFilter<"Vendor"> | number | null
    isActive?: BoolFilter<"Vendor"> | boolean
    companyId?: IntNullableFilter<"Vendor"> | number | null
    createdAt?: DateTimeFilter<"Vendor"> | Date | string
    updatedAt?: DateTimeFilter<"Vendor"> | Date | string
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
    profile?: XOR<VendorProfileNullableRelationFilter, VendorProfileWhereInput> | null
    agreements?: AgreementListRelationFilter
    rateCards?: RateCardListRelationFilter
    quoteResponses?: QuoteResponseListRelationFilter
    shipments?: ShipmentListRelationFilter
    drivers?: DriverListRelationFilter
    User?: UserListRelationFilter
  }

  export type VendorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    baseRate?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    speed?: SortOrderInput | SortOrder
    isActive?: SortOrder
    companyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    profile?: VendorProfileOrderByWithRelationInput
    agreements?: AgreementOrderByRelationAggregateInput
    rateCards?: RateCardOrderByRelationAggregateInput
    quoteResponses?: QuoteResponseOrderByRelationAggregateInput
    shipments?: ShipmentOrderByRelationAggregateInput
    drivers?: DriverOrderByRelationAggregateInput
    User?: UserOrderByRelationAggregateInput
  }

  export type VendorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VendorWhereInput | VendorWhereInput[]
    OR?: VendorWhereInput[]
    NOT?: VendorWhereInput | VendorWhereInput[]
    name?: StringFilter<"Vendor"> | string
    email?: StringNullableFilter<"Vendor"> | string | null
    phone?: StringNullableFilter<"Vendor"> | string | null
    baseRate?: FloatNullableFilter<"Vendor"> | number | null
    rating?: FloatNullableFilter<"Vendor"> | number | null
    speed?: FloatNullableFilter<"Vendor"> | number | null
    isActive?: BoolFilter<"Vendor"> | boolean
    companyId?: IntNullableFilter<"Vendor"> | number | null
    createdAt?: DateTimeFilter<"Vendor"> | Date | string
    updatedAt?: DateTimeFilter<"Vendor"> | Date | string
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
    profile?: XOR<VendorProfileNullableRelationFilter, VendorProfileWhereInput> | null
    agreements?: AgreementListRelationFilter
    rateCards?: RateCardListRelationFilter
    quoteResponses?: QuoteResponseListRelationFilter
    shipments?: ShipmentListRelationFilter
    drivers?: DriverListRelationFilter
    User?: UserListRelationFilter
  }, "id">

  export type VendorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    baseRate?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    speed?: SortOrderInput | SortOrder
    isActive?: SortOrder
    companyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VendorCountOrderByAggregateInput
    _avg?: VendorAvgOrderByAggregateInput
    _max?: VendorMaxOrderByAggregateInput
    _min?: VendorMinOrderByAggregateInput
    _sum?: VendorSumOrderByAggregateInput
  }

  export type VendorScalarWhereWithAggregatesInput = {
    AND?: VendorScalarWhereWithAggregatesInput | VendorScalarWhereWithAggregatesInput[]
    OR?: VendorScalarWhereWithAggregatesInput[]
    NOT?: VendorScalarWhereWithAggregatesInput | VendorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Vendor"> | number
    name?: StringWithAggregatesFilter<"Vendor"> | string
    email?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    baseRate?: FloatNullableWithAggregatesFilter<"Vendor"> | number | null
    rating?: FloatNullableWithAggregatesFilter<"Vendor"> | number | null
    speed?: FloatNullableWithAggregatesFilter<"Vendor"> | number | null
    isActive?: BoolWithAggregatesFilter<"Vendor"> | boolean
    companyId?: IntNullableWithAggregatesFilter<"Vendor"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Vendor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Vendor"> | Date | string
  }

  export type VendorProfileWhereInput = {
    AND?: VendorProfileWhereInput | VendorProfileWhereInput[]
    OR?: VendorProfileWhereInput[]
    NOT?: VendorProfileWhereInput | VendorProfileWhereInput[]
    id?: IntFilter<"VendorProfile"> | number
    vendorId?: IntFilter<"VendorProfile"> | number
    legalName?: StringNullableFilter<"VendorProfile"> | string | null
    gstin?: StringNullableFilter<"VendorProfile"> | string | null
    pan?: StringNullableFilter<"VendorProfile"> | string | null
    tan?: StringNullableFilter<"VendorProfile"> | string | null
    addressLine1?: StringNullableFilter<"VendorProfile"> | string | null
    addressLine2?: StringNullableFilter<"VendorProfile"> | string | null
    city?: StringNullableFilter<"VendorProfile"> | string | null
    state?: StringNullableFilter<"VendorProfile"> | string | null
    postalCode?: StringNullableFilter<"VendorProfile"> | string | null
    country?: StringNullableFilter<"VendorProfile"> | string | null
    rcmEligible?: BoolFilter<"VendorProfile"> | boolean
    gstRegistrationType?: StringNullableFilter<"VendorProfile"> | string | null
    contactPerson?: StringNullableFilter<"VendorProfile"> | string | null
    contactEmail?: StringNullableFilter<"VendorProfile"> | string | null
    contactPhone?: StringNullableFilter<"VendorProfile"> | string | null
    createdAt?: DateTimeFilter<"VendorProfile"> | Date | string
    updatedAt?: DateTimeFilter<"VendorProfile"> | Date | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
  }

  export type VendorProfileOrderByWithRelationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    legalName?: SortOrderInput | SortOrder
    gstin?: SortOrderInput | SortOrder
    pan?: SortOrderInput | SortOrder
    tan?: SortOrderInput | SortOrder
    addressLine1?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    rcmEligible?: SortOrder
    gstRegistrationType?: SortOrderInput | SortOrder
    contactPerson?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendor?: VendorOrderByWithRelationInput
  }

  export type VendorProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    vendorId?: number
    gstin?: string
    AND?: VendorProfileWhereInput | VendorProfileWhereInput[]
    OR?: VendorProfileWhereInput[]
    NOT?: VendorProfileWhereInput | VendorProfileWhereInput[]
    legalName?: StringNullableFilter<"VendorProfile"> | string | null
    pan?: StringNullableFilter<"VendorProfile"> | string | null
    tan?: StringNullableFilter<"VendorProfile"> | string | null
    addressLine1?: StringNullableFilter<"VendorProfile"> | string | null
    addressLine2?: StringNullableFilter<"VendorProfile"> | string | null
    city?: StringNullableFilter<"VendorProfile"> | string | null
    state?: StringNullableFilter<"VendorProfile"> | string | null
    postalCode?: StringNullableFilter<"VendorProfile"> | string | null
    country?: StringNullableFilter<"VendorProfile"> | string | null
    rcmEligible?: BoolFilter<"VendorProfile"> | boolean
    gstRegistrationType?: StringNullableFilter<"VendorProfile"> | string | null
    contactPerson?: StringNullableFilter<"VendorProfile"> | string | null
    contactEmail?: StringNullableFilter<"VendorProfile"> | string | null
    contactPhone?: StringNullableFilter<"VendorProfile"> | string | null
    createdAt?: DateTimeFilter<"VendorProfile"> | Date | string
    updatedAt?: DateTimeFilter<"VendorProfile"> | Date | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
  }, "id" | "vendorId" | "gstin">

  export type VendorProfileOrderByWithAggregationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    legalName?: SortOrderInput | SortOrder
    gstin?: SortOrderInput | SortOrder
    pan?: SortOrderInput | SortOrder
    tan?: SortOrderInput | SortOrder
    addressLine1?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    rcmEligible?: SortOrder
    gstRegistrationType?: SortOrderInput | SortOrder
    contactPerson?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VendorProfileCountOrderByAggregateInput
    _avg?: VendorProfileAvgOrderByAggregateInput
    _max?: VendorProfileMaxOrderByAggregateInput
    _min?: VendorProfileMinOrderByAggregateInput
    _sum?: VendorProfileSumOrderByAggregateInput
  }

  export type VendorProfileScalarWhereWithAggregatesInput = {
    AND?: VendorProfileScalarWhereWithAggregatesInput | VendorProfileScalarWhereWithAggregatesInput[]
    OR?: VendorProfileScalarWhereWithAggregatesInput[]
    NOT?: VendorProfileScalarWhereWithAggregatesInput | VendorProfileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"VendorProfile"> | number
    vendorId?: IntWithAggregatesFilter<"VendorProfile"> | number
    legalName?: StringNullableWithAggregatesFilter<"VendorProfile"> | string | null
    gstin?: StringNullableWithAggregatesFilter<"VendorProfile"> | string | null
    pan?: StringNullableWithAggregatesFilter<"VendorProfile"> | string | null
    tan?: StringNullableWithAggregatesFilter<"VendorProfile"> | string | null
    addressLine1?: StringNullableWithAggregatesFilter<"VendorProfile"> | string | null
    addressLine2?: StringNullableWithAggregatesFilter<"VendorProfile"> | string | null
    city?: StringNullableWithAggregatesFilter<"VendorProfile"> | string | null
    state?: StringNullableWithAggregatesFilter<"VendorProfile"> | string | null
    postalCode?: StringNullableWithAggregatesFilter<"VendorProfile"> | string | null
    country?: StringNullableWithAggregatesFilter<"VendorProfile"> | string | null
    rcmEligible?: BoolWithAggregatesFilter<"VendorProfile"> | boolean
    gstRegistrationType?: StringNullableWithAggregatesFilter<"VendorProfile"> | string | null
    contactPerson?: StringNullableWithAggregatesFilter<"VendorProfile"> | string | null
    contactEmail?: StringNullableWithAggregatesFilter<"VendorProfile"> | string | null
    contactPhone?: StringNullableWithAggregatesFilter<"VendorProfile"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"VendorProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VendorProfile"> | Date | string
  }

  export type DriverWhereInput = {
    AND?: DriverWhereInput | DriverWhereInput[]
    OR?: DriverWhereInput[]
    NOT?: DriverWhereInput | DriverWhereInput[]
    id?: IntFilter<"Driver"> | number
    vendorId?: IntFilter<"Driver"> | number
    name?: StringFilter<"Driver"> | string
    phone?: StringNullableFilter<"Driver"> | string | null
    licenseNumber?: StringNullableFilter<"Driver"> | string | null
    vehicleNumber?: StringNullableFilter<"Driver"> | string | null
    notes?: StringNullableFilter<"Driver"> | string | null
    isActive?: BoolFilter<"Driver"> | boolean
    createdAt?: DateTimeFilter<"Driver"> | Date | string
    updatedAt?: DateTimeFilter<"Driver"> | Date | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
  }

  export type DriverOrderByWithRelationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    licenseNumber?: SortOrderInput | SortOrder
    vehicleNumber?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendor?: VendorOrderByWithRelationInput
  }

  export type DriverWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DriverWhereInput | DriverWhereInput[]
    OR?: DriverWhereInput[]
    NOT?: DriverWhereInput | DriverWhereInput[]
    vendorId?: IntFilter<"Driver"> | number
    name?: StringFilter<"Driver"> | string
    phone?: StringNullableFilter<"Driver"> | string | null
    licenseNumber?: StringNullableFilter<"Driver"> | string | null
    vehicleNumber?: StringNullableFilter<"Driver"> | string | null
    notes?: StringNullableFilter<"Driver"> | string | null
    isActive?: BoolFilter<"Driver"> | boolean
    createdAt?: DateTimeFilter<"Driver"> | Date | string
    updatedAt?: DateTimeFilter<"Driver"> | Date | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
  }, "id">

  export type DriverOrderByWithAggregationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    licenseNumber?: SortOrderInput | SortOrder
    vehicleNumber?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DriverCountOrderByAggregateInput
    _avg?: DriverAvgOrderByAggregateInput
    _max?: DriverMaxOrderByAggregateInput
    _min?: DriverMinOrderByAggregateInput
    _sum?: DriverSumOrderByAggregateInput
  }

  export type DriverScalarWhereWithAggregatesInput = {
    AND?: DriverScalarWhereWithAggregatesInput | DriverScalarWhereWithAggregatesInput[]
    OR?: DriverScalarWhereWithAggregatesInput[]
    NOT?: DriverScalarWhereWithAggregatesInput | DriverScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Driver"> | number
    vendorId?: IntWithAggregatesFilter<"Driver"> | number
    name?: StringWithAggregatesFilter<"Driver"> | string
    phone?: StringNullableWithAggregatesFilter<"Driver"> | string | null
    licenseNumber?: StringNullableWithAggregatesFilter<"Driver"> | string | null
    vehicleNumber?: StringNullableWithAggregatesFilter<"Driver"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Driver"> | string | null
    isActive?: BoolWithAggregatesFilter<"Driver"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Driver"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Driver"> | Date | string
  }

  export type AgreementWhereInput = {
    AND?: AgreementWhereInput | AgreementWhereInput[]
    OR?: AgreementWhereInput[]
    NOT?: AgreementWhereInput | AgreementWhereInput[]
    id?: IntFilter<"Agreement"> | number
    vendorId?: IntFilter<"Agreement"> | number
    title?: StringFilter<"Agreement"> | string
    referenceCode?: StringFilter<"Agreement"> | string
    status?: StringFilter<"Agreement"> | string
    effectiveFrom?: DateTimeNullableFilter<"Agreement"> | Date | string | null
    effectiveTo?: DateTimeNullableFilter<"Agreement"> | Date | string | null
    notes?: StringNullableFilter<"Agreement"> | string | null
    reviewedById?: IntNullableFilter<"Agreement"> | number | null
    createdAt?: DateTimeFilter<"Agreement"> | Date | string
    updatedAt?: DateTimeFilter<"Agreement"> | Date | string
    companyId?: IntNullableFilter<"Agreement"> | number | null
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    reviewedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    rateCards?: RateCardListRelationFilter
    Company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
  }

  export type AgreementOrderByWithRelationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    title?: SortOrder
    referenceCode?: SortOrder
    status?: SortOrder
    effectiveFrom?: SortOrderInput | SortOrder
    effectiveTo?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    reviewedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrderInput | SortOrder
    vendor?: VendorOrderByWithRelationInput
    reviewedBy?: UserOrderByWithRelationInput
    rateCards?: RateCardOrderByRelationAggregateInput
    Company?: CompanyOrderByWithRelationInput
  }

  export type AgreementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    referenceCode?: string
    AND?: AgreementWhereInput | AgreementWhereInput[]
    OR?: AgreementWhereInput[]
    NOT?: AgreementWhereInput | AgreementWhereInput[]
    vendorId?: IntFilter<"Agreement"> | number
    title?: StringFilter<"Agreement"> | string
    status?: StringFilter<"Agreement"> | string
    effectiveFrom?: DateTimeNullableFilter<"Agreement"> | Date | string | null
    effectiveTo?: DateTimeNullableFilter<"Agreement"> | Date | string | null
    notes?: StringNullableFilter<"Agreement"> | string | null
    reviewedById?: IntNullableFilter<"Agreement"> | number | null
    createdAt?: DateTimeFilter<"Agreement"> | Date | string
    updatedAt?: DateTimeFilter<"Agreement"> | Date | string
    companyId?: IntNullableFilter<"Agreement"> | number | null
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    reviewedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    rateCards?: RateCardListRelationFilter
    Company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
  }, "id" | "referenceCode">

  export type AgreementOrderByWithAggregationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    title?: SortOrder
    referenceCode?: SortOrder
    status?: SortOrder
    effectiveFrom?: SortOrderInput | SortOrder
    effectiveTo?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    reviewedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrderInput | SortOrder
    _count?: AgreementCountOrderByAggregateInput
    _avg?: AgreementAvgOrderByAggregateInput
    _max?: AgreementMaxOrderByAggregateInput
    _min?: AgreementMinOrderByAggregateInput
    _sum?: AgreementSumOrderByAggregateInput
  }

  export type AgreementScalarWhereWithAggregatesInput = {
    AND?: AgreementScalarWhereWithAggregatesInput | AgreementScalarWhereWithAggregatesInput[]
    OR?: AgreementScalarWhereWithAggregatesInput[]
    NOT?: AgreementScalarWhereWithAggregatesInput | AgreementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Agreement"> | number
    vendorId?: IntWithAggregatesFilter<"Agreement"> | number
    title?: StringWithAggregatesFilter<"Agreement"> | string
    referenceCode?: StringWithAggregatesFilter<"Agreement"> | string
    status?: StringWithAggregatesFilter<"Agreement"> | string
    effectiveFrom?: DateTimeNullableWithAggregatesFilter<"Agreement"> | Date | string | null
    effectiveTo?: DateTimeNullableWithAggregatesFilter<"Agreement"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"Agreement"> | string | null
    reviewedById?: IntNullableWithAggregatesFilter<"Agreement"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Agreement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Agreement"> | Date | string
    companyId?: IntNullableWithAggregatesFilter<"Agreement"> | number | null
  }

  export type RateCardWhereInput = {
    AND?: RateCardWhereInput | RateCardWhereInput[]
    OR?: RateCardWhereInput[]
    NOT?: RateCardWhereInput | RateCardWhereInput[]
    id?: IntFilter<"RateCard"> | number
    agreementId?: IntFilter<"RateCard"> | number
    routeName?: StringFilter<"RateCard"> | string
    origin?: StringFilter<"RateCard"> | string
    destination?: StringFilter<"RateCard"> | string
    distanceKm?: FloatNullableFilter<"RateCard"> | number | null
    ratePerKm?: FloatFilter<"RateCard"> | number
    uom?: StringFilter<"RateCard"> | string
    vehicleType?: StringFilter<"RateCard"> | string
    effectiveFrom?: DateTimeNullableFilter<"RateCard"> | Date | string | null
    remarks?: StringNullableFilter<"RateCard"> | string | null
    createdAt?: DateTimeFilter<"RateCard"> | Date | string
    updatedAt?: DateTimeFilter<"RateCard"> | Date | string
    vendorId?: IntNullableFilter<"RateCard"> | number | null
    agreement?: XOR<AgreementRelationFilter, AgreementWhereInput>
    Vendor?: XOR<VendorNullableRelationFilter, VendorWhereInput> | null
    shipments?: ShipmentListRelationFilter
  }

  export type RateCardOrderByWithRelationInput = {
    id?: SortOrder
    agreementId?: SortOrder
    routeName?: SortOrder
    origin?: SortOrder
    destination?: SortOrder
    distanceKm?: SortOrderInput | SortOrder
    ratePerKm?: SortOrder
    uom?: SortOrder
    vehicleType?: SortOrder
    effectiveFrom?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendorId?: SortOrderInput | SortOrder
    agreement?: AgreementOrderByWithRelationInput
    Vendor?: VendorOrderByWithRelationInput
    shipments?: ShipmentOrderByRelationAggregateInput
  }

  export type RateCardWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RateCardWhereInput | RateCardWhereInput[]
    OR?: RateCardWhereInput[]
    NOT?: RateCardWhereInput | RateCardWhereInput[]
    agreementId?: IntFilter<"RateCard"> | number
    routeName?: StringFilter<"RateCard"> | string
    origin?: StringFilter<"RateCard"> | string
    destination?: StringFilter<"RateCard"> | string
    distanceKm?: FloatNullableFilter<"RateCard"> | number | null
    ratePerKm?: FloatFilter<"RateCard"> | number
    uom?: StringFilter<"RateCard"> | string
    vehicleType?: StringFilter<"RateCard"> | string
    effectiveFrom?: DateTimeNullableFilter<"RateCard"> | Date | string | null
    remarks?: StringNullableFilter<"RateCard"> | string | null
    createdAt?: DateTimeFilter<"RateCard"> | Date | string
    updatedAt?: DateTimeFilter<"RateCard"> | Date | string
    vendorId?: IntNullableFilter<"RateCard"> | number | null
    agreement?: XOR<AgreementRelationFilter, AgreementWhereInput>
    Vendor?: XOR<VendorNullableRelationFilter, VendorWhereInput> | null
    shipments?: ShipmentListRelationFilter
  }, "id">

  export type RateCardOrderByWithAggregationInput = {
    id?: SortOrder
    agreementId?: SortOrder
    routeName?: SortOrder
    origin?: SortOrder
    destination?: SortOrder
    distanceKm?: SortOrderInput | SortOrder
    ratePerKm?: SortOrder
    uom?: SortOrder
    vehicleType?: SortOrder
    effectiveFrom?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendorId?: SortOrderInput | SortOrder
    _count?: RateCardCountOrderByAggregateInput
    _avg?: RateCardAvgOrderByAggregateInput
    _max?: RateCardMaxOrderByAggregateInput
    _min?: RateCardMinOrderByAggregateInput
    _sum?: RateCardSumOrderByAggregateInput
  }

  export type RateCardScalarWhereWithAggregatesInput = {
    AND?: RateCardScalarWhereWithAggregatesInput | RateCardScalarWhereWithAggregatesInput[]
    OR?: RateCardScalarWhereWithAggregatesInput[]
    NOT?: RateCardScalarWhereWithAggregatesInput | RateCardScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RateCard"> | number
    agreementId?: IntWithAggregatesFilter<"RateCard"> | number
    routeName?: StringWithAggregatesFilter<"RateCard"> | string
    origin?: StringWithAggregatesFilter<"RateCard"> | string
    destination?: StringWithAggregatesFilter<"RateCard"> | string
    distanceKm?: FloatNullableWithAggregatesFilter<"RateCard"> | number | null
    ratePerKm?: FloatWithAggregatesFilter<"RateCard"> | number
    uom?: StringWithAggregatesFilter<"RateCard"> | string
    vehicleType?: StringWithAggregatesFilter<"RateCard"> | string
    effectiveFrom?: DateTimeNullableWithAggregatesFilter<"RateCard"> | Date | string | null
    remarks?: StringNullableWithAggregatesFilter<"RateCard"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RateCard"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RateCard"> | Date | string
    vendorId?: IntNullableWithAggregatesFilter<"RateCard"> | number | null
  }

  export type QuoteRequestWhereInput = {
    AND?: QuoteRequestWhereInput | QuoteRequestWhereInput[]
    OR?: QuoteRequestWhereInput[]
    NOT?: QuoteRequestWhereInput | QuoteRequestWhereInput[]
    id?: IntFilter<"QuoteRequest"> | number
    createdByUserId?: IntFilter<"QuoteRequest"> | number
    fromLocation?: StringFilter<"QuoteRequest"> | string
    toLocation?: StringFilter<"QuoteRequest"> | string
    fromLat?: FloatNullableFilter<"QuoteRequest"> | number | null
    fromLng?: FloatNullableFilter<"QuoteRequest"> | number | null
    toLat?: FloatNullableFilter<"QuoteRequest"> | number | null
    toLng?: FloatNullableFilter<"QuoteRequest"> | number | null
    weight?: FloatNullableFilter<"QuoteRequest"> | number | null
    shipmentType?: StringNullableFilter<"QuoteRequest"> | string | null
    urgency?: StringNullableFilter<"QuoteRequest"> | string | null
    status?: EnumQuoteStatusFilter<"QuoteRequest"> | $Enums.QuoteStatus
    notes?: StringNullableFilter<"QuoteRequest"> | string | null
    approvedResponseId?: IntNullableFilter<"QuoteRequest"> | number | null
    createdAt?: DateTimeFilter<"QuoteRequest"> | Date | string
    updatedAt?: DateTimeFilter<"QuoteRequest"> | Date | string
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    responses?: QuoteResponseListRelationFilter
    approvedResponse?: XOR<QuoteResponseNullableRelationFilter, QuoteResponseWhereInput> | null
    shipment?: XOR<ShipmentNullableRelationFilter, ShipmentWhereInput> | null
  }

  export type QuoteRequestOrderByWithRelationInput = {
    id?: SortOrder
    createdByUserId?: SortOrder
    fromLocation?: SortOrder
    toLocation?: SortOrder
    fromLat?: SortOrderInput | SortOrder
    fromLng?: SortOrderInput | SortOrder
    toLat?: SortOrderInput | SortOrder
    toLng?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    shipmentType?: SortOrderInput | SortOrder
    urgency?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    approvedResponseId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    responses?: QuoteResponseOrderByRelationAggregateInput
    approvedResponse?: QuoteResponseOrderByWithRelationInput
    shipment?: ShipmentOrderByWithRelationInput
  }

  export type QuoteRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    approvedResponseId?: number
    AND?: QuoteRequestWhereInput | QuoteRequestWhereInput[]
    OR?: QuoteRequestWhereInput[]
    NOT?: QuoteRequestWhereInput | QuoteRequestWhereInput[]
    createdByUserId?: IntFilter<"QuoteRequest"> | number
    fromLocation?: StringFilter<"QuoteRequest"> | string
    toLocation?: StringFilter<"QuoteRequest"> | string
    fromLat?: FloatNullableFilter<"QuoteRequest"> | number | null
    fromLng?: FloatNullableFilter<"QuoteRequest"> | number | null
    toLat?: FloatNullableFilter<"QuoteRequest"> | number | null
    toLng?: FloatNullableFilter<"QuoteRequest"> | number | null
    weight?: FloatNullableFilter<"QuoteRequest"> | number | null
    shipmentType?: StringNullableFilter<"QuoteRequest"> | string | null
    urgency?: StringNullableFilter<"QuoteRequest"> | string | null
    status?: EnumQuoteStatusFilter<"QuoteRequest"> | $Enums.QuoteStatus
    notes?: StringNullableFilter<"QuoteRequest"> | string | null
    createdAt?: DateTimeFilter<"QuoteRequest"> | Date | string
    updatedAt?: DateTimeFilter<"QuoteRequest"> | Date | string
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    responses?: QuoteResponseListRelationFilter
    approvedResponse?: XOR<QuoteResponseNullableRelationFilter, QuoteResponseWhereInput> | null
    shipment?: XOR<ShipmentNullableRelationFilter, ShipmentWhereInput> | null
  }, "id" | "approvedResponseId">

  export type QuoteRequestOrderByWithAggregationInput = {
    id?: SortOrder
    createdByUserId?: SortOrder
    fromLocation?: SortOrder
    toLocation?: SortOrder
    fromLat?: SortOrderInput | SortOrder
    fromLng?: SortOrderInput | SortOrder
    toLat?: SortOrderInput | SortOrder
    toLng?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    shipmentType?: SortOrderInput | SortOrder
    urgency?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    approvedResponseId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuoteRequestCountOrderByAggregateInput
    _avg?: QuoteRequestAvgOrderByAggregateInput
    _max?: QuoteRequestMaxOrderByAggregateInput
    _min?: QuoteRequestMinOrderByAggregateInput
    _sum?: QuoteRequestSumOrderByAggregateInput
  }

  export type QuoteRequestScalarWhereWithAggregatesInput = {
    AND?: QuoteRequestScalarWhereWithAggregatesInput | QuoteRequestScalarWhereWithAggregatesInput[]
    OR?: QuoteRequestScalarWhereWithAggregatesInput[]
    NOT?: QuoteRequestScalarWhereWithAggregatesInput | QuoteRequestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QuoteRequest"> | number
    createdByUserId?: IntWithAggregatesFilter<"QuoteRequest"> | number
    fromLocation?: StringWithAggregatesFilter<"QuoteRequest"> | string
    toLocation?: StringWithAggregatesFilter<"QuoteRequest"> | string
    fromLat?: FloatNullableWithAggregatesFilter<"QuoteRequest"> | number | null
    fromLng?: FloatNullableWithAggregatesFilter<"QuoteRequest"> | number | null
    toLat?: FloatNullableWithAggregatesFilter<"QuoteRequest"> | number | null
    toLng?: FloatNullableWithAggregatesFilter<"QuoteRequest"> | number | null
    weight?: FloatNullableWithAggregatesFilter<"QuoteRequest"> | number | null
    shipmentType?: StringNullableWithAggregatesFilter<"QuoteRequest"> | string | null
    urgency?: StringNullableWithAggregatesFilter<"QuoteRequest"> | string | null
    status?: EnumQuoteStatusWithAggregatesFilter<"QuoteRequest"> | $Enums.QuoteStatus
    notes?: StringNullableWithAggregatesFilter<"QuoteRequest"> | string | null
    approvedResponseId?: IntNullableWithAggregatesFilter<"QuoteRequest"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"QuoteRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QuoteRequest"> | Date | string
  }

  export type QuoteResponseWhereInput = {
    AND?: QuoteResponseWhereInput | QuoteResponseWhereInput[]
    OR?: QuoteResponseWhereInput[]
    NOT?: QuoteResponseWhereInput | QuoteResponseWhereInput[]
    id?: IntFilter<"QuoteResponse"> | number
    quoteRequestId?: IntFilter<"QuoteResponse"> | number
    vendorId?: IntFilter<"QuoteResponse"> | number
    quotedPrice?: FloatNullableFilter<"QuoteResponse"> | number | null
    estimatedDelivery?: DateTimeNullableFilter<"QuoteResponse"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"QuoteResponse"> | Date | string | null
    status?: EnumQuoteResponseStatusFilter<"QuoteResponse"> | $Enums.QuoteResponseStatus
    consentStatus?: EnumConsentStatusFilter<"QuoteResponse"> | $Enums.ConsentStatus
    notes?: StringNullableFilter<"QuoteResponse"> | string | null
    transporterNotes?: StringNullableFilter<"QuoteResponse"> | string | null
    createdAt?: DateTimeFilter<"QuoteResponse"> | Date | string
    updatedAt?: DateTimeFilter<"QuoteResponse"> | Date | string
    quoteRequest?: XOR<QuoteRequestRelationFilter, QuoteRequestWhereInput>
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    shipment?: XOR<ShipmentNullableRelationFilter, ShipmentWhereInput> | null
    approvedFor?: XOR<QuoteRequestNullableRelationFilter, QuoteRequestWhereInput> | null
    consentLogs?: ConsentLogListRelationFilter
  }

  export type QuoteResponseOrderByWithRelationInput = {
    id?: SortOrder
    quoteRequestId?: SortOrder
    vendorId?: SortOrder
    quotedPrice?: SortOrderInput | SortOrder
    estimatedDelivery?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    status?: SortOrder
    consentStatus?: SortOrder
    notes?: SortOrderInput | SortOrder
    transporterNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quoteRequest?: QuoteRequestOrderByWithRelationInput
    vendor?: VendorOrderByWithRelationInput
    shipment?: ShipmentOrderByWithRelationInput
    approvedFor?: QuoteRequestOrderByWithRelationInput
    consentLogs?: ConsentLogOrderByRelationAggregateInput
  }

  export type QuoteResponseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QuoteResponseWhereInput | QuoteResponseWhereInput[]
    OR?: QuoteResponseWhereInput[]
    NOT?: QuoteResponseWhereInput | QuoteResponseWhereInput[]
    quoteRequestId?: IntFilter<"QuoteResponse"> | number
    vendorId?: IntFilter<"QuoteResponse"> | number
    quotedPrice?: FloatNullableFilter<"QuoteResponse"> | number | null
    estimatedDelivery?: DateTimeNullableFilter<"QuoteResponse"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"QuoteResponse"> | Date | string | null
    status?: EnumQuoteResponseStatusFilter<"QuoteResponse"> | $Enums.QuoteResponseStatus
    consentStatus?: EnumConsentStatusFilter<"QuoteResponse"> | $Enums.ConsentStatus
    notes?: StringNullableFilter<"QuoteResponse"> | string | null
    transporterNotes?: StringNullableFilter<"QuoteResponse"> | string | null
    createdAt?: DateTimeFilter<"QuoteResponse"> | Date | string
    updatedAt?: DateTimeFilter<"QuoteResponse"> | Date | string
    quoteRequest?: XOR<QuoteRequestRelationFilter, QuoteRequestWhereInput>
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    shipment?: XOR<ShipmentNullableRelationFilter, ShipmentWhereInput> | null
    approvedFor?: XOR<QuoteRequestNullableRelationFilter, QuoteRequestWhereInput> | null
    consentLogs?: ConsentLogListRelationFilter
  }, "id">

  export type QuoteResponseOrderByWithAggregationInput = {
    id?: SortOrder
    quoteRequestId?: SortOrder
    vendorId?: SortOrder
    quotedPrice?: SortOrderInput | SortOrder
    estimatedDelivery?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    status?: SortOrder
    consentStatus?: SortOrder
    notes?: SortOrderInput | SortOrder
    transporterNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuoteResponseCountOrderByAggregateInput
    _avg?: QuoteResponseAvgOrderByAggregateInput
    _max?: QuoteResponseMaxOrderByAggregateInput
    _min?: QuoteResponseMinOrderByAggregateInput
    _sum?: QuoteResponseSumOrderByAggregateInput
  }

  export type QuoteResponseScalarWhereWithAggregatesInput = {
    AND?: QuoteResponseScalarWhereWithAggregatesInput | QuoteResponseScalarWhereWithAggregatesInput[]
    OR?: QuoteResponseScalarWhereWithAggregatesInput[]
    NOT?: QuoteResponseScalarWhereWithAggregatesInput | QuoteResponseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QuoteResponse"> | number
    quoteRequestId?: IntWithAggregatesFilter<"QuoteResponse"> | number
    vendorId?: IntWithAggregatesFilter<"QuoteResponse"> | number
    quotedPrice?: FloatNullableWithAggregatesFilter<"QuoteResponse"> | number | null
    estimatedDelivery?: DateTimeNullableWithAggregatesFilter<"QuoteResponse"> | Date | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"QuoteResponse"> | Date | string | null
    status?: EnumQuoteResponseStatusWithAggregatesFilter<"QuoteResponse"> | $Enums.QuoteResponseStatus
    consentStatus?: EnumConsentStatusWithAggregatesFilter<"QuoteResponse"> | $Enums.ConsentStatus
    notes?: StringNullableWithAggregatesFilter<"QuoteResponse"> | string | null
    transporterNotes?: StringNullableWithAggregatesFilter<"QuoteResponse"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"QuoteResponse"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QuoteResponse"> | Date | string
  }

  export type ConsentLogWhereInput = {
    AND?: ConsentLogWhereInput | ConsentLogWhereInput[]
    OR?: ConsentLogWhereInput[]
    NOT?: ConsentLogWhereInput | ConsentLogWhereInput[]
    id?: IntFilter<"ConsentLog"> | number
    quoteResponseId?: IntFilter<"ConsentLog"> | number
    shipmentId?: IntNullableFilter<"ConsentLog"> | number | null
    statusBefore?: EnumConsentStatusFilter<"ConsentLog"> | $Enums.ConsentStatus
    statusAfter?: EnumConsentStatusFilter<"ConsentLog"> | $Enums.ConsentStatus
    note?: StringNullableFilter<"ConsentLog"> | string | null
    recordedAt?: DateTimeFilter<"ConsentLog"> | Date | string
    quoteResponse?: XOR<QuoteResponseRelationFilter, QuoteResponseWhereInput>
    shipment?: XOR<ShipmentNullableRelationFilter, ShipmentWhereInput> | null
  }

  export type ConsentLogOrderByWithRelationInput = {
    id?: SortOrder
    quoteResponseId?: SortOrder
    shipmentId?: SortOrderInput | SortOrder
    statusBefore?: SortOrder
    statusAfter?: SortOrder
    note?: SortOrderInput | SortOrder
    recordedAt?: SortOrder
    quoteResponse?: QuoteResponseOrderByWithRelationInput
    shipment?: ShipmentOrderByWithRelationInput
  }

  export type ConsentLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ConsentLogWhereInput | ConsentLogWhereInput[]
    OR?: ConsentLogWhereInput[]
    NOT?: ConsentLogWhereInput | ConsentLogWhereInput[]
    quoteResponseId?: IntFilter<"ConsentLog"> | number
    shipmentId?: IntNullableFilter<"ConsentLog"> | number | null
    statusBefore?: EnumConsentStatusFilter<"ConsentLog"> | $Enums.ConsentStatus
    statusAfter?: EnumConsentStatusFilter<"ConsentLog"> | $Enums.ConsentStatus
    note?: StringNullableFilter<"ConsentLog"> | string | null
    recordedAt?: DateTimeFilter<"ConsentLog"> | Date | string
    quoteResponse?: XOR<QuoteResponseRelationFilter, QuoteResponseWhereInput>
    shipment?: XOR<ShipmentNullableRelationFilter, ShipmentWhereInput> | null
  }, "id">

  export type ConsentLogOrderByWithAggregationInput = {
    id?: SortOrder
    quoteResponseId?: SortOrder
    shipmentId?: SortOrderInput | SortOrder
    statusBefore?: SortOrder
    statusAfter?: SortOrder
    note?: SortOrderInput | SortOrder
    recordedAt?: SortOrder
    _count?: ConsentLogCountOrderByAggregateInput
    _avg?: ConsentLogAvgOrderByAggregateInput
    _max?: ConsentLogMaxOrderByAggregateInput
    _min?: ConsentLogMinOrderByAggregateInput
    _sum?: ConsentLogSumOrderByAggregateInput
  }

  export type ConsentLogScalarWhereWithAggregatesInput = {
    AND?: ConsentLogScalarWhereWithAggregatesInput | ConsentLogScalarWhereWithAggregatesInput[]
    OR?: ConsentLogScalarWhereWithAggregatesInput[]
    NOT?: ConsentLogScalarWhereWithAggregatesInput | ConsentLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ConsentLog"> | number
    quoteResponseId?: IntWithAggregatesFilter<"ConsentLog"> | number
    shipmentId?: IntNullableWithAggregatesFilter<"ConsentLog"> | number | null
    statusBefore?: EnumConsentStatusWithAggregatesFilter<"ConsentLog"> | $Enums.ConsentStatus
    statusAfter?: EnumConsentStatusWithAggregatesFilter<"ConsentLog"> | $Enums.ConsentStatus
    note?: StringNullableWithAggregatesFilter<"ConsentLog"> | string | null
    recordedAt?: DateTimeWithAggregatesFilter<"ConsentLog"> | Date | string
  }

  export type ShipmentWhereInput = {
    AND?: ShipmentWhereInput | ShipmentWhereInput[]
    OR?: ShipmentWhereInput[]
    NOT?: ShipmentWhereInput | ShipmentWhereInput[]
    id?: IntFilter<"Shipment"> | number
    userId?: IntFilter<"Shipment"> | number
    companyId?: IntNullableFilter<"Shipment"> | number | null
    quoteRequestId?: IntNullableFilter<"Shipment"> | number | null
    transporterQuoteId?: IntNullableFilter<"Shipment"> | number | null
    selectedVendorId?: IntNullableFilter<"Shipment"> | number | null
    agreementId?: IntNullableFilter<"Shipment"> | number | null
    rateCardId?: IntNullableFilter<"Shipment"> | number | null
    trackingNumber?: StringNullableFilter<"Shipment"> | string | null
    fromLocation?: StringFilter<"Shipment"> | string
    toLocation?: StringFilter<"Shipment"> | string
    fromLat?: FloatNullableFilter<"Shipment"> | number | null
    fromLng?: FloatNullableFilter<"Shipment"> | number | null
    toLat?: FloatNullableFilter<"Shipment"> | number | null
    toLng?: FloatNullableFilter<"Shipment"> | number | null
    weight?: FloatNullableFilter<"Shipment"> | number | null
    shipmentType?: StringNullableFilter<"Shipment"> | string | null
    urgency?: StringNullableFilter<"Shipment"> | string | null
    status?: EnumShipmentStatusFilter<"Shipment"> | $Enums.ShipmentStatus
    bookingStatus?: EnumBookingStatusNullableFilter<"Shipment"> | $Enums.BookingStatus | null
    paymentStatus?: EnumPaymentStatusNullableFilter<"Shipment"> | $Enums.PaymentStatus | null
    cost?: FloatNullableFilter<"Shipment"> | number | null
    distance?: FloatNullableFilter<"Shipment"> | number | null
    estimatedDelivery?: DateTimeNullableFilter<"Shipment"> | Date | string | null
    pickupTime?: DateTimeNullableFilter<"Shipment"> | Date | string | null
    deliveryTime?: DateTimeNullableFilter<"Shipment"> | Date | string | null
    assignedToId?: IntNullableFilter<"Shipment"> | number | null
    assignedDriver?: StringNullableFilter<"Shipment"> | string | null
    driverPhone?: StringNullableFilter<"Shipment"> | string | null
    driverEta?: DateTimeNullableFilter<"Shipment"> | Date | string | null
    transporterResponseNotes?: StringNullableFilter<"Shipment"> | string | null
    notes?: StringNullableFilter<"Shipment"> | string | null
    ewayBillNumber?: StringNullableFilter<"Shipment"> | string | null
    gstInvoiceId?: IntNullableFilter<"Shipment"> | number | null
    complianceStatus?: EnumComplianceStatusFilter<"Shipment"> | $Enums.ComplianceStatus
    source?: StringFilter<"Shipment"> | string
    podStatus?: StringFilter<"Shipment"> | string
    podUrl?: StringNullableFilter<"Shipment"> | string | null
    podNotes?: StringNullableFilter<"Shipment"> | string | null
    createdAt?: DateTimeFilter<"Shipment"> | Date | string
    updatedAt?: DateTimeFilter<"Shipment"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
    quoteRequest?: XOR<QuoteRequestNullableRelationFilter, QuoteRequestWhereInput> | null
    transporterQuote?: XOR<QuoteResponseNullableRelationFilter, QuoteResponseWhereInput> | null
    rateCard?: XOR<RateCardNullableRelationFilter, RateCardWhereInput> | null
    vendor?: XOR<VendorNullableRelationFilter, VendorWhereInput> | null
    assignedTo?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    statusHistory?: StatusHistoryListRelationFilter
    complianceDocs?: ComplianceDocumentListRelationFilter
    payments?: PaymentListRelationFilter
    invoice?: XOR<InvoiceNullableRelationFilter, InvoiceWhereInput> | null
    consentLogs?: ConsentLogListRelationFilter
    transporterInvoices?: TransporterInvoiceListRelationFilter
  }

  export type ShipmentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrderInput | SortOrder
    quoteRequestId?: SortOrderInput | SortOrder
    transporterQuoteId?: SortOrderInput | SortOrder
    selectedVendorId?: SortOrderInput | SortOrder
    agreementId?: SortOrderInput | SortOrder
    rateCardId?: SortOrderInput | SortOrder
    trackingNumber?: SortOrderInput | SortOrder
    fromLocation?: SortOrder
    toLocation?: SortOrder
    fromLat?: SortOrderInput | SortOrder
    fromLng?: SortOrderInput | SortOrder
    toLat?: SortOrderInput | SortOrder
    toLng?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    shipmentType?: SortOrderInput | SortOrder
    urgency?: SortOrderInput | SortOrder
    status?: SortOrder
    bookingStatus?: SortOrderInput | SortOrder
    paymentStatus?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    distance?: SortOrderInput | SortOrder
    estimatedDelivery?: SortOrderInput | SortOrder
    pickupTime?: SortOrderInput | SortOrder
    deliveryTime?: SortOrderInput | SortOrder
    assignedToId?: SortOrderInput | SortOrder
    assignedDriver?: SortOrderInput | SortOrder
    driverPhone?: SortOrderInput | SortOrder
    driverEta?: SortOrderInput | SortOrder
    transporterResponseNotes?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    ewayBillNumber?: SortOrderInput | SortOrder
    gstInvoiceId?: SortOrderInput | SortOrder
    complianceStatus?: SortOrder
    source?: SortOrder
    podStatus?: SortOrder
    podUrl?: SortOrderInput | SortOrder
    podNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    quoteRequest?: QuoteRequestOrderByWithRelationInput
    transporterQuote?: QuoteResponseOrderByWithRelationInput
    rateCard?: RateCardOrderByWithRelationInput
    vendor?: VendorOrderByWithRelationInput
    assignedTo?: UserOrderByWithRelationInput
    statusHistory?: StatusHistoryOrderByRelationAggregateInput
    complianceDocs?: ComplianceDocumentOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    invoice?: InvoiceOrderByWithRelationInput
    consentLogs?: ConsentLogOrderByRelationAggregateInput
    transporterInvoices?: TransporterInvoiceOrderByRelationAggregateInput
  }

  export type ShipmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    quoteRequestId?: number
    transporterQuoteId?: number
    trackingNumber?: string
    AND?: ShipmentWhereInput | ShipmentWhereInput[]
    OR?: ShipmentWhereInput[]
    NOT?: ShipmentWhereInput | ShipmentWhereInput[]
    userId?: IntFilter<"Shipment"> | number
    companyId?: IntNullableFilter<"Shipment"> | number | null
    selectedVendorId?: IntNullableFilter<"Shipment"> | number | null
    agreementId?: IntNullableFilter<"Shipment"> | number | null
    rateCardId?: IntNullableFilter<"Shipment"> | number | null
    fromLocation?: StringFilter<"Shipment"> | string
    toLocation?: StringFilter<"Shipment"> | string
    fromLat?: FloatNullableFilter<"Shipment"> | number | null
    fromLng?: FloatNullableFilter<"Shipment"> | number | null
    toLat?: FloatNullableFilter<"Shipment"> | number | null
    toLng?: FloatNullableFilter<"Shipment"> | number | null
    weight?: FloatNullableFilter<"Shipment"> | number | null
    shipmentType?: StringNullableFilter<"Shipment"> | string | null
    urgency?: StringNullableFilter<"Shipment"> | string | null
    status?: EnumShipmentStatusFilter<"Shipment"> | $Enums.ShipmentStatus
    bookingStatus?: EnumBookingStatusNullableFilter<"Shipment"> | $Enums.BookingStatus | null
    paymentStatus?: EnumPaymentStatusNullableFilter<"Shipment"> | $Enums.PaymentStatus | null
    cost?: FloatNullableFilter<"Shipment"> | number | null
    distance?: FloatNullableFilter<"Shipment"> | number | null
    estimatedDelivery?: DateTimeNullableFilter<"Shipment"> | Date | string | null
    pickupTime?: DateTimeNullableFilter<"Shipment"> | Date | string | null
    deliveryTime?: DateTimeNullableFilter<"Shipment"> | Date | string | null
    assignedToId?: IntNullableFilter<"Shipment"> | number | null
    assignedDriver?: StringNullableFilter<"Shipment"> | string | null
    driverPhone?: StringNullableFilter<"Shipment"> | string | null
    driverEta?: DateTimeNullableFilter<"Shipment"> | Date | string | null
    transporterResponseNotes?: StringNullableFilter<"Shipment"> | string | null
    notes?: StringNullableFilter<"Shipment"> | string | null
    ewayBillNumber?: StringNullableFilter<"Shipment"> | string | null
    gstInvoiceId?: IntNullableFilter<"Shipment"> | number | null
    complianceStatus?: EnumComplianceStatusFilter<"Shipment"> | $Enums.ComplianceStatus
    source?: StringFilter<"Shipment"> | string
    podStatus?: StringFilter<"Shipment"> | string
    podUrl?: StringNullableFilter<"Shipment"> | string | null
    podNotes?: StringNullableFilter<"Shipment"> | string | null
    createdAt?: DateTimeFilter<"Shipment"> | Date | string
    updatedAt?: DateTimeFilter<"Shipment"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
    quoteRequest?: XOR<QuoteRequestNullableRelationFilter, QuoteRequestWhereInput> | null
    transporterQuote?: XOR<QuoteResponseNullableRelationFilter, QuoteResponseWhereInput> | null
    rateCard?: XOR<RateCardNullableRelationFilter, RateCardWhereInput> | null
    vendor?: XOR<VendorNullableRelationFilter, VendorWhereInput> | null
    assignedTo?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    statusHistory?: StatusHistoryListRelationFilter
    complianceDocs?: ComplianceDocumentListRelationFilter
    payments?: PaymentListRelationFilter
    invoice?: XOR<InvoiceNullableRelationFilter, InvoiceWhereInput> | null
    consentLogs?: ConsentLogListRelationFilter
    transporterInvoices?: TransporterInvoiceListRelationFilter
  }, "id" | "quoteRequestId" | "transporterQuoteId" | "trackingNumber">

  export type ShipmentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrderInput | SortOrder
    quoteRequestId?: SortOrderInput | SortOrder
    transporterQuoteId?: SortOrderInput | SortOrder
    selectedVendorId?: SortOrderInput | SortOrder
    agreementId?: SortOrderInput | SortOrder
    rateCardId?: SortOrderInput | SortOrder
    trackingNumber?: SortOrderInput | SortOrder
    fromLocation?: SortOrder
    toLocation?: SortOrder
    fromLat?: SortOrderInput | SortOrder
    fromLng?: SortOrderInput | SortOrder
    toLat?: SortOrderInput | SortOrder
    toLng?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    shipmentType?: SortOrderInput | SortOrder
    urgency?: SortOrderInput | SortOrder
    status?: SortOrder
    bookingStatus?: SortOrderInput | SortOrder
    paymentStatus?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    distance?: SortOrderInput | SortOrder
    estimatedDelivery?: SortOrderInput | SortOrder
    pickupTime?: SortOrderInput | SortOrder
    deliveryTime?: SortOrderInput | SortOrder
    assignedToId?: SortOrderInput | SortOrder
    assignedDriver?: SortOrderInput | SortOrder
    driverPhone?: SortOrderInput | SortOrder
    driverEta?: SortOrderInput | SortOrder
    transporterResponseNotes?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    ewayBillNumber?: SortOrderInput | SortOrder
    gstInvoiceId?: SortOrderInput | SortOrder
    complianceStatus?: SortOrder
    source?: SortOrder
    podStatus?: SortOrder
    podUrl?: SortOrderInput | SortOrder
    podNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShipmentCountOrderByAggregateInput
    _avg?: ShipmentAvgOrderByAggregateInput
    _max?: ShipmentMaxOrderByAggregateInput
    _min?: ShipmentMinOrderByAggregateInput
    _sum?: ShipmentSumOrderByAggregateInput
  }

  export type ShipmentScalarWhereWithAggregatesInput = {
    AND?: ShipmentScalarWhereWithAggregatesInput | ShipmentScalarWhereWithAggregatesInput[]
    OR?: ShipmentScalarWhereWithAggregatesInput[]
    NOT?: ShipmentScalarWhereWithAggregatesInput | ShipmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Shipment"> | number
    userId?: IntWithAggregatesFilter<"Shipment"> | number
    companyId?: IntNullableWithAggregatesFilter<"Shipment"> | number | null
    quoteRequestId?: IntNullableWithAggregatesFilter<"Shipment"> | number | null
    transporterQuoteId?: IntNullableWithAggregatesFilter<"Shipment"> | number | null
    selectedVendorId?: IntNullableWithAggregatesFilter<"Shipment"> | number | null
    agreementId?: IntNullableWithAggregatesFilter<"Shipment"> | number | null
    rateCardId?: IntNullableWithAggregatesFilter<"Shipment"> | number | null
    trackingNumber?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    fromLocation?: StringWithAggregatesFilter<"Shipment"> | string
    toLocation?: StringWithAggregatesFilter<"Shipment"> | string
    fromLat?: FloatNullableWithAggregatesFilter<"Shipment"> | number | null
    fromLng?: FloatNullableWithAggregatesFilter<"Shipment"> | number | null
    toLat?: FloatNullableWithAggregatesFilter<"Shipment"> | number | null
    toLng?: FloatNullableWithAggregatesFilter<"Shipment"> | number | null
    weight?: FloatNullableWithAggregatesFilter<"Shipment"> | number | null
    shipmentType?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    urgency?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    status?: EnumShipmentStatusWithAggregatesFilter<"Shipment"> | $Enums.ShipmentStatus
    bookingStatus?: EnumBookingStatusNullableWithAggregatesFilter<"Shipment"> | $Enums.BookingStatus | null
    paymentStatus?: EnumPaymentStatusNullableWithAggregatesFilter<"Shipment"> | $Enums.PaymentStatus | null
    cost?: FloatNullableWithAggregatesFilter<"Shipment"> | number | null
    distance?: FloatNullableWithAggregatesFilter<"Shipment"> | number | null
    estimatedDelivery?: DateTimeNullableWithAggregatesFilter<"Shipment"> | Date | string | null
    pickupTime?: DateTimeNullableWithAggregatesFilter<"Shipment"> | Date | string | null
    deliveryTime?: DateTimeNullableWithAggregatesFilter<"Shipment"> | Date | string | null
    assignedToId?: IntNullableWithAggregatesFilter<"Shipment"> | number | null
    assignedDriver?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    driverPhone?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    driverEta?: DateTimeNullableWithAggregatesFilter<"Shipment"> | Date | string | null
    transporterResponseNotes?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    ewayBillNumber?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    gstInvoiceId?: IntNullableWithAggregatesFilter<"Shipment"> | number | null
    complianceStatus?: EnumComplianceStatusWithAggregatesFilter<"Shipment"> | $Enums.ComplianceStatus
    source?: StringWithAggregatesFilter<"Shipment"> | string
    podStatus?: StringWithAggregatesFilter<"Shipment"> | string
    podUrl?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    podNotes?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Shipment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Shipment"> | Date | string
  }

  export type StatusHistoryWhereInput = {
    AND?: StatusHistoryWhereInput | StatusHistoryWhereInput[]
    OR?: StatusHistoryWhereInput[]
    NOT?: StatusHistoryWhereInput | StatusHistoryWhereInput[]
    id?: IntFilter<"StatusHistory"> | number
    shipmentId?: IntFilter<"StatusHistory"> | number
    status?: EnumShipmentStatusFilter<"StatusHistory"> | $Enums.ShipmentStatus
    notes?: StringNullableFilter<"StatusHistory"> | string | null
    latitude?: FloatNullableFilter<"StatusHistory"> | number | null
    longitude?: FloatNullableFilter<"StatusHistory"> | number | null
    location?: StringNullableFilter<"StatusHistory"> | string | null
    updatedBy?: IntNullableFilter<"StatusHistory"> | number | null
    timestamp?: DateTimeFilter<"StatusHistory"> | Date | string
    shipment?: XOR<ShipmentRelationFilter, ShipmentWhereInput>
  }

  export type StatusHistoryOrderByWithRelationInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    shipment?: ShipmentOrderByWithRelationInput
  }

  export type StatusHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StatusHistoryWhereInput | StatusHistoryWhereInput[]
    OR?: StatusHistoryWhereInput[]
    NOT?: StatusHistoryWhereInput | StatusHistoryWhereInput[]
    shipmentId?: IntFilter<"StatusHistory"> | number
    status?: EnumShipmentStatusFilter<"StatusHistory"> | $Enums.ShipmentStatus
    notes?: StringNullableFilter<"StatusHistory"> | string | null
    latitude?: FloatNullableFilter<"StatusHistory"> | number | null
    longitude?: FloatNullableFilter<"StatusHistory"> | number | null
    location?: StringNullableFilter<"StatusHistory"> | string | null
    updatedBy?: IntNullableFilter<"StatusHistory"> | number | null
    timestamp?: DateTimeFilter<"StatusHistory"> | Date | string
    shipment?: XOR<ShipmentRelationFilter, ShipmentWhereInput>
  }, "id">

  export type StatusHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: StatusHistoryCountOrderByAggregateInput
    _avg?: StatusHistoryAvgOrderByAggregateInput
    _max?: StatusHistoryMaxOrderByAggregateInput
    _min?: StatusHistoryMinOrderByAggregateInput
    _sum?: StatusHistorySumOrderByAggregateInput
  }

  export type StatusHistoryScalarWhereWithAggregatesInput = {
    AND?: StatusHistoryScalarWhereWithAggregatesInput | StatusHistoryScalarWhereWithAggregatesInput[]
    OR?: StatusHistoryScalarWhereWithAggregatesInput[]
    NOT?: StatusHistoryScalarWhereWithAggregatesInput | StatusHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StatusHistory"> | number
    shipmentId?: IntWithAggregatesFilter<"StatusHistory"> | number
    status?: EnumShipmentStatusWithAggregatesFilter<"StatusHistory"> | $Enums.ShipmentStatus
    notes?: StringNullableWithAggregatesFilter<"StatusHistory"> | string | null
    latitude?: FloatNullableWithAggregatesFilter<"StatusHistory"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"StatusHistory"> | number | null
    location?: StringNullableWithAggregatesFilter<"StatusHistory"> | string | null
    updatedBy?: IntNullableWithAggregatesFilter<"StatusHistory"> | number | null
    timestamp?: DateTimeWithAggregatesFilter<"StatusHistory"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: IntFilter<"Invoice"> | number
    shipmentId?: IntFilter<"Invoice"> | number
    invoiceNumber?: StringFilter<"Invoice"> | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    issuedAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    subtotal?: FloatFilter<"Invoice"> | number
    taxTotal?: FloatFilter<"Invoice"> | number
    grandTotal?: FloatFilter<"Invoice"> | number
    lineItems?: JsonFilter<"Invoice">
    metadata?: JsonNullableFilter<"Invoice">
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    companyId?: IntNullableFilter<"Invoice"> | number | null
    shipment?: XOR<ShipmentRelationFilter, ShipmentWhereInput>
    payments?: PaymentListRelationFilter
    Company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    invoiceNumber?: SortOrder
    status?: SortOrder
    issuedAt?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    taxTotal?: SortOrder
    grandTotal?: SortOrder
    lineItems?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrderInput | SortOrder
    shipment?: ShipmentOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
    Company?: CompanyOrderByWithRelationInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    shipmentId?: number
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    invoiceNumber?: StringFilter<"Invoice"> | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    issuedAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    subtotal?: FloatFilter<"Invoice"> | number
    taxTotal?: FloatFilter<"Invoice"> | number
    grandTotal?: FloatFilter<"Invoice"> | number
    lineItems?: JsonFilter<"Invoice">
    metadata?: JsonNullableFilter<"Invoice">
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    companyId?: IntNullableFilter<"Invoice"> | number | null
    shipment?: XOR<ShipmentRelationFilter, ShipmentWhereInput>
    payments?: PaymentListRelationFilter
    Company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
  }, "id" | "shipmentId">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    invoiceNumber?: SortOrder
    status?: SortOrder
    issuedAt?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    taxTotal?: SortOrder
    grandTotal?: SortOrder
    lineItems?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrderInput | SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Invoice"> | number
    shipmentId?: IntWithAggregatesFilter<"Invoice"> | number
    invoiceNumber?: StringWithAggregatesFilter<"Invoice"> | string
    status?: EnumInvoiceStatusWithAggregatesFilter<"Invoice"> | $Enums.InvoiceStatus
    issuedAt?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    dueDate?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    subtotal?: FloatWithAggregatesFilter<"Invoice"> | number
    taxTotal?: FloatWithAggregatesFilter<"Invoice"> | number
    grandTotal?: FloatWithAggregatesFilter<"Invoice"> | number
    lineItems?: JsonWithAggregatesFilter<"Invoice">
    metadata?: JsonNullableWithAggregatesFilter<"Invoice">
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    companyId?: IntNullableWithAggregatesFilter<"Invoice"> | number | null
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: IntFilter<"Payment"> | number
    shipmentId?: IntFilter<"Payment"> | number
    invoiceId?: IntFilter<"Payment"> | number
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    gateway?: StringFilter<"Payment"> | string
    transactionRef?: StringNullableFilter<"Payment"> | string | null
    authorizedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    capturedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    failureReason?: StringNullableFilter<"Payment"> | string | null
    metadata?: JsonNullableFilter<"Payment">
    tdsAmount?: FloatNullableFilter<"Payment"> | number | null
    tcsAmount?: FloatNullableFilter<"Payment"> | number | null
    rcmLiability?: FloatNullableFilter<"Payment"> | number | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    shipment?: XOR<ShipmentRelationFilter, ShipmentWhereInput>
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
    events?: PaymentEventListRelationFilter
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    gateway?: SortOrder
    transactionRef?: SortOrderInput | SortOrder
    authorizedAt?: SortOrderInput | SortOrder
    capturedAt?: SortOrderInput | SortOrder
    failureReason?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    tdsAmount?: SortOrderInput | SortOrder
    tcsAmount?: SortOrderInput | SortOrder
    rcmLiability?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    shipment?: ShipmentOrderByWithRelationInput
    invoice?: InvoiceOrderByWithRelationInput
    events?: PaymentEventOrderByRelationAggregateInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    shipmentId?: IntFilter<"Payment"> | number
    invoiceId?: IntFilter<"Payment"> | number
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    gateway?: StringFilter<"Payment"> | string
    transactionRef?: StringNullableFilter<"Payment"> | string | null
    authorizedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    capturedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    failureReason?: StringNullableFilter<"Payment"> | string | null
    metadata?: JsonNullableFilter<"Payment">
    tdsAmount?: FloatNullableFilter<"Payment"> | number | null
    tcsAmount?: FloatNullableFilter<"Payment"> | number | null
    rcmLiability?: FloatNullableFilter<"Payment"> | number | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    shipment?: XOR<ShipmentRelationFilter, ShipmentWhereInput>
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
    events?: PaymentEventListRelationFilter
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    gateway?: SortOrder
    transactionRef?: SortOrderInput | SortOrder
    authorizedAt?: SortOrderInput | SortOrder
    capturedAt?: SortOrderInput | SortOrder
    failureReason?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    tdsAmount?: SortOrderInput | SortOrder
    tcsAmount?: SortOrderInput | SortOrder
    rcmLiability?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Payment"> | number
    shipmentId?: IntWithAggregatesFilter<"Payment"> | number
    invoiceId?: IntWithAggregatesFilter<"Payment"> | number
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    currency?: StringWithAggregatesFilter<"Payment"> | string
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    gateway?: StringWithAggregatesFilter<"Payment"> | string
    transactionRef?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    authorizedAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    capturedAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    failureReason?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Payment">
    tdsAmount?: FloatNullableWithAggregatesFilter<"Payment"> | number | null
    tcsAmount?: FloatNullableWithAggregatesFilter<"Payment"> | number | null
    rcmLiability?: FloatNullableWithAggregatesFilter<"Payment"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type PaymentEventWhereInput = {
    AND?: PaymentEventWhereInput | PaymentEventWhereInput[]
    OR?: PaymentEventWhereInput[]
    NOT?: PaymentEventWhereInput | PaymentEventWhereInput[]
    id?: IntFilter<"PaymentEvent"> | number
    paymentId?: IntFilter<"PaymentEvent"> | number
    eventType?: StringFilter<"PaymentEvent"> | string
    details?: JsonNullableFilter<"PaymentEvent">
    recordedAt?: DateTimeFilter<"PaymentEvent"> | Date | string
    payment?: XOR<PaymentRelationFilter, PaymentWhereInput>
  }

  export type PaymentEventOrderByWithRelationInput = {
    id?: SortOrder
    paymentId?: SortOrder
    eventType?: SortOrder
    details?: SortOrderInput | SortOrder
    recordedAt?: SortOrder
    payment?: PaymentOrderByWithRelationInput
  }

  export type PaymentEventWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PaymentEventWhereInput | PaymentEventWhereInput[]
    OR?: PaymentEventWhereInput[]
    NOT?: PaymentEventWhereInput | PaymentEventWhereInput[]
    paymentId?: IntFilter<"PaymentEvent"> | number
    eventType?: StringFilter<"PaymentEvent"> | string
    details?: JsonNullableFilter<"PaymentEvent">
    recordedAt?: DateTimeFilter<"PaymentEvent"> | Date | string
    payment?: XOR<PaymentRelationFilter, PaymentWhereInput>
  }, "id">

  export type PaymentEventOrderByWithAggregationInput = {
    id?: SortOrder
    paymentId?: SortOrder
    eventType?: SortOrder
    details?: SortOrderInput | SortOrder
    recordedAt?: SortOrder
    _count?: PaymentEventCountOrderByAggregateInput
    _avg?: PaymentEventAvgOrderByAggregateInput
    _max?: PaymentEventMaxOrderByAggregateInput
    _min?: PaymentEventMinOrderByAggregateInput
    _sum?: PaymentEventSumOrderByAggregateInput
  }

  export type PaymentEventScalarWhereWithAggregatesInput = {
    AND?: PaymentEventScalarWhereWithAggregatesInput | PaymentEventScalarWhereWithAggregatesInput[]
    OR?: PaymentEventScalarWhereWithAggregatesInput[]
    NOT?: PaymentEventScalarWhereWithAggregatesInput | PaymentEventScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PaymentEvent"> | number
    paymentId?: IntWithAggregatesFilter<"PaymentEvent"> | number
    eventType?: StringWithAggregatesFilter<"PaymentEvent"> | string
    details?: JsonNullableWithAggregatesFilter<"PaymentEvent">
    recordedAt?: DateTimeWithAggregatesFilter<"PaymentEvent"> | Date | string
  }

  export type TransporterInvoiceWhereInput = {
    AND?: TransporterInvoiceWhereInput | TransporterInvoiceWhereInput[]
    OR?: TransporterInvoiceWhereInput[]
    NOT?: TransporterInvoiceWhereInput | TransporterInvoiceWhereInput[]
    id?: IntFilter<"TransporterInvoice"> | number
    companyId?: IntFilter<"TransporterInvoice"> | number
    shipmentId?: IntFilter<"TransporterInvoice"> | number
    invoiceNumber?: StringFilter<"TransporterInvoice"> | string
    invoiceDate?: DateTimeFilter<"TransporterInvoice"> | Date | string
    invoiceAmount?: FloatFilter<"TransporterInvoice"> | number
    invoiceUrl?: StringFilter<"TransporterInvoice"> | string
    approvalStatus?: StringFilter<"TransporterInvoice"> | string
    rejectionNotes?: StringNullableFilter<"TransporterInvoice"> | string | null
    postedToErpAt?: DateTimeNullableFilter<"TransporterInvoice"> | Date | string | null
    approvedById?: IntNullableFilter<"TransporterInvoice"> | number | null
    createdAt?: DateTimeFilter<"TransporterInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"TransporterInvoice"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    shipment?: XOR<ShipmentRelationFilter, ShipmentWhereInput>
    approvedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type TransporterInvoiceOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    shipmentId?: SortOrder
    invoiceNumber?: SortOrder
    invoiceDate?: SortOrder
    invoiceAmount?: SortOrder
    invoiceUrl?: SortOrder
    approvalStatus?: SortOrder
    rejectionNotes?: SortOrderInput | SortOrder
    postedToErpAt?: SortOrderInput | SortOrder
    approvedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    shipment?: ShipmentOrderByWithRelationInput
    approvedBy?: UserOrderByWithRelationInput
  }

  export type TransporterInvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TransporterInvoiceWhereInput | TransporterInvoiceWhereInput[]
    OR?: TransporterInvoiceWhereInput[]
    NOT?: TransporterInvoiceWhereInput | TransporterInvoiceWhereInput[]
    companyId?: IntFilter<"TransporterInvoice"> | number
    shipmentId?: IntFilter<"TransporterInvoice"> | number
    invoiceNumber?: StringFilter<"TransporterInvoice"> | string
    invoiceDate?: DateTimeFilter<"TransporterInvoice"> | Date | string
    invoiceAmount?: FloatFilter<"TransporterInvoice"> | number
    invoiceUrl?: StringFilter<"TransporterInvoice"> | string
    approvalStatus?: StringFilter<"TransporterInvoice"> | string
    rejectionNotes?: StringNullableFilter<"TransporterInvoice"> | string | null
    postedToErpAt?: DateTimeNullableFilter<"TransporterInvoice"> | Date | string | null
    approvedById?: IntNullableFilter<"TransporterInvoice"> | number | null
    createdAt?: DateTimeFilter<"TransporterInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"TransporterInvoice"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    shipment?: XOR<ShipmentRelationFilter, ShipmentWhereInput>
    approvedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type TransporterInvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    shipmentId?: SortOrder
    invoiceNumber?: SortOrder
    invoiceDate?: SortOrder
    invoiceAmount?: SortOrder
    invoiceUrl?: SortOrder
    approvalStatus?: SortOrder
    rejectionNotes?: SortOrderInput | SortOrder
    postedToErpAt?: SortOrderInput | SortOrder
    approvedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransporterInvoiceCountOrderByAggregateInput
    _avg?: TransporterInvoiceAvgOrderByAggregateInput
    _max?: TransporterInvoiceMaxOrderByAggregateInput
    _min?: TransporterInvoiceMinOrderByAggregateInput
    _sum?: TransporterInvoiceSumOrderByAggregateInput
  }

  export type TransporterInvoiceScalarWhereWithAggregatesInput = {
    AND?: TransporterInvoiceScalarWhereWithAggregatesInput | TransporterInvoiceScalarWhereWithAggregatesInput[]
    OR?: TransporterInvoiceScalarWhereWithAggregatesInput[]
    NOT?: TransporterInvoiceScalarWhereWithAggregatesInput | TransporterInvoiceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TransporterInvoice"> | number
    companyId?: IntWithAggregatesFilter<"TransporterInvoice"> | number
    shipmentId?: IntWithAggregatesFilter<"TransporterInvoice"> | number
    invoiceNumber?: StringWithAggregatesFilter<"TransporterInvoice"> | string
    invoiceDate?: DateTimeWithAggregatesFilter<"TransporterInvoice"> | Date | string
    invoiceAmount?: FloatWithAggregatesFilter<"TransporterInvoice"> | number
    invoiceUrl?: StringWithAggregatesFilter<"TransporterInvoice"> | string
    approvalStatus?: StringWithAggregatesFilter<"TransporterInvoice"> | string
    rejectionNotes?: StringNullableWithAggregatesFilter<"TransporterInvoice"> | string | null
    postedToErpAt?: DateTimeNullableWithAggregatesFilter<"TransporterInvoice"> | Date | string | null
    approvedById?: IntNullableWithAggregatesFilter<"TransporterInvoice"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"TransporterInvoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TransporterInvoice"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: IntFilter<"Notification"> | number
    userId?: IntFilter<"Notification"> | number
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    metadata?: JsonNullableFilter<"Notification">
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    metadata?: SortOrderInput | SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: IntFilter<"Notification"> | number
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    metadata?: JsonNullableFilter<"Notification">
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    metadata?: SortOrderInput | SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notification"> | number
    userId?: IntWithAggregatesFilter<"Notification"> | number
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    metadata?: JsonNullableWithAggregatesFilter<"Notification">
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: IntFilter<"AuditLog"> | number
    userId?: IntNullableFilter<"AuditLog"> | number | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: IntNullableFilter<"AuditLog"> | number | null
    details?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: IntNullableFilter<"AuditLog"> | number | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: IntNullableFilter<"AuditLog"> | number | null
    details?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _avg?: AuditLogAvgOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
    _sum?: AuditLogSumOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AuditLog"> | number
    userId?: IntNullableWithAggregatesFilter<"AuditLog"> | number | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: IntNullableWithAggregatesFilter<"AuditLog"> | number | null
    details?: JsonNullableWithAggregatesFilter<"AuditLog">
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type ComplianceDocumentWhereInput = {
    AND?: ComplianceDocumentWhereInput | ComplianceDocumentWhereInput[]
    OR?: ComplianceDocumentWhereInput[]
    NOT?: ComplianceDocumentWhereInput | ComplianceDocumentWhereInput[]
    id?: IntFilter<"ComplianceDocument"> | number
    shipmentId?: IntFilter<"ComplianceDocument"> | number
    type?: EnumDocumentTypeFilter<"ComplianceDocument"> | $Enums.DocumentType
    status?: EnumComplianceStatusFilter<"ComplianceDocument"> | $Enums.ComplianceStatus
    issuedAt?: DateTimeNullableFilter<"ComplianceDocument"> | Date | string | null
    fileUrl?: StringNullableFilter<"ComplianceDocument"> | string | null
    payload?: JsonNullableFilter<"ComplianceDocument">
    metadata?: JsonNullableFilter<"ComplianceDocument">
    remarks?: StringNullableFilter<"ComplianceDocument"> | string | null
    createdAt?: DateTimeFilter<"ComplianceDocument"> | Date | string
    updatedAt?: DateTimeFilter<"ComplianceDocument"> | Date | string
    shipment?: XOR<ShipmentRelationFilter, ShipmentWhereInput>
    events?: ComplianceEventListRelationFilter
  }

  export type ComplianceDocumentOrderByWithRelationInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    issuedAt?: SortOrderInput | SortOrder
    fileUrl?: SortOrderInput | SortOrder
    payload?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    shipment?: ShipmentOrderByWithRelationInput
    events?: ComplianceEventOrderByRelationAggregateInput
  }

  export type ComplianceDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ComplianceDocumentWhereInput | ComplianceDocumentWhereInput[]
    OR?: ComplianceDocumentWhereInput[]
    NOT?: ComplianceDocumentWhereInput | ComplianceDocumentWhereInput[]
    shipmentId?: IntFilter<"ComplianceDocument"> | number
    type?: EnumDocumentTypeFilter<"ComplianceDocument"> | $Enums.DocumentType
    status?: EnumComplianceStatusFilter<"ComplianceDocument"> | $Enums.ComplianceStatus
    issuedAt?: DateTimeNullableFilter<"ComplianceDocument"> | Date | string | null
    fileUrl?: StringNullableFilter<"ComplianceDocument"> | string | null
    payload?: JsonNullableFilter<"ComplianceDocument">
    metadata?: JsonNullableFilter<"ComplianceDocument">
    remarks?: StringNullableFilter<"ComplianceDocument"> | string | null
    createdAt?: DateTimeFilter<"ComplianceDocument"> | Date | string
    updatedAt?: DateTimeFilter<"ComplianceDocument"> | Date | string
    shipment?: XOR<ShipmentRelationFilter, ShipmentWhereInput>
    events?: ComplianceEventListRelationFilter
  }, "id">

  export type ComplianceDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    issuedAt?: SortOrderInput | SortOrder
    fileUrl?: SortOrderInput | SortOrder
    payload?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ComplianceDocumentCountOrderByAggregateInput
    _avg?: ComplianceDocumentAvgOrderByAggregateInput
    _max?: ComplianceDocumentMaxOrderByAggregateInput
    _min?: ComplianceDocumentMinOrderByAggregateInput
    _sum?: ComplianceDocumentSumOrderByAggregateInput
  }

  export type ComplianceDocumentScalarWhereWithAggregatesInput = {
    AND?: ComplianceDocumentScalarWhereWithAggregatesInput | ComplianceDocumentScalarWhereWithAggregatesInput[]
    OR?: ComplianceDocumentScalarWhereWithAggregatesInput[]
    NOT?: ComplianceDocumentScalarWhereWithAggregatesInput | ComplianceDocumentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ComplianceDocument"> | number
    shipmentId?: IntWithAggregatesFilter<"ComplianceDocument"> | number
    type?: EnumDocumentTypeWithAggregatesFilter<"ComplianceDocument"> | $Enums.DocumentType
    status?: EnumComplianceStatusWithAggregatesFilter<"ComplianceDocument"> | $Enums.ComplianceStatus
    issuedAt?: DateTimeNullableWithAggregatesFilter<"ComplianceDocument"> | Date | string | null
    fileUrl?: StringNullableWithAggregatesFilter<"ComplianceDocument"> | string | null
    payload?: JsonNullableWithAggregatesFilter<"ComplianceDocument">
    metadata?: JsonNullableWithAggregatesFilter<"ComplianceDocument">
    remarks?: StringNullableWithAggregatesFilter<"ComplianceDocument"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ComplianceDocument"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ComplianceDocument"> | Date | string
  }

  export type ComplianceEventWhereInput = {
    AND?: ComplianceEventWhereInput | ComplianceEventWhereInput[]
    OR?: ComplianceEventWhereInput[]
    NOT?: ComplianceEventWhereInput | ComplianceEventWhereInput[]
    id?: IntFilter<"ComplianceEvent"> | number
    documentId?: IntFilter<"ComplianceEvent"> | number
    eventType?: StringFilter<"ComplianceEvent"> | string
    details?: JsonNullableFilter<"ComplianceEvent">
    recordedAt?: DateTimeFilter<"ComplianceEvent"> | Date | string
    document?: XOR<ComplianceDocumentRelationFilter, ComplianceDocumentWhereInput>
  }

  export type ComplianceEventOrderByWithRelationInput = {
    id?: SortOrder
    documentId?: SortOrder
    eventType?: SortOrder
    details?: SortOrderInput | SortOrder
    recordedAt?: SortOrder
    document?: ComplianceDocumentOrderByWithRelationInput
  }

  export type ComplianceEventWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ComplianceEventWhereInput | ComplianceEventWhereInput[]
    OR?: ComplianceEventWhereInput[]
    NOT?: ComplianceEventWhereInput | ComplianceEventWhereInput[]
    documentId?: IntFilter<"ComplianceEvent"> | number
    eventType?: StringFilter<"ComplianceEvent"> | string
    details?: JsonNullableFilter<"ComplianceEvent">
    recordedAt?: DateTimeFilter<"ComplianceEvent"> | Date | string
    document?: XOR<ComplianceDocumentRelationFilter, ComplianceDocumentWhereInput>
  }, "id">

  export type ComplianceEventOrderByWithAggregationInput = {
    id?: SortOrder
    documentId?: SortOrder
    eventType?: SortOrder
    details?: SortOrderInput | SortOrder
    recordedAt?: SortOrder
    _count?: ComplianceEventCountOrderByAggregateInput
    _avg?: ComplianceEventAvgOrderByAggregateInput
    _max?: ComplianceEventMaxOrderByAggregateInput
    _min?: ComplianceEventMinOrderByAggregateInput
    _sum?: ComplianceEventSumOrderByAggregateInput
  }

  export type ComplianceEventScalarWhereWithAggregatesInput = {
    AND?: ComplianceEventScalarWhereWithAggregatesInput | ComplianceEventScalarWhereWithAggregatesInput[]
    OR?: ComplianceEventScalarWhereWithAggregatesInput[]
    NOT?: ComplianceEventScalarWhereWithAggregatesInput | ComplianceEventScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ComplianceEvent"> | number
    documentId?: IntWithAggregatesFilter<"ComplianceEvent"> | number
    eventType?: StringWithAggregatesFilter<"ComplianceEvent"> | string
    details?: JsonNullableWithAggregatesFilter<"ComplianceEvent">
    recordedAt?: DateTimeWithAggregatesFilter<"ComplianceEvent"> | Date | string
  }

  export type CompanyCreateInput = {
    name: string
    webhookSecret: string
    plan?: string
    subscriptionStatus?: string
    billingEmail?: string | null
    billingCustomerId?: string | null
    trialEndsAt?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    shipments?: ShipmentCreateNestedManyWithoutCompanyInput
    agreements?: AgreementCreateNestedManyWithoutCompanyInput
    transporterInvoices?: TransporterInvoiceCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    profiles?: CompanyProfileCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: number
    name: string
    webhookSecret: string
    plan?: string
    subscriptionStatus?: string
    billingEmail?: string | null
    billingCustomerId?: string | null
    trialEndsAt?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    shipments?: ShipmentUncheckedCreateNestedManyWithoutCompanyInput
    agreements?: AgreementUncheckedCreateNestedManyWithoutCompanyInput
    transporterInvoices?: TransporterInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    profiles?: CompanyProfileUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    webhookSecret?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    billingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    billingCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    shipments?: ShipmentUpdateManyWithoutCompanyNestedInput
    agreements?: AgreementUpdateManyWithoutCompanyNestedInput
    transporterInvoices?: TransporterInvoiceUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    profiles?: CompanyProfileUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    webhookSecret?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    billingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    billingCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    shipments?: ShipmentUncheckedUpdateManyWithoutCompanyNestedInput
    agreements?: AgreementUncheckedUpdateManyWithoutCompanyNestedInput
    transporterInvoices?: TransporterInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    profiles?: CompanyProfileUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: number
    name: string
    webhookSecret: string
    plan?: string
    subscriptionStatus?: string
    billingEmail?: string | null
    billingCustomerId?: string | null
    trialEndsAt?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    webhookSecret?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    billingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    billingCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    webhookSecret?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    billingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    billingCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyProfileCreateInput = {
    legalName?: string | null
    gstin?: string | null
    pan?: string | null
    tan?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutProfilesInput
  }

  export type CompanyProfileUncheckedCreateInput = {
    id?: number
    companyId?: number | null
    legalName?: string | null
    gstin?: string | null
    pan?: string | null
    tan?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyProfileUpdateInput = {
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    tan?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutProfilesNestedInput
  }

  export type CompanyProfileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    tan?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyProfileCreateManyInput = {
    id?: number
    companyId?: number | null
    legalName?: string | null
    gstin?: string | null
    pan?: string | null
    tan?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyProfileUpdateManyMutationInput = {
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    tan?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyProfileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    tan?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    email: string
    passwordHash: string
    name?: string | null
    phone?: string | null
    role?: $Enums.Role
    approvalStatus?: $Enums.ApprovalStatus
    approvalNote?: string | null
    rejectionReason?: string | null
    reviewedById?: number | null
    reviewedAt?: Date | string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorChannel?: string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutUsersInput
    vendor?: VendorCreateNestedOneWithoutUserInput
    shipments?: ShipmentCreateNestedManyWithoutUserInput
    assignedShipments?: ShipmentCreateNestedManyWithoutAssignedToInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    agreementsReviewed?: AgreementCreateNestedManyWithoutReviewedByInput
    transporterInvoices?: TransporterInvoiceCreateNestedManyWithoutApprovedByInput
    QuoteRequest?: QuoteRequestCreateNestedManyWithoutCreatedByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    twoFactorChallenges?: TwoFactorChallengeCreateNestedManyWithoutUserInput
    userConsents?: UserConsentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    passwordHash: string
    name?: string | null
    phone?: string | null
    role?: $Enums.Role
    approvalStatus?: $Enums.ApprovalStatus
    approvalNote?: string | null
    rejectionReason?: string | null
    reviewedById?: number | null
    reviewedAt?: Date | string | null
    isActive?: boolean
    vendorId?: number | null
    companyId?: number | null
    lastLoginAt?: Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorChannel?: string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    shipments?: ShipmentUncheckedCreateNestedManyWithoutUserInput
    assignedShipments?: ShipmentUncheckedCreateNestedManyWithoutAssignedToInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    agreementsReviewed?: AgreementUncheckedCreateNestedManyWithoutReviewedByInput
    transporterInvoices?: TransporterInvoiceUncheckedCreateNestedManyWithoutApprovedByInput
    QuoteRequest?: QuoteRequestUncheckedCreateNestedManyWithoutCreatedByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    twoFactorChallenges?: TwoFactorChallengeUncheckedCreateNestedManyWithoutUserInput
    userConsents?: UserConsentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorChannel?: NullableStringFieldUpdateOperationsInput | string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutUsersNestedInput
    vendor?: VendorUpdateOneWithoutUserNestedInput
    shipments?: ShipmentUpdateManyWithoutUserNestedInput
    assignedShipments?: ShipmentUpdateManyWithoutAssignedToNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    agreementsReviewed?: AgreementUpdateManyWithoutReviewedByNestedInput
    transporterInvoices?: TransporterInvoiceUpdateManyWithoutApprovedByNestedInput
    QuoteRequest?: QuoteRequestUpdateManyWithoutCreatedByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    twoFactorChallenges?: TwoFactorChallengeUpdateManyWithoutUserNestedInput
    userConsents?: UserConsentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorChannel?: NullableStringFieldUpdateOperationsInput | string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipments?: ShipmentUncheckedUpdateManyWithoutUserNestedInput
    assignedShipments?: ShipmentUncheckedUpdateManyWithoutAssignedToNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    agreementsReviewed?: AgreementUncheckedUpdateManyWithoutReviewedByNestedInput
    transporterInvoices?: TransporterInvoiceUncheckedUpdateManyWithoutApprovedByNestedInput
    QuoteRequest?: QuoteRequestUncheckedUpdateManyWithoutCreatedByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    twoFactorChallenges?: TwoFactorChallengeUncheckedUpdateManyWithoutUserNestedInput
    userConsents?: UserConsentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    passwordHash: string
    name?: string | null
    phone?: string | null
    role?: $Enums.Role
    approvalStatus?: $Enums.ApprovalStatus
    approvalNote?: string | null
    rejectionReason?: string | null
    reviewedById?: number | null
    reviewedAt?: Date | string | null
    isActive?: boolean
    vendorId?: number | null
    companyId?: number | null
    lastLoginAt?: Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorChannel?: string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorChannel?: NullableStringFieldUpdateOperationsInput | string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorChannel?: NullableStringFieldUpdateOperationsInput | string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateInput = {
    tokenHash: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPasswordResetTokensInput
  }

  export type PasswordResetTokenUncheckedCreateInput = {
    id?: number
    userId: number
    tokenHash: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
  }

  export type PasswordResetTokenUpdateInput = {
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPasswordResetTokensNestedInput
  }

  export type PasswordResetTokenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateManyInput = {
    id?: number
    userId: number
    tokenHash: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
  }

  export type PasswordResetTokenUpdateManyMutationInput = {
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorChallengeCreateInput = {
    codeHash: string
    expiresAt: Date | string
    consumed?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTwoFactorChallengesInput
  }

  export type TwoFactorChallengeUncheckedCreateInput = {
    id?: number
    userId: number
    codeHash: string
    expiresAt: Date | string
    consumed?: boolean
    createdAt?: Date | string
  }

  export type TwoFactorChallengeUpdateInput = {
    codeHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consumed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTwoFactorChallengesNestedInput
  }

  export type TwoFactorChallengeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    codeHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consumed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorChallengeCreateManyInput = {
    id?: number
    userId: number
    codeHash: string
    expiresAt: Date | string
    consumed?: boolean
    createdAt?: Date | string
  }

  export type TwoFactorChallengeUpdateManyMutationInput = {
    codeHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consumed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorChallengeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    codeHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consumed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserConsentCreateInput = {
    consentType: string
    status?: $Enums.ConsentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    recordedAt?: Date | string
    user: UserCreateNestedOneWithoutUserConsentsInput
  }

  export type UserConsentUncheckedCreateInput = {
    id?: number
    userId: number
    consentType: string
    status?: $Enums.ConsentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    recordedAt?: Date | string
  }

  export type UserConsentUpdateInput = {
    consentType?: StringFieldUpdateOperationsInput | string
    status?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserConsentsNestedInput
  }

  export type UserConsentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    consentType?: StringFieldUpdateOperationsInput | string
    status?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserConsentCreateManyInput = {
    id?: number
    userId: number
    consentType: string
    status?: $Enums.ConsentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    recordedAt?: Date | string
  }

  export type UserConsentUpdateManyMutationInput = {
    consentType?: StringFieldUpdateOperationsInput | string
    status?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserConsentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    consentType?: StringFieldUpdateOperationsInput | string
    status?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorCreateInput = {
    name: string
    email?: string | null
    phone?: string | null
    baseRate?: number | null
    rating?: number | null
    speed?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutVendorsInput
    profile?: VendorProfileCreateNestedOneWithoutVendorInput
    agreements?: AgreementCreateNestedManyWithoutVendorInput
    rateCards?: RateCardCreateNestedManyWithoutVendorInput
    quoteResponses?: QuoteResponseCreateNestedManyWithoutVendorInput
    shipments?: ShipmentCreateNestedManyWithoutVendorInput
    drivers?: DriverCreateNestedManyWithoutVendorInput
    User?: UserCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateInput = {
    id?: number
    name: string
    email?: string | null
    phone?: string | null
    baseRate?: number | null
    rating?: number | null
    speed?: number | null
    isActive?: boolean
    companyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: VendorProfileUncheckedCreateNestedOneWithoutVendorInput
    agreements?: AgreementUncheckedCreateNestedManyWithoutVendorInput
    rateCards?: RateCardUncheckedCreateNestedManyWithoutVendorInput
    quoteResponses?: QuoteResponseUncheckedCreateNestedManyWithoutVendorInput
    shipments?: ShipmentUncheckedCreateNestedManyWithoutVendorInput
    drivers?: DriverUncheckedCreateNestedManyWithoutVendorInput
    User?: UserUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    baseRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutVendorsNestedInput
    profile?: VendorProfileUpdateOneWithoutVendorNestedInput
    agreements?: AgreementUpdateManyWithoutVendorNestedInput
    rateCards?: RateCardUpdateManyWithoutVendorNestedInput
    quoteResponses?: QuoteResponseUpdateManyWithoutVendorNestedInput
    shipments?: ShipmentUpdateManyWithoutVendorNestedInput
    drivers?: DriverUpdateManyWithoutVendorNestedInput
    User?: UserUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    baseRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: VendorProfileUncheckedUpdateOneWithoutVendorNestedInput
    agreements?: AgreementUncheckedUpdateManyWithoutVendorNestedInput
    rateCards?: RateCardUncheckedUpdateManyWithoutVendorNestedInput
    quoteResponses?: QuoteResponseUncheckedUpdateManyWithoutVendorNestedInput
    shipments?: ShipmentUncheckedUpdateManyWithoutVendorNestedInput
    drivers?: DriverUncheckedUpdateManyWithoutVendorNestedInput
    User?: UserUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type VendorCreateManyInput = {
    id?: number
    name: string
    email?: string | null
    phone?: string | null
    baseRate?: number | null
    rating?: number | null
    speed?: number | null
    isActive?: boolean
    companyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    baseRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    baseRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorProfileCreateInput = {
    legalName?: string | null
    gstin?: string | null
    pan?: string | null
    tan?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    rcmEligible?: boolean
    gstRegistrationType?: string | null
    contactPerson?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutProfileInput
  }

  export type VendorProfileUncheckedCreateInput = {
    id?: number
    vendorId: number
    legalName?: string | null
    gstin?: string | null
    pan?: string | null
    tan?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    rcmEligible?: boolean
    gstRegistrationType?: string | null
    contactPerson?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorProfileUpdateInput = {
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    tan?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    rcmEligible?: BoolFieldUpdateOperationsInput | boolean
    gstRegistrationType?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutProfileNestedInput
  }

  export type VendorProfileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    tan?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    rcmEligible?: BoolFieldUpdateOperationsInput | boolean
    gstRegistrationType?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorProfileCreateManyInput = {
    id?: number
    vendorId: number
    legalName?: string | null
    gstin?: string | null
    pan?: string | null
    tan?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    rcmEligible?: boolean
    gstRegistrationType?: string | null
    contactPerson?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorProfileUpdateManyMutationInput = {
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    tan?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    rcmEligible?: BoolFieldUpdateOperationsInput | boolean
    gstRegistrationType?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorProfileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    tan?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    rcmEligible?: BoolFieldUpdateOperationsInput | boolean
    gstRegistrationType?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverCreateInput = {
    name: string
    phone?: string | null
    licenseNumber?: string | null
    vehicleNumber?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutDriversInput
  }

  export type DriverUncheckedCreateInput = {
    id?: number
    vendorId: number
    name: string
    phone?: string | null
    licenseNumber?: string | null
    vehicleNumber?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DriverUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutDriversNestedInput
  }

  export type DriverUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverCreateManyInput = {
    id?: number
    vendorId: number
    name: string
    phone?: string | null
    licenseNumber?: string | null
    vehicleNumber?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DriverUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgreementCreateInput = {
    title: string
    referenceCode: string
    status?: string
    effectiveFrom?: Date | string | null
    effectiveTo?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutAgreementsInput
    reviewedBy?: UserCreateNestedOneWithoutAgreementsReviewedInput
    rateCards?: RateCardCreateNestedManyWithoutAgreementInput
    Company?: CompanyCreateNestedOneWithoutAgreementsInput
  }

  export type AgreementUncheckedCreateInput = {
    id?: number
    vendorId: number
    title: string
    referenceCode: string
    status?: string
    effectiveFrom?: Date | string | null
    effectiveTo?: Date | string | null
    notes?: string | null
    reviewedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: number | null
    rateCards?: RateCardUncheckedCreateNestedManyWithoutAgreementInput
  }

  export type AgreementUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    referenceCode?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutAgreementsNestedInput
    reviewedBy?: UserUpdateOneWithoutAgreementsReviewedNestedInput
    rateCards?: RateCardUpdateManyWithoutAgreementNestedInput
    Company?: CompanyUpdateOneWithoutAgreementsNestedInput
  }

  export type AgreementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    referenceCode?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    rateCards?: RateCardUncheckedUpdateManyWithoutAgreementNestedInput
  }

  export type AgreementCreateManyInput = {
    id?: number
    vendorId: number
    title: string
    referenceCode: string
    status?: string
    effectiveFrom?: Date | string | null
    effectiveTo?: Date | string | null
    notes?: string | null
    reviewedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: number | null
  }

  export type AgreementUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    referenceCode?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgreementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    referenceCode?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RateCardCreateInput = {
    routeName: string
    origin: string
    destination: string
    distanceKm?: number | null
    ratePerKm: number
    uom: string
    vehicleType: string
    effectiveFrom?: Date | string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agreement: AgreementCreateNestedOneWithoutRateCardsInput
    Vendor?: VendorCreateNestedOneWithoutRateCardsInput
    shipments?: ShipmentCreateNestedManyWithoutRateCardInput
  }

  export type RateCardUncheckedCreateInput = {
    id?: number
    agreementId: number
    routeName: string
    origin: string
    destination: string
    distanceKm?: number | null
    ratePerKm: number
    uom: string
    vehicleType: string
    effectiveFrom?: Date | string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendorId?: number | null
    shipments?: ShipmentUncheckedCreateNestedManyWithoutRateCardInput
  }

  export type RateCardUpdateInput = {
    routeName?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    distanceKm?: NullableFloatFieldUpdateOperationsInput | number | null
    ratePerKm?: FloatFieldUpdateOperationsInput | number
    uom?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agreement?: AgreementUpdateOneRequiredWithoutRateCardsNestedInput
    Vendor?: VendorUpdateOneWithoutRateCardsNestedInput
    shipments?: ShipmentUpdateManyWithoutRateCardNestedInput
  }

  export type RateCardUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    agreementId?: IntFieldUpdateOperationsInput | number
    routeName?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    distanceKm?: NullableFloatFieldUpdateOperationsInput | number | null
    ratePerKm?: FloatFieldUpdateOperationsInput | number
    uom?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    shipments?: ShipmentUncheckedUpdateManyWithoutRateCardNestedInput
  }

  export type RateCardCreateManyInput = {
    id?: number
    agreementId: number
    routeName: string
    origin: string
    destination: string
    distanceKm?: number | null
    ratePerKm: number
    uom: string
    vehicleType: string
    effectiveFrom?: Date | string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendorId?: number | null
  }

  export type RateCardUpdateManyMutationInput = {
    routeName?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    distanceKm?: NullableFloatFieldUpdateOperationsInput | number | null
    ratePerKm?: FloatFieldUpdateOperationsInput | number
    uom?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RateCardUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    agreementId?: IntFieldUpdateOperationsInput | number
    routeName?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    distanceKm?: NullableFloatFieldUpdateOperationsInput | number | null
    ratePerKm?: FloatFieldUpdateOperationsInput | number
    uom?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuoteRequestCreateInput = {
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.QuoteStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutQuoteRequestInput
    responses?: QuoteResponseCreateNestedManyWithoutQuoteRequestInput
    approvedResponse?: QuoteResponseCreateNestedOneWithoutApprovedForInput
    shipment?: ShipmentCreateNestedOneWithoutQuoteRequestInput
  }

  export type QuoteRequestUncheckedCreateInput = {
    id?: number
    createdByUserId: number
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.QuoteStatus
    notes?: string | null
    approvedResponseId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: QuoteResponseUncheckedCreateNestedManyWithoutQuoteRequestInput
    shipment?: ShipmentUncheckedCreateNestedOneWithoutQuoteRequestInput
  }

  export type QuoteRequestUpdateInput = {
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutQuoteRequestNestedInput
    responses?: QuoteResponseUpdateManyWithoutQuoteRequestNestedInput
    approvedResponse?: QuoteResponseUpdateOneWithoutApprovedForNestedInput
    shipment?: ShipmentUpdateOneWithoutQuoteRequestNestedInput
  }

  export type QuoteRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdByUserId?: IntFieldUpdateOperationsInput | number
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedResponseId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: QuoteResponseUncheckedUpdateManyWithoutQuoteRequestNestedInput
    shipment?: ShipmentUncheckedUpdateOneWithoutQuoteRequestNestedInput
  }

  export type QuoteRequestCreateManyInput = {
    id?: number
    createdByUserId: number
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.QuoteStatus
    notes?: string | null
    approvedResponseId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuoteRequestUpdateManyMutationInput = {
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdByUserId?: IntFieldUpdateOperationsInput | number
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedResponseId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteResponseCreateInput = {
    quotedPrice?: number | null
    estimatedDelivery?: Date | string | null
    expiresAt?: Date | string | null
    status?: $Enums.QuoteResponseStatus
    consentStatus?: $Enums.ConsentStatus
    notes?: string | null
    transporterNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quoteRequest: QuoteRequestCreateNestedOneWithoutResponsesInput
    vendor: VendorCreateNestedOneWithoutQuoteResponsesInput
    shipment?: ShipmentCreateNestedOneWithoutTransporterQuoteInput
    approvedFor?: QuoteRequestCreateNestedOneWithoutApprovedResponseInput
    consentLogs?: ConsentLogCreateNestedManyWithoutQuoteResponseInput
  }

  export type QuoteResponseUncheckedCreateInput = {
    id?: number
    quoteRequestId: number
    vendorId: number
    quotedPrice?: number | null
    estimatedDelivery?: Date | string | null
    expiresAt?: Date | string | null
    status?: $Enums.QuoteResponseStatus
    consentStatus?: $Enums.ConsentStatus
    notes?: string | null
    transporterNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shipment?: ShipmentUncheckedCreateNestedOneWithoutTransporterQuoteInput
    approvedFor?: QuoteRequestUncheckedCreateNestedOneWithoutApprovedResponseInput
    consentLogs?: ConsentLogUncheckedCreateNestedManyWithoutQuoteResponseInput
  }

  export type QuoteResponseUpdateInput = {
    quotedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumQuoteResponseStatusFieldUpdateOperationsInput | $Enums.QuoteResponseStatus
    consentStatus?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    transporterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quoteRequest?: QuoteRequestUpdateOneRequiredWithoutResponsesNestedInput
    vendor?: VendorUpdateOneRequiredWithoutQuoteResponsesNestedInput
    shipment?: ShipmentUpdateOneWithoutTransporterQuoteNestedInput
    approvedFor?: QuoteRequestUpdateOneWithoutApprovedResponseNestedInput
    consentLogs?: ConsentLogUpdateManyWithoutQuoteResponseNestedInput
  }

  export type QuoteResponseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    quoteRequestId?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    quotedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumQuoteResponseStatusFieldUpdateOperationsInput | $Enums.QuoteResponseStatus
    consentStatus?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    transporterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipment?: ShipmentUncheckedUpdateOneWithoutTransporterQuoteNestedInput
    approvedFor?: QuoteRequestUncheckedUpdateOneWithoutApprovedResponseNestedInput
    consentLogs?: ConsentLogUncheckedUpdateManyWithoutQuoteResponseNestedInput
  }

  export type QuoteResponseCreateManyInput = {
    id?: number
    quoteRequestId: number
    vendorId: number
    quotedPrice?: number | null
    estimatedDelivery?: Date | string | null
    expiresAt?: Date | string | null
    status?: $Enums.QuoteResponseStatus
    consentStatus?: $Enums.ConsentStatus
    notes?: string | null
    transporterNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuoteResponseUpdateManyMutationInput = {
    quotedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumQuoteResponseStatusFieldUpdateOperationsInput | $Enums.QuoteResponseStatus
    consentStatus?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    transporterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteResponseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    quoteRequestId?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    quotedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumQuoteResponseStatusFieldUpdateOperationsInput | $Enums.QuoteResponseStatus
    consentStatus?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    transporterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsentLogCreateInput = {
    statusBefore: $Enums.ConsentStatus
    statusAfter: $Enums.ConsentStatus
    note?: string | null
    recordedAt?: Date | string
    quoteResponse: QuoteResponseCreateNestedOneWithoutConsentLogsInput
    shipment?: ShipmentCreateNestedOneWithoutConsentLogsInput
  }

  export type ConsentLogUncheckedCreateInput = {
    id?: number
    quoteResponseId: number
    shipmentId?: number | null
    statusBefore: $Enums.ConsentStatus
    statusAfter: $Enums.ConsentStatus
    note?: string | null
    recordedAt?: Date | string
  }

  export type ConsentLogUpdateInput = {
    statusBefore?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    statusAfter?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quoteResponse?: QuoteResponseUpdateOneRequiredWithoutConsentLogsNestedInput
    shipment?: ShipmentUpdateOneWithoutConsentLogsNestedInput
  }

  export type ConsentLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    quoteResponseId?: IntFieldUpdateOperationsInput | number
    shipmentId?: NullableIntFieldUpdateOperationsInput | number | null
    statusBefore?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    statusAfter?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsentLogCreateManyInput = {
    id?: number
    quoteResponseId: number
    shipmentId?: number | null
    statusBefore: $Enums.ConsentStatus
    statusAfter: $Enums.ConsentStatus
    note?: string | null
    recordedAt?: Date | string
  }

  export type ConsentLogUpdateManyMutationInput = {
    statusBefore?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    statusAfter?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsentLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    quoteResponseId?: IntFieldUpdateOperationsInput | number
    shipmentId?: NullableIntFieldUpdateOperationsInput | number | null
    statusBefore?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    statusAfter?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShipmentCreateInput = {
    agreementId?: number | null
    trackingNumber?: string | null
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.ShipmentStatus
    bookingStatus?: $Enums.BookingStatus | null
    paymentStatus?: $Enums.PaymentStatus | null
    cost?: number | null
    distance?: number | null
    estimatedDelivery?: Date | string | null
    pickupTime?: Date | string | null
    deliveryTime?: Date | string | null
    assignedDriver?: string | null
    driverPhone?: string | null
    driverEta?: Date | string | null
    transporterResponseNotes?: string | null
    notes?: string | null
    ewayBillNumber?: string | null
    gstInvoiceId?: number | null
    complianceStatus?: $Enums.ComplianceStatus
    source?: string
    podStatus?: string
    podUrl?: string | null
    podNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutShipmentsInput
    company?: CompanyCreateNestedOneWithoutShipmentsInput
    quoteRequest?: QuoteRequestCreateNestedOneWithoutShipmentInput
    transporterQuote?: QuoteResponseCreateNestedOneWithoutShipmentInput
    rateCard?: RateCardCreateNestedOneWithoutShipmentsInput
    vendor?: VendorCreateNestedOneWithoutShipmentsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedShipmentsInput
    statusHistory?: StatusHistoryCreateNestedManyWithoutShipmentInput
    complianceDocs?: ComplianceDocumentCreateNestedManyWithoutShipmentInput
    payments?: PaymentCreateNestedManyWithoutShipmentInput
    invoice?: InvoiceCreateNestedOneWithoutShipmentInput
    consentLogs?: ConsentLogCreateNestedManyWithoutShipmentInput
    transporterInvoices?: TransporterInvoiceCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentUncheckedCreateInput = {
    id?: number
    userId: number
    companyId?: number | null
    quoteRequestId?: number | null
    transporterQuoteId?: number | null
    selectedVendorId?: number | null
    agreementId?: number | null
    rateCardId?: number | null
    trackingNumber?: string | null
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.ShipmentStatus
    bookingStatus?: $Enums.BookingStatus | null
    paymentStatus?: $Enums.PaymentStatus | null
    cost?: number | null
    distance?: number | null
    estimatedDelivery?: Date | string | null
    pickupTime?: Date | string | null
    deliveryTime?: Date | string | null
    assignedToId?: number | null
    assignedDriver?: string | null
    driverPhone?: string | null
    driverEta?: Date | string | null
    transporterResponseNotes?: string | null
    notes?: string | null
    ewayBillNumber?: string | null
    gstInvoiceId?: number | null
    complianceStatus?: $Enums.ComplianceStatus
    source?: string
    podStatus?: string
    podUrl?: string | null
    podNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    statusHistory?: StatusHistoryUncheckedCreateNestedManyWithoutShipmentInput
    complianceDocs?: ComplianceDocumentUncheckedCreateNestedManyWithoutShipmentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutShipmentInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutShipmentInput
    consentLogs?: ConsentLogUncheckedCreateNestedManyWithoutShipmentInput
    transporterInvoices?: TransporterInvoiceUncheckedCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentUpdateInput = {
    agreementId?: NullableIntFieldUpdateOperationsInput | number | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedDriver?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    driverEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transporterResponseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ewayBillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstInvoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    source?: StringFieldUpdateOperationsInput | string
    podStatus?: StringFieldUpdateOperationsInput | string
    podUrl?: NullableStringFieldUpdateOperationsInput | string | null
    podNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutShipmentsNestedInput
    company?: CompanyUpdateOneWithoutShipmentsNestedInput
    quoteRequest?: QuoteRequestUpdateOneWithoutShipmentNestedInput
    transporterQuote?: QuoteResponseUpdateOneWithoutShipmentNestedInput
    rateCard?: RateCardUpdateOneWithoutShipmentsNestedInput
    vendor?: VendorUpdateOneWithoutShipmentsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedShipmentsNestedInput
    statusHistory?: StatusHistoryUpdateManyWithoutShipmentNestedInput
    complianceDocs?: ComplianceDocumentUpdateManyWithoutShipmentNestedInput
    payments?: PaymentUpdateManyWithoutShipmentNestedInput
    invoice?: InvoiceUpdateOneWithoutShipmentNestedInput
    consentLogs?: ConsentLogUpdateManyWithoutShipmentNestedInput
    transporterInvoices?: TransporterInvoiceUpdateManyWithoutShipmentNestedInput
  }

  export type ShipmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    quoteRequestId?: NullableIntFieldUpdateOperationsInput | number | null
    transporterQuoteId?: NullableIntFieldUpdateOperationsInput | number | null
    selectedVendorId?: NullableIntFieldUpdateOperationsInput | number | null
    agreementId?: NullableIntFieldUpdateOperationsInput | number | null
    rateCardId?: NullableIntFieldUpdateOperationsInput | number | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedDriver?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    driverEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transporterResponseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ewayBillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstInvoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    source?: StringFieldUpdateOperationsInput | string
    podStatus?: StringFieldUpdateOperationsInput | string
    podUrl?: NullableStringFieldUpdateOperationsInput | string | null
    podNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusHistory?: StatusHistoryUncheckedUpdateManyWithoutShipmentNestedInput
    complianceDocs?: ComplianceDocumentUncheckedUpdateManyWithoutShipmentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutShipmentNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutShipmentNestedInput
    consentLogs?: ConsentLogUncheckedUpdateManyWithoutShipmentNestedInput
    transporterInvoices?: TransporterInvoiceUncheckedUpdateManyWithoutShipmentNestedInput
  }

  export type ShipmentCreateManyInput = {
    id?: number
    userId: number
    companyId?: number | null
    quoteRequestId?: number | null
    transporterQuoteId?: number | null
    selectedVendorId?: number | null
    agreementId?: number | null
    rateCardId?: number | null
    trackingNumber?: string | null
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.ShipmentStatus
    bookingStatus?: $Enums.BookingStatus | null
    paymentStatus?: $Enums.PaymentStatus | null
    cost?: number | null
    distance?: number | null
    estimatedDelivery?: Date | string | null
    pickupTime?: Date | string | null
    deliveryTime?: Date | string | null
    assignedToId?: number | null
    assignedDriver?: string | null
    driverPhone?: string | null
    driverEta?: Date | string | null
    transporterResponseNotes?: string | null
    notes?: string | null
    ewayBillNumber?: string | null
    gstInvoiceId?: number | null
    complianceStatus?: $Enums.ComplianceStatus
    source?: string
    podStatus?: string
    podUrl?: string | null
    podNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShipmentUpdateManyMutationInput = {
    agreementId?: NullableIntFieldUpdateOperationsInput | number | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedDriver?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    driverEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transporterResponseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ewayBillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstInvoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    source?: StringFieldUpdateOperationsInput | string
    podStatus?: StringFieldUpdateOperationsInput | string
    podUrl?: NullableStringFieldUpdateOperationsInput | string | null
    podNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShipmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    quoteRequestId?: NullableIntFieldUpdateOperationsInput | number | null
    transporterQuoteId?: NullableIntFieldUpdateOperationsInput | number | null
    selectedVendorId?: NullableIntFieldUpdateOperationsInput | number | null
    agreementId?: NullableIntFieldUpdateOperationsInput | number | null
    rateCardId?: NullableIntFieldUpdateOperationsInput | number | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedDriver?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    driverEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transporterResponseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ewayBillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstInvoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    source?: StringFieldUpdateOperationsInput | string
    podStatus?: StringFieldUpdateOperationsInput | string
    podUrl?: NullableStringFieldUpdateOperationsInput | string | null
    podNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusHistoryCreateInput = {
    status: $Enums.ShipmentStatus
    notes?: string | null
    latitude?: number | null
    longitude?: number | null
    location?: string | null
    updatedBy?: number | null
    timestamp?: Date | string
    shipment: ShipmentCreateNestedOneWithoutStatusHistoryInput
  }

  export type StatusHistoryUncheckedCreateInput = {
    id?: number
    shipmentId: number
    status: $Enums.ShipmentStatus
    notes?: string | null
    latitude?: number | null
    longitude?: number | null
    location?: string | null
    updatedBy?: number | null
    timestamp?: Date | string
  }

  export type StatusHistoryUpdateInput = {
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    shipment?: ShipmentUpdateOneRequiredWithoutStatusHistoryNestedInput
  }

  export type StatusHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipmentId?: IntFieldUpdateOperationsInput | number
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusHistoryCreateManyInput = {
    id?: number
    shipmentId: number
    status: $Enums.ShipmentStatus
    notes?: string | null
    latitude?: number | null
    longitude?: number | null
    location?: string | null
    updatedBy?: number | null
    timestamp?: Date | string
  }

  export type StatusHistoryUpdateManyMutationInput = {
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipmentId?: IntFieldUpdateOperationsInput | number
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    invoiceNumber: string
    status?: $Enums.InvoiceStatus
    issuedAt?: Date | string | null
    dueDate?: Date | string | null
    subtotal?: number
    taxTotal?: number
    grandTotal?: number
    lineItems: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    shipment: ShipmentCreateNestedOneWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    Company?: CompanyCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: number
    shipmentId: number
    invoiceNumber: string
    status?: $Enums.InvoiceStatus
    issuedAt?: Date | string | null
    dueDate?: Date | string | null
    subtotal?: number
    taxTotal?: number
    grandTotal?: number
    lineItems: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: number | null
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxTotal?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    lineItems?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipment?: ShipmentUpdateOneRequiredWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    Company?: CompanyUpdateOneWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipmentId?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxTotal?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    lineItems?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: number
    shipmentId: number
    invoiceNumber: string
    status?: $Enums.InvoiceStatus
    issuedAt?: Date | string | null
    dueDate?: Date | string | null
    subtotal?: number
    taxTotal?: number
    grandTotal?: number
    lineItems: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: number | null
  }

  export type InvoiceUpdateManyMutationInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxTotal?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    lineItems?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipmentId?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxTotal?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    lineItems?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PaymentCreateInput = {
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    gateway?: string
    transactionRef?: string | null
    authorizedAt?: Date | string | null
    capturedAt?: Date | string | null
    failureReason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tdsAmount?: number | null
    tcsAmount?: number | null
    rcmLiability?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shipment: ShipmentCreateNestedOneWithoutPaymentsInput
    invoice: InvoiceCreateNestedOneWithoutPaymentsInput
    events?: PaymentEventCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: number
    shipmentId: number
    invoiceId: number
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    gateway?: string
    transactionRef?: string | null
    authorizedAt?: Date | string | null
    capturedAt?: Date | string | null
    failureReason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tdsAmount?: number | null
    tcsAmount?: number | null
    rcmLiability?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: PaymentEventUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gateway?: StringFieldUpdateOperationsInput | string
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    authorizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tdsAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    tcsAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    rcmLiability?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipment?: ShipmentUpdateOneRequiredWithoutPaymentsNestedInput
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentsNestedInput
    events?: PaymentEventUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipmentId?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gateway?: StringFieldUpdateOperationsInput | string
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    authorizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tdsAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    tcsAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    rcmLiability?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: PaymentEventUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentCreateManyInput = {
    id?: number
    shipmentId: number
    invoiceId: number
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    gateway?: string
    transactionRef?: string | null
    authorizedAt?: Date | string | null
    capturedAt?: Date | string | null
    failureReason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tdsAmount?: number | null
    tcsAmount?: number | null
    rcmLiability?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gateway?: StringFieldUpdateOperationsInput | string
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    authorizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tdsAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    tcsAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    rcmLiability?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipmentId?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gateway?: StringFieldUpdateOperationsInput | string
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    authorizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tdsAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    tcsAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    rcmLiability?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentEventCreateInput = {
    eventType: string
    details?: NullableJsonNullValueInput | InputJsonValue
    recordedAt?: Date | string
    payment: PaymentCreateNestedOneWithoutEventsInput
  }

  export type PaymentEventUncheckedCreateInput = {
    id?: number
    paymentId: number
    eventType: string
    details?: NullableJsonNullValueInput | InputJsonValue
    recordedAt?: Date | string
  }

  export type PaymentEventUpdateInput = {
    eventType?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUpdateOneRequiredWithoutEventsNestedInput
  }

  export type PaymentEventUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    paymentId?: IntFieldUpdateOperationsInput | number
    eventType?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentEventCreateManyInput = {
    id?: number
    paymentId: number
    eventType: string
    details?: NullableJsonNullValueInput | InputJsonValue
    recordedAt?: Date | string
  }

  export type PaymentEventUpdateManyMutationInput = {
    eventType?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentEventUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    paymentId?: IntFieldUpdateOperationsInput | number
    eventType?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransporterInvoiceCreateInput = {
    invoiceNumber: string
    invoiceDate: Date | string
    invoiceAmount: number
    invoiceUrl: string
    approvalStatus?: string
    rejectionNotes?: string | null
    postedToErpAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutTransporterInvoicesInput
    shipment: ShipmentCreateNestedOneWithoutTransporterInvoicesInput
    approvedBy?: UserCreateNestedOneWithoutTransporterInvoicesInput
  }

  export type TransporterInvoiceUncheckedCreateInput = {
    id?: number
    companyId: number
    shipmentId: number
    invoiceNumber: string
    invoiceDate: Date | string
    invoiceAmount: number
    invoiceUrl: string
    approvalStatus?: string
    rejectionNotes?: string | null
    postedToErpAt?: Date | string | null
    approvedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransporterInvoiceUpdateInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceAmount?: FloatFieldUpdateOperationsInput | number
    invoiceUrl?: StringFieldUpdateOperationsInput | string
    approvalStatus?: StringFieldUpdateOperationsInput | string
    rejectionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    postedToErpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutTransporterInvoicesNestedInput
    shipment?: ShipmentUpdateOneRequiredWithoutTransporterInvoicesNestedInput
    approvedBy?: UserUpdateOneWithoutTransporterInvoicesNestedInput
  }

  export type TransporterInvoiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    shipmentId?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceAmount?: FloatFieldUpdateOperationsInput | number
    invoiceUrl?: StringFieldUpdateOperationsInput | string
    approvalStatus?: StringFieldUpdateOperationsInput | string
    rejectionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    postedToErpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransporterInvoiceCreateManyInput = {
    id?: number
    companyId: number
    shipmentId: number
    invoiceNumber: string
    invoiceDate: Date | string
    invoiceAmount: number
    invoiceUrl: string
    approvalStatus?: string
    rejectionNotes?: string | null
    postedToErpAt?: Date | string | null
    approvedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransporterInvoiceUpdateManyMutationInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceAmount?: FloatFieldUpdateOperationsInput | number
    invoiceUrl?: StringFieldUpdateOperationsInput | string
    approvalStatus?: StringFieldUpdateOperationsInput | string
    rejectionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    postedToErpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransporterInvoiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    shipmentId?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceAmount?: FloatFieldUpdateOperationsInput | number
    invoiceUrl?: StringFieldUpdateOperationsInput | string
    approvalStatus?: StringFieldUpdateOperationsInput | string
    rejectionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    postedToErpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    title: string
    message: string
    type: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRead?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: number
    userId: number
    title: string
    message: string
    type: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: number
    userId: number
    title: string
    message: string
    type: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    action: string
    entityType: string
    entityId?: number | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: number
    userId?: number | null
    action: string
    entityType: string
    entityId?: number | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: number
    userId?: number | null
    action: string
    entityType: string
    entityId?: number | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceDocumentCreateInput = {
    type: $Enums.DocumentType
    status?: $Enums.ComplianceStatus
    issuedAt?: Date | string | null
    fileUrl?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shipment: ShipmentCreateNestedOneWithoutComplianceDocsInput
    events?: ComplianceEventCreateNestedManyWithoutDocumentInput
  }

  export type ComplianceDocumentUncheckedCreateInput = {
    id?: number
    shipmentId: number
    type: $Enums.DocumentType
    status?: $Enums.ComplianceStatus
    issuedAt?: Date | string | null
    fileUrl?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: ComplianceEventUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type ComplianceDocumentUpdateInput = {
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipment?: ShipmentUpdateOneRequiredWithoutComplianceDocsNestedInput
    events?: ComplianceEventUpdateManyWithoutDocumentNestedInput
  }

  export type ComplianceDocumentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipmentId?: IntFieldUpdateOperationsInput | number
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: ComplianceEventUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type ComplianceDocumentCreateManyInput = {
    id?: number
    shipmentId: number
    type: $Enums.DocumentType
    status?: $Enums.ComplianceStatus
    issuedAt?: Date | string | null
    fileUrl?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplianceDocumentUpdateManyMutationInput = {
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceDocumentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipmentId?: IntFieldUpdateOperationsInput | number
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceEventCreateInput = {
    eventType: string
    details?: NullableJsonNullValueInput | InputJsonValue
    recordedAt?: Date | string
    document: ComplianceDocumentCreateNestedOneWithoutEventsInput
  }

  export type ComplianceEventUncheckedCreateInput = {
    id?: number
    documentId: number
    eventType: string
    details?: NullableJsonNullValueInput | InputJsonValue
    recordedAt?: Date | string
  }

  export type ComplianceEventUpdateInput = {
    eventType?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: ComplianceDocumentUpdateOneRequiredWithoutEventsNestedInput
  }

  export type ComplianceEventUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    documentId?: IntFieldUpdateOperationsInput | number
    eventType?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceEventCreateManyInput = {
    id?: number
    documentId: number
    eventType: string
    details?: NullableJsonNullValueInput | InputJsonValue
    recordedAt?: Date | string
  }

  export type ComplianceEventUpdateManyMutationInput = {
    eventType?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceEventUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    documentId?: IntFieldUpdateOperationsInput | number
    eventType?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type ShipmentListRelationFilter = {
    every?: ShipmentWhereInput
    some?: ShipmentWhereInput
    none?: ShipmentWhereInput
  }

  export type AgreementListRelationFilter = {
    every?: AgreementWhereInput
    some?: AgreementWhereInput
    none?: AgreementWhereInput
  }

  export type TransporterInvoiceListRelationFilter = {
    every?: TransporterInvoiceWhereInput
    some?: TransporterInvoiceWhereInput
    none?: TransporterInvoiceWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type CompanyProfileListRelationFilter = {
    every?: CompanyProfileWhereInput
    some?: CompanyProfileWhereInput
    none?: CompanyProfileWhereInput
  }

  export type VendorListRelationFilter = {
    every?: VendorWhereInput
    some?: VendorWhereInput
    none?: VendorWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShipmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgreementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransporterInvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    webhookSecret?: SortOrder
    plan?: SortOrder
    subscriptionStatus?: SortOrder
    billingEmail?: SortOrder
    billingCustomerId?: SortOrder
    trialEndsAt?: SortOrder
    settings?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    webhookSecret?: SortOrder
    plan?: SortOrder
    subscriptionStatus?: SortOrder
    billingEmail?: SortOrder
    billingCustomerId?: SortOrder
    trialEndsAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    webhookSecret?: SortOrder
    plan?: SortOrder
    subscriptionStatus?: SortOrder
    billingEmail?: SortOrder
    billingCustomerId?: SortOrder
    trialEndsAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CompanyNullableRelationFilter = {
    is?: CompanyWhereInput | null
    isNot?: CompanyWhereInput | null
  }

  export type CompanyProfileCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    legalName?: SortOrder
    gstin?: SortOrder
    pan?: SortOrder
    tan?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyProfileAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type CompanyProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    legalName?: SortOrder
    gstin?: SortOrder
    pan?: SortOrder
    tan?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyProfileMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    legalName?: SortOrder
    gstin?: SortOrder
    pan?: SortOrder
    tan?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyProfileSumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type EnumApprovalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusFilter<$PrismaModel> | $Enums.ApprovalStatus
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type VendorNullableRelationFilter = {
    is?: VendorWhereInput | null
    isNot?: VendorWhereInput | null
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type QuoteRequestListRelationFilter = {
    every?: QuoteRequestWhereInput
    some?: QuoteRequestWhereInput
    none?: QuoteRequestWhereInput
  }

  export type PasswordResetTokenListRelationFilter = {
    every?: PasswordResetTokenWhereInput
    some?: PasswordResetTokenWhereInput
    none?: PasswordResetTokenWhereInput
  }

  export type TwoFactorChallengeListRelationFilter = {
    every?: TwoFactorChallengeWhereInput
    some?: TwoFactorChallengeWhereInput
    none?: TwoFactorChallengeWhereInput
  }

  export type UserConsentListRelationFilter = {
    every?: UserConsentWhereInput
    some?: UserConsentWhereInput
    none?: UserConsentWhereInput
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuoteRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasswordResetTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TwoFactorChallengeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserConsentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    approvalStatus?: SortOrder
    approvalNote?: SortOrder
    rejectionReason?: SortOrder
    reviewedById?: SortOrder
    reviewedAt?: SortOrder
    isActive?: SortOrder
    vendorId?: SortOrder
    companyId?: SortOrder
    lastLoginAt?: SortOrder
    notificationPreferences?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorChannel?: SortOrder
    allowedIpRanges?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    reviewedById?: SortOrder
    vendorId?: SortOrder
    companyId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    approvalStatus?: SortOrder
    approvalNote?: SortOrder
    rejectionReason?: SortOrder
    reviewedById?: SortOrder
    reviewedAt?: SortOrder
    isActive?: SortOrder
    vendorId?: SortOrder
    companyId?: SortOrder
    lastLoginAt?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorChannel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    approvalStatus?: SortOrder
    approvalNote?: SortOrder
    rejectionReason?: SortOrder
    reviewedById?: SortOrder
    reviewedAt?: SortOrder
    isActive?: SortOrder
    vendorId?: SortOrder
    companyId?: SortOrder
    lastLoginAt?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorChannel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    reviewedById?: SortOrder
    vendorId?: SortOrder
    companyId?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type EnumApprovalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApprovalStatusFilter<$PrismaModel>
    _max?: NestedEnumApprovalStatusFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type PasswordResetTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type PasswordResetTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type TwoFactorChallengeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    codeHash?: SortOrder
    expiresAt?: SortOrder
    consumed?: SortOrder
    createdAt?: SortOrder
  }

  export type TwoFactorChallengeAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type TwoFactorChallengeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    codeHash?: SortOrder
    expiresAt?: SortOrder
    consumed?: SortOrder
    createdAt?: SortOrder
  }

  export type TwoFactorChallengeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    codeHash?: SortOrder
    expiresAt?: SortOrder
    consumed?: SortOrder
    createdAt?: SortOrder
  }

  export type TwoFactorChallengeSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EnumConsentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsentStatus | EnumConsentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConsentStatus[] | ListEnumConsentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsentStatus[] | ListEnumConsentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConsentStatusFilter<$PrismaModel> | $Enums.ConsentStatus
  }

  export type UserConsentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    consentType?: SortOrder
    status?: SortOrder
    metadata?: SortOrder
    recordedAt?: SortOrder
  }

  export type UserConsentAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserConsentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    consentType?: SortOrder
    status?: SortOrder
    recordedAt?: SortOrder
  }

  export type UserConsentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    consentType?: SortOrder
    status?: SortOrder
    recordedAt?: SortOrder
  }

  export type UserConsentSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EnumConsentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsentStatus | EnumConsentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConsentStatus[] | ListEnumConsentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsentStatus[] | ListEnumConsentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConsentStatusWithAggregatesFilter<$PrismaModel> | $Enums.ConsentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConsentStatusFilter<$PrismaModel>
    _max?: NestedEnumConsentStatusFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type VendorProfileNullableRelationFilter = {
    is?: VendorProfileWhereInput | null
    isNot?: VendorProfileWhereInput | null
  }

  export type RateCardListRelationFilter = {
    every?: RateCardWhereInput
    some?: RateCardWhereInput
    none?: RateCardWhereInput
  }

  export type QuoteResponseListRelationFilter = {
    every?: QuoteResponseWhereInput
    some?: QuoteResponseWhereInput
    none?: QuoteResponseWhereInput
  }

  export type DriverListRelationFilter = {
    every?: DriverWhereInput
    some?: DriverWhereInput
    none?: DriverWhereInput
  }

  export type RateCardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuoteResponseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DriverOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    baseRate?: SortOrder
    rating?: SortOrder
    speed?: SortOrder
    isActive?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorAvgOrderByAggregateInput = {
    id?: SortOrder
    baseRate?: SortOrder
    rating?: SortOrder
    speed?: SortOrder
    companyId?: SortOrder
  }

  export type VendorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    baseRate?: SortOrder
    rating?: SortOrder
    speed?: SortOrder
    isActive?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    baseRate?: SortOrder
    rating?: SortOrder
    speed?: SortOrder
    isActive?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorSumOrderByAggregateInput = {
    id?: SortOrder
    baseRate?: SortOrder
    rating?: SortOrder
    speed?: SortOrder
    companyId?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type VendorRelationFilter = {
    is?: VendorWhereInput
    isNot?: VendorWhereInput
  }

  export type VendorProfileCountOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    legalName?: SortOrder
    gstin?: SortOrder
    pan?: SortOrder
    tan?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    rcmEligible?: SortOrder
    gstRegistrationType?: SortOrder
    contactPerson?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorProfileAvgOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
  }

  export type VendorProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    legalName?: SortOrder
    gstin?: SortOrder
    pan?: SortOrder
    tan?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    rcmEligible?: SortOrder
    gstRegistrationType?: SortOrder
    contactPerson?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorProfileMinOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    legalName?: SortOrder
    gstin?: SortOrder
    pan?: SortOrder
    tan?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    rcmEligible?: SortOrder
    gstRegistrationType?: SortOrder
    contactPerson?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorProfileSumOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
  }

  export type DriverCountOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    licenseNumber?: SortOrder
    vehicleNumber?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DriverAvgOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
  }

  export type DriverMaxOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    licenseNumber?: SortOrder
    vehicleNumber?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DriverMinOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    licenseNumber?: SortOrder
    vehicleNumber?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DriverSumOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AgreementCountOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    title?: SortOrder
    referenceCode?: SortOrder
    status?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    notes?: SortOrder
    reviewedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type AgreementAvgOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    reviewedById?: SortOrder
    companyId?: SortOrder
  }

  export type AgreementMaxOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    title?: SortOrder
    referenceCode?: SortOrder
    status?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    notes?: SortOrder
    reviewedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type AgreementMinOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    title?: SortOrder
    referenceCode?: SortOrder
    status?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    notes?: SortOrder
    reviewedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type AgreementSumOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    reviewedById?: SortOrder
    companyId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type AgreementRelationFilter = {
    is?: AgreementWhereInput
    isNot?: AgreementWhereInput
  }

  export type RateCardCountOrderByAggregateInput = {
    id?: SortOrder
    agreementId?: SortOrder
    routeName?: SortOrder
    origin?: SortOrder
    destination?: SortOrder
    distanceKm?: SortOrder
    ratePerKm?: SortOrder
    uom?: SortOrder
    vehicleType?: SortOrder
    effectiveFrom?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendorId?: SortOrder
  }

  export type RateCardAvgOrderByAggregateInput = {
    id?: SortOrder
    agreementId?: SortOrder
    distanceKm?: SortOrder
    ratePerKm?: SortOrder
    vendorId?: SortOrder
  }

  export type RateCardMaxOrderByAggregateInput = {
    id?: SortOrder
    agreementId?: SortOrder
    routeName?: SortOrder
    origin?: SortOrder
    destination?: SortOrder
    distanceKm?: SortOrder
    ratePerKm?: SortOrder
    uom?: SortOrder
    vehicleType?: SortOrder
    effectiveFrom?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendorId?: SortOrder
  }

  export type RateCardMinOrderByAggregateInput = {
    id?: SortOrder
    agreementId?: SortOrder
    routeName?: SortOrder
    origin?: SortOrder
    destination?: SortOrder
    distanceKm?: SortOrder
    ratePerKm?: SortOrder
    uom?: SortOrder
    vehicleType?: SortOrder
    effectiveFrom?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendorId?: SortOrder
  }

  export type RateCardSumOrderByAggregateInput = {
    id?: SortOrder
    agreementId?: SortOrder
    distanceKm?: SortOrder
    ratePerKm?: SortOrder
    vendorId?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumQuoteStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QuoteStatus | EnumQuoteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuoteStatusFilter<$PrismaModel> | $Enums.QuoteStatus
  }

  export type QuoteResponseNullableRelationFilter = {
    is?: QuoteResponseWhereInput | null
    isNot?: QuoteResponseWhereInput | null
  }

  export type ShipmentNullableRelationFilter = {
    is?: ShipmentWhereInput | null
    isNot?: ShipmentWhereInput | null
  }

  export type QuoteRequestCountOrderByAggregateInput = {
    id?: SortOrder
    createdByUserId?: SortOrder
    fromLocation?: SortOrder
    toLocation?: SortOrder
    fromLat?: SortOrder
    fromLng?: SortOrder
    toLat?: SortOrder
    toLng?: SortOrder
    weight?: SortOrder
    shipmentType?: SortOrder
    urgency?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    approvedResponseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuoteRequestAvgOrderByAggregateInput = {
    id?: SortOrder
    createdByUserId?: SortOrder
    fromLat?: SortOrder
    fromLng?: SortOrder
    toLat?: SortOrder
    toLng?: SortOrder
    weight?: SortOrder
    approvedResponseId?: SortOrder
  }

  export type QuoteRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    createdByUserId?: SortOrder
    fromLocation?: SortOrder
    toLocation?: SortOrder
    fromLat?: SortOrder
    fromLng?: SortOrder
    toLat?: SortOrder
    toLng?: SortOrder
    weight?: SortOrder
    shipmentType?: SortOrder
    urgency?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    approvedResponseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuoteRequestMinOrderByAggregateInput = {
    id?: SortOrder
    createdByUserId?: SortOrder
    fromLocation?: SortOrder
    toLocation?: SortOrder
    fromLat?: SortOrder
    fromLng?: SortOrder
    toLat?: SortOrder
    toLng?: SortOrder
    weight?: SortOrder
    shipmentType?: SortOrder
    urgency?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    approvedResponseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuoteRequestSumOrderByAggregateInput = {
    id?: SortOrder
    createdByUserId?: SortOrder
    fromLat?: SortOrder
    fromLng?: SortOrder
    toLat?: SortOrder
    toLng?: SortOrder
    weight?: SortOrder
    approvedResponseId?: SortOrder
  }

  export type EnumQuoteStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuoteStatus | EnumQuoteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuoteStatusWithAggregatesFilter<$PrismaModel> | $Enums.QuoteStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuoteStatusFilter<$PrismaModel>
    _max?: NestedEnumQuoteStatusFilter<$PrismaModel>
  }

  export type EnumQuoteResponseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QuoteResponseStatus | EnumQuoteResponseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuoteResponseStatus[] | ListEnumQuoteResponseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuoteResponseStatus[] | ListEnumQuoteResponseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuoteResponseStatusFilter<$PrismaModel> | $Enums.QuoteResponseStatus
  }

  export type QuoteRequestRelationFilter = {
    is?: QuoteRequestWhereInput
    isNot?: QuoteRequestWhereInput
  }

  export type QuoteRequestNullableRelationFilter = {
    is?: QuoteRequestWhereInput | null
    isNot?: QuoteRequestWhereInput | null
  }

  export type ConsentLogListRelationFilter = {
    every?: ConsentLogWhereInput
    some?: ConsentLogWhereInput
    none?: ConsentLogWhereInput
  }

  export type ConsentLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuoteResponseCountOrderByAggregateInput = {
    id?: SortOrder
    quoteRequestId?: SortOrder
    vendorId?: SortOrder
    quotedPrice?: SortOrder
    estimatedDelivery?: SortOrder
    expiresAt?: SortOrder
    status?: SortOrder
    consentStatus?: SortOrder
    notes?: SortOrder
    transporterNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuoteResponseAvgOrderByAggregateInput = {
    id?: SortOrder
    quoteRequestId?: SortOrder
    vendorId?: SortOrder
    quotedPrice?: SortOrder
  }

  export type QuoteResponseMaxOrderByAggregateInput = {
    id?: SortOrder
    quoteRequestId?: SortOrder
    vendorId?: SortOrder
    quotedPrice?: SortOrder
    estimatedDelivery?: SortOrder
    expiresAt?: SortOrder
    status?: SortOrder
    consentStatus?: SortOrder
    notes?: SortOrder
    transporterNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuoteResponseMinOrderByAggregateInput = {
    id?: SortOrder
    quoteRequestId?: SortOrder
    vendorId?: SortOrder
    quotedPrice?: SortOrder
    estimatedDelivery?: SortOrder
    expiresAt?: SortOrder
    status?: SortOrder
    consentStatus?: SortOrder
    notes?: SortOrder
    transporterNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuoteResponseSumOrderByAggregateInput = {
    id?: SortOrder
    quoteRequestId?: SortOrder
    vendorId?: SortOrder
    quotedPrice?: SortOrder
  }

  export type EnumQuoteResponseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuoteResponseStatus | EnumQuoteResponseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuoteResponseStatus[] | ListEnumQuoteResponseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuoteResponseStatus[] | ListEnumQuoteResponseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuoteResponseStatusWithAggregatesFilter<$PrismaModel> | $Enums.QuoteResponseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuoteResponseStatusFilter<$PrismaModel>
    _max?: NestedEnumQuoteResponseStatusFilter<$PrismaModel>
  }

  export type QuoteResponseRelationFilter = {
    is?: QuoteResponseWhereInput
    isNot?: QuoteResponseWhereInput
  }

  export type ConsentLogCountOrderByAggregateInput = {
    id?: SortOrder
    quoteResponseId?: SortOrder
    shipmentId?: SortOrder
    statusBefore?: SortOrder
    statusAfter?: SortOrder
    note?: SortOrder
    recordedAt?: SortOrder
  }

  export type ConsentLogAvgOrderByAggregateInput = {
    id?: SortOrder
    quoteResponseId?: SortOrder
    shipmentId?: SortOrder
  }

  export type ConsentLogMaxOrderByAggregateInput = {
    id?: SortOrder
    quoteResponseId?: SortOrder
    shipmentId?: SortOrder
    statusBefore?: SortOrder
    statusAfter?: SortOrder
    note?: SortOrder
    recordedAt?: SortOrder
  }

  export type ConsentLogMinOrderByAggregateInput = {
    id?: SortOrder
    quoteResponseId?: SortOrder
    shipmentId?: SortOrder
    statusBefore?: SortOrder
    statusAfter?: SortOrder
    note?: SortOrder
    recordedAt?: SortOrder
  }

  export type ConsentLogSumOrderByAggregateInput = {
    id?: SortOrder
    quoteResponseId?: SortOrder
    shipmentId?: SortOrder
  }

  export type EnumShipmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ShipmentStatus | EnumShipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShipmentStatus[] | ListEnumShipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShipmentStatus[] | ListEnumShipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShipmentStatusFilter<$PrismaModel> | $Enums.ShipmentStatus
  }

  export type EnumBookingStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBookingStatusNullableFilter<$PrismaModel> | $Enums.BookingStatus | null
  }

  export type EnumPaymentStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentStatusNullableFilter<$PrismaModel> | $Enums.PaymentStatus | null
  }

  export type EnumComplianceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplianceStatus | EnumComplianceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplianceStatus[] | ListEnumComplianceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplianceStatus[] | ListEnumComplianceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumComplianceStatusFilter<$PrismaModel> | $Enums.ComplianceStatus
  }

  export type RateCardNullableRelationFilter = {
    is?: RateCardWhereInput | null
    isNot?: RateCardWhereInput | null
  }

  export type StatusHistoryListRelationFilter = {
    every?: StatusHistoryWhereInput
    some?: StatusHistoryWhereInput
    none?: StatusHistoryWhereInput
  }

  export type ComplianceDocumentListRelationFilter = {
    every?: ComplianceDocumentWhereInput
    some?: ComplianceDocumentWhereInput
    none?: ComplianceDocumentWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type InvoiceNullableRelationFilter = {
    is?: InvoiceWhereInput | null
    isNot?: InvoiceWhereInput | null
  }

  export type StatusHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComplianceDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShipmentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    quoteRequestId?: SortOrder
    transporterQuoteId?: SortOrder
    selectedVendorId?: SortOrder
    agreementId?: SortOrder
    rateCardId?: SortOrder
    trackingNumber?: SortOrder
    fromLocation?: SortOrder
    toLocation?: SortOrder
    fromLat?: SortOrder
    fromLng?: SortOrder
    toLat?: SortOrder
    toLng?: SortOrder
    weight?: SortOrder
    shipmentType?: SortOrder
    urgency?: SortOrder
    status?: SortOrder
    bookingStatus?: SortOrder
    paymentStatus?: SortOrder
    cost?: SortOrder
    distance?: SortOrder
    estimatedDelivery?: SortOrder
    pickupTime?: SortOrder
    deliveryTime?: SortOrder
    assignedToId?: SortOrder
    assignedDriver?: SortOrder
    driverPhone?: SortOrder
    driverEta?: SortOrder
    transporterResponseNotes?: SortOrder
    notes?: SortOrder
    ewayBillNumber?: SortOrder
    gstInvoiceId?: SortOrder
    complianceStatus?: SortOrder
    source?: SortOrder
    podStatus?: SortOrder
    podUrl?: SortOrder
    podNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShipmentAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    quoteRequestId?: SortOrder
    transporterQuoteId?: SortOrder
    selectedVendorId?: SortOrder
    agreementId?: SortOrder
    rateCardId?: SortOrder
    fromLat?: SortOrder
    fromLng?: SortOrder
    toLat?: SortOrder
    toLng?: SortOrder
    weight?: SortOrder
    cost?: SortOrder
    distance?: SortOrder
    assignedToId?: SortOrder
    gstInvoiceId?: SortOrder
  }

  export type ShipmentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    quoteRequestId?: SortOrder
    transporterQuoteId?: SortOrder
    selectedVendorId?: SortOrder
    agreementId?: SortOrder
    rateCardId?: SortOrder
    trackingNumber?: SortOrder
    fromLocation?: SortOrder
    toLocation?: SortOrder
    fromLat?: SortOrder
    fromLng?: SortOrder
    toLat?: SortOrder
    toLng?: SortOrder
    weight?: SortOrder
    shipmentType?: SortOrder
    urgency?: SortOrder
    status?: SortOrder
    bookingStatus?: SortOrder
    paymentStatus?: SortOrder
    cost?: SortOrder
    distance?: SortOrder
    estimatedDelivery?: SortOrder
    pickupTime?: SortOrder
    deliveryTime?: SortOrder
    assignedToId?: SortOrder
    assignedDriver?: SortOrder
    driverPhone?: SortOrder
    driverEta?: SortOrder
    transporterResponseNotes?: SortOrder
    notes?: SortOrder
    ewayBillNumber?: SortOrder
    gstInvoiceId?: SortOrder
    complianceStatus?: SortOrder
    source?: SortOrder
    podStatus?: SortOrder
    podUrl?: SortOrder
    podNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShipmentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    quoteRequestId?: SortOrder
    transporterQuoteId?: SortOrder
    selectedVendorId?: SortOrder
    agreementId?: SortOrder
    rateCardId?: SortOrder
    trackingNumber?: SortOrder
    fromLocation?: SortOrder
    toLocation?: SortOrder
    fromLat?: SortOrder
    fromLng?: SortOrder
    toLat?: SortOrder
    toLng?: SortOrder
    weight?: SortOrder
    shipmentType?: SortOrder
    urgency?: SortOrder
    status?: SortOrder
    bookingStatus?: SortOrder
    paymentStatus?: SortOrder
    cost?: SortOrder
    distance?: SortOrder
    estimatedDelivery?: SortOrder
    pickupTime?: SortOrder
    deliveryTime?: SortOrder
    assignedToId?: SortOrder
    assignedDriver?: SortOrder
    driverPhone?: SortOrder
    driverEta?: SortOrder
    transporterResponseNotes?: SortOrder
    notes?: SortOrder
    ewayBillNumber?: SortOrder
    gstInvoiceId?: SortOrder
    complianceStatus?: SortOrder
    source?: SortOrder
    podStatus?: SortOrder
    podUrl?: SortOrder
    podNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShipmentSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    quoteRequestId?: SortOrder
    transporterQuoteId?: SortOrder
    selectedVendorId?: SortOrder
    agreementId?: SortOrder
    rateCardId?: SortOrder
    fromLat?: SortOrder
    fromLng?: SortOrder
    toLat?: SortOrder
    toLng?: SortOrder
    weight?: SortOrder
    cost?: SortOrder
    distance?: SortOrder
    assignedToId?: SortOrder
    gstInvoiceId?: SortOrder
  }

  export type EnumShipmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShipmentStatus | EnumShipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShipmentStatus[] | ListEnumShipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShipmentStatus[] | ListEnumShipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShipmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.ShipmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShipmentStatusFilter<$PrismaModel>
    _max?: NestedEnumShipmentStatusFilter<$PrismaModel>
  }

  export type EnumBookingStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBookingStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusNullableFilter<$PrismaModel>
  }

  export type EnumPaymentStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusNullableFilter<$PrismaModel>
  }

  export type EnumComplianceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplianceStatus | EnumComplianceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplianceStatus[] | ListEnumComplianceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplianceStatus[] | ListEnumComplianceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumComplianceStatusWithAggregatesFilter<$PrismaModel> | $Enums.ComplianceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComplianceStatusFilter<$PrismaModel>
    _max?: NestedEnumComplianceStatusFilter<$PrismaModel>
  }

  export type ShipmentRelationFilter = {
    is?: ShipmentWhereInput
    isNot?: ShipmentWhereInput
  }

  export type StatusHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    location?: SortOrder
    updatedBy?: SortOrder
    timestamp?: SortOrder
  }

  export type StatusHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    updatedBy?: SortOrder
  }

  export type StatusHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    location?: SortOrder
    updatedBy?: SortOrder
    timestamp?: SortOrder
  }

  export type StatusHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    location?: SortOrder
    updatedBy?: SortOrder
    timestamp?: SortOrder
  }

  export type StatusHistorySumOrderByAggregateInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    updatedBy?: SortOrder
  }

  export type EnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    invoiceNumber?: SortOrder
    status?: SortOrder
    issuedAt?: SortOrder
    dueDate?: SortOrder
    subtotal?: SortOrder
    taxTotal?: SortOrder
    grandTotal?: SortOrder
    lineItems?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    subtotal?: SortOrder
    taxTotal?: SortOrder
    grandTotal?: SortOrder
    companyId?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    invoiceNumber?: SortOrder
    status?: SortOrder
    issuedAt?: SortOrder
    dueDate?: SortOrder
    subtotal?: SortOrder
    taxTotal?: SortOrder
    grandTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    invoiceNumber?: SortOrder
    status?: SortOrder
    issuedAt?: SortOrder
    dueDate?: SortOrder
    subtotal?: SortOrder
    taxTotal?: SortOrder
    grandTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    subtotal?: SortOrder
    taxTotal?: SortOrder
    grandTotal?: SortOrder
    companyId?: SortOrder
  }

  export type EnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type InvoiceRelationFilter = {
    is?: InvoiceWhereInput
    isNot?: InvoiceWhereInput
  }

  export type PaymentEventListRelationFilter = {
    every?: PaymentEventWhereInput
    some?: PaymentEventWhereInput
    none?: PaymentEventWhereInput
  }

  export type PaymentEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    gateway?: SortOrder
    transactionRef?: SortOrder
    authorizedAt?: SortOrder
    capturedAt?: SortOrder
    failureReason?: SortOrder
    metadata?: SortOrder
    tdsAmount?: SortOrder
    tcsAmount?: SortOrder
    rcmLiability?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    tdsAmount?: SortOrder
    tcsAmount?: SortOrder
    rcmLiability?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    gateway?: SortOrder
    transactionRef?: SortOrder
    authorizedAt?: SortOrder
    capturedAt?: SortOrder
    failureReason?: SortOrder
    tdsAmount?: SortOrder
    tcsAmount?: SortOrder
    rcmLiability?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    gateway?: SortOrder
    transactionRef?: SortOrder
    authorizedAt?: SortOrder
    capturedAt?: SortOrder
    failureReason?: SortOrder
    tdsAmount?: SortOrder
    tcsAmount?: SortOrder
    rcmLiability?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    tdsAmount?: SortOrder
    tcsAmount?: SortOrder
    rcmLiability?: SortOrder
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type PaymentRelationFilter = {
    is?: PaymentWhereInput
    isNot?: PaymentWhereInput
  }

  export type PaymentEventCountOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    eventType?: SortOrder
    details?: SortOrder
    recordedAt?: SortOrder
  }

  export type PaymentEventAvgOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
  }

  export type PaymentEventMaxOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    eventType?: SortOrder
    recordedAt?: SortOrder
  }

  export type PaymentEventMinOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    eventType?: SortOrder
    recordedAt?: SortOrder
  }

  export type PaymentEventSumOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
  }

  export type CompanyRelationFilter = {
    is?: CompanyWhereInput
    isNot?: CompanyWhereInput
  }

  export type TransporterInvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    shipmentId?: SortOrder
    invoiceNumber?: SortOrder
    invoiceDate?: SortOrder
    invoiceAmount?: SortOrder
    invoiceUrl?: SortOrder
    approvalStatus?: SortOrder
    rejectionNotes?: SortOrder
    postedToErpAt?: SortOrder
    approvedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransporterInvoiceAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    shipmentId?: SortOrder
    invoiceAmount?: SortOrder
    approvedById?: SortOrder
  }

  export type TransporterInvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    shipmentId?: SortOrder
    invoiceNumber?: SortOrder
    invoiceDate?: SortOrder
    invoiceAmount?: SortOrder
    invoiceUrl?: SortOrder
    approvalStatus?: SortOrder
    rejectionNotes?: SortOrder
    postedToErpAt?: SortOrder
    approvedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransporterInvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    shipmentId?: SortOrder
    invoiceNumber?: SortOrder
    invoiceDate?: SortOrder
    invoiceAmount?: SortOrder
    invoiceUrl?: SortOrder
    approvalStatus?: SortOrder
    rejectionNotes?: SortOrder
    postedToErpAt?: SortOrder
    approvedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransporterInvoiceSumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    shipmentId?: SortOrder
    invoiceAmount?: SortOrder
    approvedById?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    metadata?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    entityId?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    entityId?: SortOrder
  }

  export type EnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type ComplianceEventListRelationFilter = {
    every?: ComplianceEventWhereInput
    some?: ComplianceEventWhereInput
    none?: ComplianceEventWhereInput
  }

  export type ComplianceEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComplianceDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    issuedAt?: SortOrder
    fileUrl?: SortOrder
    payload?: SortOrder
    metadata?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComplianceDocumentAvgOrderByAggregateInput = {
    id?: SortOrder
    shipmentId?: SortOrder
  }

  export type ComplianceDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    issuedAt?: SortOrder
    fileUrl?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComplianceDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    issuedAt?: SortOrder
    fileUrl?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComplianceDocumentSumOrderByAggregateInput = {
    id?: SortOrder
    shipmentId?: SortOrder
  }

  export type EnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type ComplianceDocumentRelationFilter = {
    is?: ComplianceDocumentWhereInput
    isNot?: ComplianceDocumentWhereInput
  }

  export type ComplianceEventCountOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    eventType?: SortOrder
    details?: SortOrder
    recordedAt?: SortOrder
  }

  export type ComplianceEventAvgOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
  }

  export type ComplianceEventMaxOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    eventType?: SortOrder
    recordedAt?: SortOrder
  }

  export type ComplianceEventMinOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    eventType?: SortOrder
    recordedAt?: SortOrder
  }

  export type ComplianceEventSumOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
  }

  export type UserCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ShipmentCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ShipmentCreateWithoutCompanyInput, ShipmentUncheckedCreateWithoutCompanyInput> | ShipmentCreateWithoutCompanyInput[] | ShipmentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ShipmentCreateOrConnectWithoutCompanyInput | ShipmentCreateOrConnectWithoutCompanyInput[]
    createMany?: ShipmentCreateManyCompanyInputEnvelope
    connect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
  }

  export type AgreementCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AgreementCreateWithoutCompanyInput, AgreementUncheckedCreateWithoutCompanyInput> | AgreementCreateWithoutCompanyInput[] | AgreementUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AgreementCreateOrConnectWithoutCompanyInput | AgreementCreateOrConnectWithoutCompanyInput[]
    createMany?: AgreementCreateManyCompanyInputEnvelope
    connect?: AgreementWhereUniqueInput | AgreementWhereUniqueInput[]
  }

  export type TransporterInvoiceCreateNestedManyWithoutCompanyInput = {
    create?: XOR<TransporterInvoiceCreateWithoutCompanyInput, TransporterInvoiceUncheckedCreateWithoutCompanyInput> | TransporterInvoiceCreateWithoutCompanyInput[] | TransporterInvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TransporterInvoiceCreateOrConnectWithoutCompanyInput | TransporterInvoiceCreateOrConnectWithoutCompanyInput[]
    createMany?: TransporterInvoiceCreateManyCompanyInputEnvelope
    connect?: TransporterInvoiceWhereUniqueInput | TransporterInvoiceWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutCompanyInput = {
    create?: XOR<InvoiceCreateWithoutCompanyInput, InvoiceUncheckedCreateWithoutCompanyInput> | InvoiceCreateWithoutCompanyInput[] | InvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCompanyInput | InvoiceCreateOrConnectWithoutCompanyInput[]
    createMany?: InvoiceCreateManyCompanyInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type CompanyProfileCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyProfileCreateWithoutCompanyInput, CompanyProfileUncheckedCreateWithoutCompanyInput> | CompanyProfileCreateWithoutCompanyInput[] | CompanyProfileUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyProfileCreateOrConnectWithoutCompanyInput | CompanyProfileCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyProfileCreateManyCompanyInputEnvelope
    connect?: CompanyProfileWhereUniqueInput | CompanyProfileWhereUniqueInput[]
  }

  export type VendorCreateNestedManyWithoutCompanyInput = {
    create?: XOR<VendorCreateWithoutCompanyInput, VendorUncheckedCreateWithoutCompanyInput> | VendorCreateWithoutCompanyInput[] | VendorUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: VendorCreateOrConnectWithoutCompanyInput | VendorCreateOrConnectWithoutCompanyInput[]
    createMany?: VendorCreateManyCompanyInputEnvelope
    connect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ShipmentUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ShipmentCreateWithoutCompanyInput, ShipmentUncheckedCreateWithoutCompanyInput> | ShipmentCreateWithoutCompanyInput[] | ShipmentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ShipmentCreateOrConnectWithoutCompanyInput | ShipmentCreateOrConnectWithoutCompanyInput[]
    createMany?: ShipmentCreateManyCompanyInputEnvelope
    connect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
  }

  export type AgreementUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AgreementCreateWithoutCompanyInput, AgreementUncheckedCreateWithoutCompanyInput> | AgreementCreateWithoutCompanyInput[] | AgreementUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AgreementCreateOrConnectWithoutCompanyInput | AgreementCreateOrConnectWithoutCompanyInput[]
    createMany?: AgreementCreateManyCompanyInputEnvelope
    connect?: AgreementWhereUniqueInput | AgreementWhereUniqueInput[]
  }

  export type TransporterInvoiceUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<TransporterInvoiceCreateWithoutCompanyInput, TransporterInvoiceUncheckedCreateWithoutCompanyInput> | TransporterInvoiceCreateWithoutCompanyInput[] | TransporterInvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TransporterInvoiceCreateOrConnectWithoutCompanyInput | TransporterInvoiceCreateOrConnectWithoutCompanyInput[]
    createMany?: TransporterInvoiceCreateManyCompanyInputEnvelope
    connect?: TransporterInvoiceWhereUniqueInput | TransporterInvoiceWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<InvoiceCreateWithoutCompanyInput, InvoiceUncheckedCreateWithoutCompanyInput> | InvoiceCreateWithoutCompanyInput[] | InvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCompanyInput | InvoiceCreateOrConnectWithoutCompanyInput[]
    createMany?: InvoiceCreateManyCompanyInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type CompanyProfileUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyProfileCreateWithoutCompanyInput, CompanyProfileUncheckedCreateWithoutCompanyInput> | CompanyProfileCreateWithoutCompanyInput[] | CompanyProfileUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyProfileCreateOrConnectWithoutCompanyInput | CompanyProfileCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyProfileCreateManyCompanyInputEnvelope
    connect?: CompanyProfileWhereUniqueInput | CompanyProfileWhereUniqueInput[]
  }

  export type VendorUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<VendorCreateWithoutCompanyInput, VendorUncheckedCreateWithoutCompanyInput> | VendorCreateWithoutCompanyInput[] | VendorUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: VendorCreateOrConnectWithoutCompanyInput | VendorCreateOrConnectWithoutCompanyInput[]
    createMany?: VendorCreateManyCompanyInputEnvelope
    connect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCompanyInput | UserUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCompanyInput | UserUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCompanyInput | UserUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ShipmentUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ShipmentCreateWithoutCompanyInput, ShipmentUncheckedCreateWithoutCompanyInput> | ShipmentCreateWithoutCompanyInput[] | ShipmentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ShipmentCreateOrConnectWithoutCompanyInput | ShipmentCreateOrConnectWithoutCompanyInput[]
    upsert?: ShipmentUpsertWithWhereUniqueWithoutCompanyInput | ShipmentUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ShipmentCreateManyCompanyInputEnvelope
    set?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    disconnect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    delete?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    connect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    update?: ShipmentUpdateWithWhereUniqueWithoutCompanyInput | ShipmentUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ShipmentUpdateManyWithWhereWithoutCompanyInput | ShipmentUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ShipmentScalarWhereInput | ShipmentScalarWhereInput[]
  }

  export type AgreementUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AgreementCreateWithoutCompanyInput, AgreementUncheckedCreateWithoutCompanyInput> | AgreementCreateWithoutCompanyInput[] | AgreementUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AgreementCreateOrConnectWithoutCompanyInput | AgreementCreateOrConnectWithoutCompanyInput[]
    upsert?: AgreementUpsertWithWhereUniqueWithoutCompanyInput | AgreementUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AgreementCreateManyCompanyInputEnvelope
    set?: AgreementWhereUniqueInput | AgreementWhereUniqueInput[]
    disconnect?: AgreementWhereUniqueInput | AgreementWhereUniqueInput[]
    delete?: AgreementWhereUniqueInput | AgreementWhereUniqueInput[]
    connect?: AgreementWhereUniqueInput | AgreementWhereUniqueInput[]
    update?: AgreementUpdateWithWhereUniqueWithoutCompanyInput | AgreementUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AgreementUpdateManyWithWhereWithoutCompanyInput | AgreementUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AgreementScalarWhereInput | AgreementScalarWhereInput[]
  }

  export type TransporterInvoiceUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<TransporterInvoiceCreateWithoutCompanyInput, TransporterInvoiceUncheckedCreateWithoutCompanyInput> | TransporterInvoiceCreateWithoutCompanyInput[] | TransporterInvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TransporterInvoiceCreateOrConnectWithoutCompanyInput | TransporterInvoiceCreateOrConnectWithoutCompanyInput[]
    upsert?: TransporterInvoiceUpsertWithWhereUniqueWithoutCompanyInput | TransporterInvoiceUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: TransporterInvoiceCreateManyCompanyInputEnvelope
    set?: TransporterInvoiceWhereUniqueInput | TransporterInvoiceWhereUniqueInput[]
    disconnect?: TransporterInvoiceWhereUniqueInput | TransporterInvoiceWhereUniqueInput[]
    delete?: TransporterInvoiceWhereUniqueInput | TransporterInvoiceWhereUniqueInput[]
    connect?: TransporterInvoiceWhereUniqueInput | TransporterInvoiceWhereUniqueInput[]
    update?: TransporterInvoiceUpdateWithWhereUniqueWithoutCompanyInput | TransporterInvoiceUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: TransporterInvoiceUpdateManyWithWhereWithoutCompanyInput | TransporterInvoiceUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: TransporterInvoiceScalarWhereInput | TransporterInvoiceScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<InvoiceCreateWithoutCompanyInput, InvoiceUncheckedCreateWithoutCompanyInput> | InvoiceCreateWithoutCompanyInput[] | InvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCompanyInput | InvoiceCreateOrConnectWithoutCompanyInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCompanyInput | InvoiceUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: InvoiceCreateManyCompanyInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCompanyInput | InvoiceUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCompanyInput | InvoiceUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type CompanyProfileUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyProfileCreateWithoutCompanyInput, CompanyProfileUncheckedCreateWithoutCompanyInput> | CompanyProfileCreateWithoutCompanyInput[] | CompanyProfileUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyProfileCreateOrConnectWithoutCompanyInput | CompanyProfileCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyProfileUpsertWithWhereUniqueWithoutCompanyInput | CompanyProfileUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyProfileCreateManyCompanyInputEnvelope
    set?: CompanyProfileWhereUniqueInput | CompanyProfileWhereUniqueInput[]
    disconnect?: CompanyProfileWhereUniqueInput | CompanyProfileWhereUniqueInput[]
    delete?: CompanyProfileWhereUniqueInput | CompanyProfileWhereUniqueInput[]
    connect?: CompanyProfileWhereUniqueInput | CompanyProfileWhereUniqueInput[]
    update?: CompanyProfileUpdateWithWhereUniqueWithoutCompanyInput | CompanyProfileUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyProfileUpdateManyWithWhereWithoutCompanyInput | CompanyProfileUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyProfileScalarWhereInput | CompanyProfileScalarWhereInput[]
  }

  export type VendorUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<VendorCreateWithoutCompanyInput, VendorUncheckedCreateWithoutCompanyInput> | VendorCreateWithoutCompanyInput[] | VendorUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: VendorCreateOrConnectWithoutCompanyInput | VendorCreateOrConnectWithoutCompanyInput[]
    upsert?: VendorUpsertWithWhereUniqueWithoutCompanyInput | VendorUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: VendorCreateManyCompanyInputEnvelope
    set?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    disconnect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    delete?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    connect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    update?: VendorUpdateWithWhereUniqueWithoutCompanyInput | VendorUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: VendorUpdateManyWithWhereWithoutCompanyInput | VendorUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: VendorScalarWhereInput | VendorScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCompanyInput | UserUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCompanyInput | UserUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCompanyInput | UserUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ShipmentUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ShipmentCreateWithoutCompanyInput, ShipmentUncheckedCreateWithoutCompanyInput> | ShipmentCreateWithoutCompanyInput[] | ShipmentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ShipmentCreateOrConnectWithoutCompanyInput | ShipmentCreateOrConnectWithoutCompanyInput[]
    upsert?: ShipmentUpsertWithWhereUniqueWithoutCompanyInput | ShipmentUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ShipmentCreateManyCompanyInputEnvelope
    set?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    disconnect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    delete?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    connect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    update?: ShipmentUpdateWithWhereUniqueWithoutCompanyInput | ShipmentUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ShipmentUpdateManyWithWhereWithoutCompanyInput | ShipmentUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ShipmentScalarWhereInput | ShipmentScalarWhereInput[]
  }

  export type AgreementUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AgreementCreateWithoutCompanyInput, AgreementUncheckedCreateWithoutCompanyInput> | AgreementCreateWithoutCompanyInput[] | AgreementUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AgreementCreateOrConnectWithoutCompanyInput | AgreementCreateOrConnectWithoutCompanyInput[]
    upsert?: AgreementUpsertWithWhereUniqueWithoutCompanyInput | AgreementUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AgreementCreateManyCompanyInputEnvelope
    set?: AgreementWhereUniqueInput | AgreementWhereUniqueInput[]
    disconnect?: AgreementWhereUniqueInput | AgreementWhereUniqueInput[]
    delete?: AgreementWhereUniqueInput | AgreementWhereUniqueInput[]
    connect?: AgreementWhereUniqueInput | AgreementWhereUniqueInput[]
    update?: AgreementUpdateWithWhereUniqueWithoutCompanyInput | AgreementUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AgreementUpdateManyWithWhereWithoutCompanyInput | AgreementUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AgreementScalarWhereInput | AgreementScalarWhereInput[]
  }

  export type TransporterInvoiceUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<TransporterInvoiceCreateWithoutCompanyInput, TransporterInvoiceUncheckedCreateWithoutCompanyInput> | TransporterInvoiceCreateWithoutCompanyInput[] | TransporterInvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TransporterInvoiceCreateOrConnectWithoutCompanyInput | TransporterInvoiceCreateOrConnectWithoutCompanyInput[]
    upsert?: TransporterInvoiceUpsertWithWhereUniqueWithoutCompanyInput | TransporterInvoiceUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: TransporterInvoiceCreateManyCompanyInputEnvelope
    set?: TransporterInvoiceWhereUniqueInput | TransporterInvoiceWhereUniqueInput[]
    disconnect?: TransporterInvoiceWhereUniqueInput | TransporterInvoiceWhereUniqueInput[]
    delete?: TransporterInvoiceWhereUniqueInput | TransporterInvoiceWhereUniqueInput[]
    connect?: TransporterInvoiceWhereUniqueInput | TransporterInvoiceWhereUniqueInput[]
    update?: TransporterInvoiceUpdateWithWhereUniqueWithoutCompanyInput | TransporterInvoiceUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: TransporterInvoiceUpdateManyWithWhereWithoutCompanyInput | TransporterInvoiceUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: TransporterInvoiceScalarWhereInput | TransporterInvoiceScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<InvoiceCreateWithoutCompanyInput, InvoiceUncheckedCreateWithoutCompanyInput> | InvoiceCreateWithoutCompanyInput[] | InvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCompanyInput | InvoiceCreateOrConnectWithoutCompanyInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCompanyInput | InvoiceUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: InvoiceCreateManyCompanyInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCompanyInput | InvoiceUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCompanyInput | InvoiceUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type CompanyProfileUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyProfileCreateWithoutCompanyInput, CompanyProfileUncheckedCreateWithoutCompanyInput> | CompanyProfileCreateWithoutCompanyInput[] | CompanyProfileUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyProfileCreateOrConnectWithoutCompanyInput | CompanyProfileCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyProfileUpsertWithWhereUniqueWithoutCompanyInput | CompanyProfileUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyProfileCreateManyCompanyInputEnvelope
    set?: CompanyProfileWhereUniqueInput | CompanyProfileWhereUniqueInput[]
    disconnect?: CompanyProfileWhereUniqueInput | CompanyProfileWhereUniqueInput[]
    delete?: CompanyProfileWhereUniqueInput | CompanyProfileWhereUniqueInput[]
    connect?: CompanyProfileWhereUniqueInput | CompanyProfileWhereUniqueInput[]
    update?: CompanyProfileUpdateWithWhereUniqueWithoutCompanyInput | CompanyProfileUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyProfileUpdateManyWithWhereWithoutCompanyInput | CompanyProfileUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyProfileScalarWhereInput | CompanyProfileScalarWhereInput[]
  }

  export type VendorUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<VendorCreateWithoutCompanyInput, VendorUncheckedCreateWithoutCompanyInput> | VendorCreateWithoutCompanyInput[] | VendorUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: VendorCreateOrConnectWithoutCompanyInput | VendorCreateOrConnectWithoutCompanyInput[]
    upsert?: VendorUpsertWithWhereUniqueWithoutCompanyInput | VendorUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: VendorCreateManyCompanyInputEnvelope
    set?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    disconnect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    delete?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    connect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    update?: VendorUpdateWithWhereUniqueWithoutCompanyInput | VendorUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: VendorUpdateManyWithWhereWithoutCompanyInput | VendorUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: VendorScalarWhereInput | VendorScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutProfilesInput = {
    create?: XOR<CompanyCreateWithoutProfilesInput, CompanyUncheckedCreateWithoutProfilesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutProfilesInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneWithoutProfilesNestedInput = {
    create?: XOR<CompanyCreateWithoutProfilesInput, CompanyUncheckedCreateWithoutProfilesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutProfilesInput
    upsert?: CompanyUpsertWithoutProfilesInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutProfilesInput, CompanyUpdateWithoutProfilesInput>, CompanyUncheckedUpdateWithoutProfilesInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CompanyCreateNestedOneWithoutUsersInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    connect?: CompanyWhereUniqueInput
  }

  export type VendorCreateNestedOneWithoutUserInput = {
    create?: XOR<VendorCreateWithoutUserInput, VendorUncheckedCreateWithoutUserInput>
    connectOrCreate?: VendorCreateOrConnectWithoutUserInput
    connect?: VendorWhereUniqueInput
  }

  export type ShipmentCreateNestedManyWithoutUserInput = {
    create?: XOR<ShipmentCreateWithoutUserInput, ShipmentUncheckedCreateWithoutUserInput> | ShipmentCreateWithoutUserInput[] | ShipmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShipmentCreateOrConnectWithoutUserInput | ShipmentCreateOrConnectWithoutUserInput[]
    createMany?: ShipmentCreateManyUserInputEnvelope
    connect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
  }

  export type ShipmentCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<ShipmentCreateWithoutAssignedToInput, ShipmentUncheckedCreateWithoutAssignedToInput> | ShipmentCreateWithoutAssignedToInput[] | ShipmentUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: ShipmentCreateOrConnectWithoutAssignedToInput | ShipmentCreateOrConnectWithoutAssignedToInput[]
    createMany?: ShipmentCreateManyAssignedToInputEnvelope
    connect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type AgreementCreateNestedManyWithoutReviewedByInput = {
    create?: XOR<AgreementCreateWithoutReviewedByInput, AgreementUncheckedCreateWithoutReviewedByInput> | AgreementCreateWithoutReviewedByInput[] | AgreementUncheckedCreateWithoutReviewedByInput[]
    connectOrCreate?: AgreementCreateOrConnectWithoutReviewedByInput | AgreementCreateOrConnectWithoutReviewedByInput[]
    createMany?: AgreementCreateManyReviewedByInputEnvelope
    connect?: AgreementWhereUniqueInput | AgreementWhereUniqueInput[]
  }

  export type TransporterInvoiceCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<TransporterInvoiceCreateWithoutApprovedByInput, TransporterInvoiceUncheckedCreateWithoutApprovedByInput> | TransporterInvoiceCreateWithoutApprovedByInput[] | TransporterInvoiceUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: TransporterInvoiceCreateOrConnectWithoutApprovedByInput | TransporterInvoiceCreateOrConnectWithoutApprovedByInput[]
    createMany?: TransporterInvoiceCreateManyApprovedByInputEnvelope
    connect?: TransporterInvoiceWhereUniqueInput | TransporterInvoiceWhereUniqueInput[]
  }

  export type QuoteRequestCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<QuoteRequestCreateWithoutCreatedByInput, QuoteRequestUncheckedCreateWithoutCreatedByInput> | QuoteRequestCreateWithoutCreatedByInput[] | QuoteRequestUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: QuoteRequestCreateOrConnectWithoutCreatedByInput | QuoteRequestCreateOrConnectWithoutCreatedByInput[]
    createMany?: QuoteRequestCreateManyCreatedByInputEnvelope
    connect?: QuoteRequestWhereUniqueInput | QuoteRequestWhereUniqueInput[]
  }

  export type PasswordResetTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
  }

  export type TwoFactorChallengeCreateNestedManyWithoutUserInput = {
    create?: XOR<TwoFactorChallengeCreateWithoutUserInput, TwoFactorChallengeUncheckedCreateWithoutUserInput> | TwoFactorChallengeCreateWithoutUserInput[] | TwoFactorChallengeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TwoFactorChallengeCreateOrConnectWithoutUserInput | TwoFactorChallengeCreateOrConnectWithoutUserInput[]
    createMany?: TwoFactorChallengeCreateManyUserInputEnvelope
    connect?: TwoFactorChallengeWhereUniqueInput | TwoFactorChallengeWhereUniqueInput[]
  }

  export type UserConsentCreateNestedManyWithoutUserInput = {
    create?: XOR<UserConsentCreateWithoutUserInput, UserConsentUncheckedCreateWithoutUserInput> | UserConsentCreateWithoutUserInput[] | UserConsentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserConsentCreateOrConnectWithoutUserInput | UserConsentCreateOrConnectWithoutUserInput[]
    createMany?: UserConsentCreateManyUserInputEnvelope
    connect?: UserConsentWhereUniqueInput | UserConsentWhereUniqueInput[]
  }

  export type ShipmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ShipmentCreateWithoutUserInput, ShipmentUncheckedCreateWithoutUserInput> | ShipmentCreateWithoutUserInput[] | ShipmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShipmentCreateOrConnectWithoutUserInput | ShipmentCreateOrConnectWithoutUserInput[]
    createMany?: ShipmentCreateManyUserInputEnvelope
    connect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
  }

  export type ShipmentUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<ShipmentCreateWithoutAssignedToInput, ShipmentUncheckedCreateWithoutAssignedToInput> | ShipmentCreateWithoutAssignedToInput[] | ShipmentUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: ShipmentCreateOrConnectWithoutAssignedToInput | ShipmentCreateOrConnectWithoutAssignedToInput[]
    createMany?: ShipmentCreateManyAssignedToInputEnvelope
    connect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type AgreementUncheckedCreateNestedManyWithoutReviewedByInput = {
    create?: XOR<AgreementCreateWithoutReviewedByInput, AgreementUncheckedCreateWithoutReviewedByInput> | AgreementCreateWithoutReviewedByInput[] | AgreementUncheckedCreateWithoutReviewedByInput[]
    connectOrCreate?: AgreementCreateOrConnectWithoutReviewedByInput | AgreementCreateOrConnectWithoutReviewedByInput[]
    createMany?: AgreementCreateManyReviewedByInputEnvelope
    connect?: AgreementWhereUniqueInput | AgreementWhereUniqueInput[]
  }

  export type TransporterInvoiceUncheckedCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<TransporterInvoiceCreateWithoutApprovedByInput, TransporterInvoiceUncheckedCreateWithoutApprovedByInput> | TransporterInvoiceCreateWithoutApprovedByInput[] | TransporterInvoiceUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: TransporterInvoiceCreateOrConnectWithoutApprovedByInput | TransporterInvoiceCreateOrConnectWithoutApprovedByInput[]
    createMany?: TransporterInvoiceCreateManyApprovedByInputEnvelope
    connect?: TransporterInvoiceWhereUniqueInput | TransporterInvoiceWhereUniqueInput[]
  }

  export type QuoteRequestUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<QuoteRequestCreateWithoutCreatedByInput, QuoteRequestUncheckedCreateWithoutCreatedByInput> | QuoteRequestCreateWithoutCreatedByInput[] | QuoteRequestUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: QuoteRequestCreateOrConnectWithoutCreatedByInput | QuoteRequestCreateOrConnectWithoutCreatedByInput[]
    createMany?: QuoteRequestCreateManyCreatedByInputEnvelope
    connect?: QuoteRequestWhereUniqueInput | QuoteRequestWhereUniqueInput[]
  }

  export type PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
  }

  export type TwoFactorChallengeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TwoFactorChallengeCreateWithoutUserInput, TwoFactorChallengeUncheckedCreateWithoutUserInput> | TwoFactorChallengeCreateWithoutUserInput[] | TwoFactorChallengeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TwoFactorChallengeCreateOrConnectWithoutUserInput | TwoFactorChallengeCreateOrConnectWithoutUserInput[]
    createMany?: TwoFactorChallengeCreateManyUserInputEnvelope
    connect?: TwoFactorChallengeWhereUniqueInput | TwoFactorChallengeWhereUniqueInput[]
  }

  export type UserConsentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserConsentCreateWithoutUserInput, UserConsentUncheckedCreateWithoutUserInput> | UserConsentCreateWithoutUserInput[] | UserConsentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserConsentCreateOrConnectWithoutUserInput | UserConsentCreateOrConnectWithoutUserInput[]
    createMany?: UserConsentCreateManyUserInputEnvelope
    connect?: UserConsentWhereUniqueInput | UserConsentWhereUniqueInput[]
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type EnumApprovalStatusFieldUpdateOperationsInput = {
    set?: $Enums.ApprovalStatus
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type CompanyUpdateOneWithoutUsersNestedInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    upsert?: CompanyUpsertWithoutUsersInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutUsersInput, CompanyUpdateWithoutUsersInput>, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type VendorUpdateOneWithoutUserNestedInput = {
    create?: XOR<VendorCreateWithoutUserInput, VendorUncheckedCreateWithoutUserInput>
    connectOrCreate?: VendorCreateOrConnectWithoutUserInput
    upsert?: VendorUpsertWithoutUserInput
    disconnect?: VendorWhereInput | boolean
    delete?: VendorWhereInput | boolean
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutUserInput, VendorUpdateWithoutUserInput>, VendorUncheckedUpdateWithoutUserInput>
  }

  export type ShipmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<ShipmentCreateWithoutUserInput, ShipmentUncheckedCreateWithoutUserInput> | ShipmentCreateWithoutUserInput[] | ShipmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShipmentCreateOrConnectWithoutUserInput | ShipmentCreateOrConnectWithoutUserInput[]
    upsert?: ShipmentUpsertWithWhereUniqueWithoutUserInput | ShipmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ShipmentCreateManyUserInputEnvelope
    set?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    disconnect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    delete?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    connect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    update?: ShipmentUpdateWithWhereUniqueWithoutUserInput | ShipmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ShipmentUpdateManyWithWhereWithoutUserInput | ShipmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ShipmentScalarWhereInput | ShipmentScalarWhereInput[]
  }

  export type ShipmentUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<ShipmentCreateWithoutAssignedToInput, ShipmentUncheckedCreateWithoutAssignedToInput> | ShipmentCreateWithoutAssignedToInput[] | ShipmentUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: ShipmentCreateOrConnectWithoutAssignedToInput | ShipmentCreateOrConnectWithoutAssignedToInput[]
    upsert?: ShipmentUpsertWithWhereUniqueWithoutAssignedToInput | ShipmentUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: ShipmentCreateManyAssignedToInputEnvelope
    set?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    disconnect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    delete?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    connect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    update?: ShipmentUpdateWithWhereUniqueWithoutAssignedToInput | ShipmentUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: ShipmentUpdateManyWithWhereWithoutAssignedToInput | ShipmentUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: ShipmentScalarWhereInput | ShipmentScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type AgreementUpdateManyWithoutReviewedByNestedInput = {
    create?: XOR<AgreementCreateWithoutReviewedByInput, AgreementUncheckedCreateWithoutReviewedByInput> | AgreementCreateWithoutReviewedByInput[] | AgreementUncheckedCreateWithoutReviewedByInput[]
    connectOrCreate?: AgreementCreateOrConnectWithoutReviewedByInput | AgreementCreateOrConnectWithoutReviewedByInput[]
    upsert?: AgreementUpsertWithWhereUniqueWithoutReviewedByInput | AgreementUpsertWithWhereUniqueWithoutReviewedByInput[]
    createMany?: AgreementCreateManyReviewedByInputEnvelope
    set?: AgreementWhereUniqueInput | AgreementWhereUniqueInput[]
    disconnect?: AgreementWhereUniqueInput | AgreementWhereUniqueInput[]
    delete?: AgreementWhereUniqueInput | AgreementWhereUniqueInput[]
    connect?: AgreementWhereUniqueInput | AgreementWhereUniqueInput[]
    update?: AgreementUpdateWithWhereUniqueWithoutReviewedByInput | AgreementUpdateWithWhereUniqueWithoutReviewedByInput[]
    updateMany?: AgreementUpdateManyWithWhereWithoutReviewedByInput | AgreementUpdateManyWithWhereWithoutReviewedByInput[]
    deleteMany?: AgreementScalarWhereInput | AgreementScalarWhereInput[]
  }

  export type TransporterInvoiceUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<TransporterInvoiceCreateWithoutApprovedByInput, TransporterInvoiceUncheckedCreateWithoutApprovedByInput> | TransporterInvoiceCreateWithoutApprovedByInput[] | TransporterInvoiceUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: TransporterInvoiceCreateOrConnectWithoutApprovedByInput | TransporterInvoiceCreateOrConnectWithoutApprovedByInput[]
    upsert?: TransporterInvoiceUpsertWithWhereUniqueWithoutApprovedByInput | TransporterInvoiceUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: TransporterInvoiceCreateManyApprovedByInputEnvelope
    set?: TransporterInvoiceWhereUniqueInput | TransporterInvoiceWhereUniqueInput[]
    disconnect?: TransporterInvoiceWhereUniqueInput | TransporterInvoiceWhereUniqueInput[]
    delete?: TransporterInvoiceWhereUniqueInput | TransporterInvoiceWhereUniqueInput[]
    connect?: TransporterInvoiceWhereUniqueInput | TransporterInvoiceWhereUniqueInput[]
    update?: TransporterInvoiceUpdateWithWhereUniqueWithoutApprovedByInput | TransporterInvoiceUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: TransporterInvoiceUpdateManyWithWhereWithoutApprovedByInput | TransporterInvoiceUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: TransporterInvoiceScalarWhereInput | TransporterInvoiceScalarWhereInput[]
  }

  export type QuoteRequestUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<QuoteRequestCreateWithoutCreatedByInput, QuoteRequestUncheckedCreateWithoutCreatedByInput> | QuoteRequestCreateWithoutCreatedByInput[] | QuoteRequestUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: QuoteRequestCreateOrConnectWithoutCreatedByInput | QuoteRequestCreateOrConnectWithoutCreatedByInput[]
    upsert?: QuoteRequestUpsertWithWhereUniqueWithoutCreatedByInput | QuoteRequestUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: QuoteRequestCreateManyCreatedByInputEnvelope
    set?: QuoteRequestWhereUniqueInput | QuoteRequestWhereUniqueInput[]
    disconnect?: QuoteRequestWhereUniqueInput | QuoteRequestWhereUniqueInput[]
    delete?: QuoteRequestWhereUniqueInput | QuoteRequestWhereUniqueInput[]
    connect?: QuoteRequestWhereUniqueInput | QuoteRequestWhereUniqueInput[]
    update?: QuoteRequestUpdateWithWhereUniqueWithoutCreatedByInput | QuoteRequestUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: QuoteRequestUpdateManyWithWhereWithoutCreatedByInput | QuoteRequestUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: QuoteRequestScalarWhereInput | QuoteRequestScalarWhereInput[]
  }

  export type PasswordResetTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    set?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    disconnect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    delete?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    update?: PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetTokenUpdateManyWithWhereWithoutUserInput | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
  }

  export type TwoFactorChallengeUpdateManyWithoutUserNestedInput = {
    create?: XOR<TwoFactorChallengeCreateWithoutUserInput, TwoFactorChallengeUncheckedCreateWithoutUserInput> | TwoFactorChallengeCreateWithoutUserInput[] | TwoFactorChallengeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TwoFactorChallengeCreateOrConnectWithoutUserInput | TwoFactorChallengeCreateOrConnectWithoutUserInput[]
    upsert?: TwoFactorChallengeUpsertWithWhereUniqueWithoutUserInput | TwoFactorChallengeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TwoFactorChallengeCreateManyUserInputEnvelope
    set?: TwoFactorChallengeWhereUniqueInput | TwoFactorChallengeWhereUniqueInput[]
    disconnect?: TwoFactorChallengeWhereUniqueInput | TwoFactorChallengeWhereUniqueInput[]
    delete?: TwoFactorChallengeWhereUniqueInput | TwoFactorChallengeWhereUniqueInput[]
    connect?: TwoFactorChallengeWhereUniqueInput | TwoFactorChallengeWhereUniqueInput[]
    update?: TwoFactorChallengeUpdateWithWhereUniqueWithoutUserInput | TwoFactorChallengeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TwoFactorChallengeUpdateManyWithWhereWithoutUserInput | TwoFactorChallengeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TwoFactorChallengeScalarWhereInput | TwoFactorChallengeScalarWhereInput[]
  }

  export type UserConsentUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserConsentCreateWithoutUserInput, UserConsentUncheckedCreateWithoutUserInput> | UserConsentCreateWithoutUserInput[] | UserConsentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserConsentCreateOrConnectWithoutUserInput | UserConsentCreateOrConnectWithoutUserInput[]
    upsert?: UserConsentUpsertWithWhereUniqueWithoutUserInput | UserConsentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserConsentCreateManyUserInputEnvelope
    set?: UserConsentWhereUniqueInput | UserConsentWhereUniqueInput[]
    disconnect?: UserConsentWhereUniqueInput | UserConsentWhereUniqueInput[]
    delete?: UserConsentWhereUniqueInput | UserConsentWhereUniqueInput[]
    connect?: UserConsentWhereUniqueInput | UserConsentWhereUniqueInput[]
    update?: UserConsentUpdateWithWhereUniqueWithoutUserInput | UserConsentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserConsentUpdateManyWithWhereWithoutUserInput | UserConsentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserConsentScalarWhereInput | UserConsentScalarWhereInput[]
  }

  export type ShipmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ShipmentCreateWithoutUserInput, ShipmentUncheckedCreateWithoutUserInput> | ShipmentCreateWithoutUserInput[] | ShipmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShipmentCreateOrConnectWithoutUserInput | ShipmentCreateOrConnectWithoutUserInput[]
    upsert?: ShipmentUpsertWithWhereUniqueWithoutUserInput | ShipmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ShipmentCreateManyUserInputEnvelope
    set?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    disconnect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    delete?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    connect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    update?: ShipmentUpdateWithWhereUniqueWithoutUserInput | ShipmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ShipmentUpdateManyWithWhereWithoutUserInput | ShipmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ShipmentScalarWhereInput | ShipmentScalarWhereInput[]
  }

  export type ShipmentUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<ShipmentCreateWithoutAssignedToInput, ShipmentUncheckedCreateWithoutAssignedToInput> | ShipmentCreateWithoutAssignedToInput[] | ShipmentUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: ShipmentCreateOrConnectWithoutAssignedToInput | ShipmentCreateOrConnectWithoutAssignedToInput[]
    upsert?: ShipmentUpsertWithWhereUniqueWithoutAssignedToInput | ShipmentUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: ShipmentCreateManyAssignedToInputEnvelope
    set?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    disconnect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    delete?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    connect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    update?: ShipmentUpdateWithWhereUniqueWithoutAssignedToInput | ShipmentUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: ShipmentUpdateManyWithWhereWithoutAssignedToInput | ShipmentUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: ShipmentScalarWhereInput | ShipmentScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type AgreementUncheckedUpdateManyWithoutReviewedByNestedInput = {
    create?: XOR<AgreementCreateWithoutReviewedByInput, AgreementUncheckedCreateWithoutReviewedByInput> | AgreementCreateWithoutReviewedByInput[] | AgreementUncheckedCreateWithoutReviewedByInput[]
    connectOrCreate?: AgreementCreateOrConnectWithoutReviewedByInput | AgreementCreateOrConnectWithoutReviewedByInput[]
    upsert?: AgreementUpsertWithWhereUniqueWithoutReviewedByInput | AgreementUpsertWithWhereUniqueWithoutReviewedByInput[]
    createMany?: AgreementCreateManyReviewedByInputEnvelope
    set?: AgreementWhereUniqueInput | AgreementWhereUniqueInput[]
    disconnect?: AgreementWhereUniqueInput | AgreementWhereUniqueInput[]
    delete?: AgreementWhereUniqueInput | AgreementWhereUniqueInput[]
    connect?: AgreementWhereUniqueInput | AgreementWhereUniqueInput[]
    update?: AgreementUpdateWithWhereUniqueWithoutReviewedByInput | AgreementUpdateWithWhereUniqueWithoutReviewedByInput[]
    updateMany?: AgreementUpdateManyWithWhereWithoutReviewedByInput | AgreementUpdateManyWithWhereWithoutReviewedByInput[]
    deleteMany?: AgreementScalarWhereInput | AgreementScalarWhereInput[]
  }

  export type TransporterInvoiceUncheckedUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<TransporterInvoiceCreateWithoutApprovedByInput, TransporterInvoiceUncheckedCreateWithoutApprovedByInput> | TransporterInvoiceCreateWithoutApprovedByInput[] | TransporterInvoiceUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: TransporterInvoiceCreateOrConnectWithoutApprovedByInput | TransporterInvoiceCreateOrConnectWithoutApprovedByInput[]
    upsert?: TransporterInvoiceUpsertWithWhereUniqueWithoutApprovedByInput | TransporterInvoiceUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: TransporterInvoiceCreateManyApprovedByInputEnvelope
    set?: TransporterInvoiceWhereUniqueInput | TransporterInvoiceWhereUniqueInput[]
    disconnect?: TransporterInvoiceWhereUniqueInput | TransporterInvoiceWhereUniqueInput[]
    delete?: TransporterInvoiceWhereUniqueInput | TransporterInvoiceWhereUniqueInput[]
    connect?: TransporterInvoiceWhereUniqueInput | TransporterInvoiceWhereUniqueInput[]
    update?: TransporterInvoiceUpdateWithWhereUniqueWithoutApprovedByInput | TransporterInvoiceUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: TransporterInvoiceUpdateManyWithWhereWithoutApprovedByInput | TransporterInvoiceUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: TransporterInvoiceScalarWhereInput | TransporterInvoiceScalarWhereInput[]
  }

  export type QuoteRequestUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<QuoteRequestCreateWithoutCreatedByInput, QuoteRequestUncheckedCreateWithoutCreatedByInput> | QuoteRequestCreateWithoutCreatedByInput[] | QuoteRequestUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: QuoteRequestCreateOrConnectWithoutCreatedByInput | QuoteRequestCreateOrConnectWithoutCreatedByInput[]
    upsert?: QuoteRequestUpsertWithWhereUniqueWithoutCreatedByInput | QuoteRequestUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: QuoteRequestCreateManyCreatedByInputEnvelope
    set?: QuoteRequestWhereUniqueInput | QuoteRequestWhereUniqueInput[]
    disconnect?: QuoteRequestWhereUniqueInput | QuoteRequestWhereUniqueInput[]
    delete?: QuoteRequestWhereUniqueInput | QuoteRequestWhereUniqueInput[]
    connect?: QuoteRequestWhereUniqueInput | QuoteRequestWhereUniqueInput[]
    update?: QuoteRequestUpdateWithWhereUniqueWithoutCreatedByInput | QuoteRequestUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: QuoteRequestUpdateManyWithWhereWithoutCreatedByInput | QuoteRequestUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: QuoteRequestScalarWhereInput | QuoteRequestScalarWhereInput[]
  }

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    set?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    disconnect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    delete?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    update?: PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetTokenUpdateManyWithWhereWithoutUserInput | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
  }

  export type TwoFactorChallengeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TwoFactorChallengeCreateWithoutUserInput, TwoFactorChallengeUncheckedCreateWithoutUserInput> | TwoFactorChallengeCreateWithoutUserInput[] | TwoFactorChallengeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TwoFactorChallengeCreateOrConnectWithoutUserInput | TwoFactorChallengeCreateOrConnectWithoutUserInput[]
    upsert?: TwoFactorChallengeUpsertWithWhereUniqueWithoutUserInput | TwoFactorChallengeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TwoFactorChallengeCreateManyUserInputEnvelope
    set?: TwoFactorChallengeWhereUniqueInput | TwoFactorChallengeWhereUniqueInput[]
    disconnect?: TwoFactorChallengeWhereUniqueInput | TwoFactorChallengeWhereUniqueInput[]
    delete?: TwoFactorChallengeWhereUniqueInput | TwoFactorChallengeWhereUniqueInput[]
    connect?: TwoFactorChallengeWhereUniqueInput | TwoFactorChallengeWhereUniqueInput[]
    update?: TwoFactorChallengeUpdateWithWhereUniqueWithoutUserInput | TwoFactorChallengeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TwoFactorChallengeUpdateManyWithWhereWithoutUserInput | TwoFactorChallengeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TwoFactorChallengeScalarWhereInput | TwoFactorChallengeScalarWhereInput[]
  }

  export type UserConsentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserConsentCreateWithoutUserInput, UserConsentUncheckedCreateWithoutUserInput> | UserConsentCreateWithoutUserInput[] | UserConsentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserConsentCreateOrConnectWithoutUserInput | UserConsentCreateOrConnectWithoutUserInput[]
    upsert?: UserConsentUpsertWithWhereUniqueWithoutUserInput | UserConsentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserConsentCreateManyUserInputEnvelope
    set?: UserConsentWhereUniqueInput | UserConsentWhereUniqueInput[]
    disconnect?: UserConsentWhereUniqueInput | UserConsentWhereUniqueInput[]
    delete?: UserConsentWhereUniqueInput | UserConsentWhereUniqueInput[]
    connect?: UserConsentWhereUniqueInput | UserConsentWhereUniqueInput[]
    update?: UserConsentUpdateWithWhereUniqueWithoutUserInput | UserConsentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserConsentUpdateManyWithWhereWithoutUserInput | UserConsentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserConsentScalarWhereInput | UserConsentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPasswordResetTokensInput = {
    create?: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPasswordResetTokensNestedInput = {
    create?: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetTokensInput
    upsert?: UserUpsertWithoutPasswordResetTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasswordResetTokensInput, UserUpdateWithoutPasswordResetTokensInput>, UserUncheckedUpdateWithoutPasswordResetTokensInput>
  }

  export type UserCreateNestedOneWithoutTwoFactorChallengesInput = {
    create?: XOR<UserCreateWithoutTwoFactorChallengesInput, UserUncheckedCreateWithoutTwoFactorChallengesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTwoFactorChallengesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTwoFactorChallengesNestedInput = {
    create?: XOR<UserCreateWithoutTwoFactorChallengesInput, UserUncheckedCreateWithoutTwoFactorChallengesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTwoFactorChallengesInput
    upsert?: UserUpsertWithoutTwoFactorChallengesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTwoFactorChallengesInput, UserUpdateWithoutTwoFactorChallengesInput>, UserUncheckedUpdateWithoutTwoFactorChallengesInput>
  }

  export type UserCreateNestedOneWithoutUserConsentsInput = {
    create?: XOR<UserCreateWithoutUserConsentsInput, UserUncheckedCreateWithoutUserConsentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserConsentsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumConsentStatusFieldUpdateOperationsInput = {
    set?: $Enums.ConsentStatus
  }

  export type UserUpdateOneRequiredWithoutUserConsentsNestedInput = {
    create?: XOR<UserCreateWithoutUserConsentsInput, UserUncheckedCreateWithoutUserConsentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserConsentsInput
    upsert?: UserUpsertWithoutUserConsentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserConsentsInput, UserUpdateWithoutUserConsentsInput>, UserUncheckedUpdateWithoutUserConsentsInput>
  }

  export type CompanyCreateNestedOneWithoutVendorsInput = {
    create?: XOR<CompanyCreateWithoutVendorsInput, CompanyUncheckedCreateWithoutVendorsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutVendorsInput
    connect?: CompanyWhereUniqueInput
  }

  export type VendorProfileCreateNestedOneWithoutVendorInput = {
    create?: XOR<VendorProfileCreateWithoutVendorInput, VendorProfileUncheckedCreateWithoutVendorInput>
    connectOrCreate?: VendorProfileCreateOrConnectWithoutVendorInput
    connect?: VendorProfileWhereUniqueInput
  }

  export type AgreementCreateNestedManyWithoutVendorInput = {
    create?: XOR<AgreementCreateWithoutVendorInput, AgreementUncheckedCreateWithoutVendorInput> | AgreementCreateWithoutVendorInput[] | AgreementUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: AgreementCreateOrConnectWithoutVendorInput | AgreementCreateOrConnectWithoutVendorInput[]
    createMany?: AgreementCreateManyVendorInputEnvelope
    connect?: AgreementWhereUniqueInput | AgreementWhereUniqueInput[]
  }

  export type RateCardCreateNestedManyWithoutVendorInput = {
    create?: XOR<RateCardCreateWithoutVendorInput, RateCardUncheckedCreateWithoutVendorInput> | RateCardCreateWithoutVendorInput[] | RateCardUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: RateCardCreateOrConnectWithoutVendorInput | RateCardCreateOrConnectWithoutVendorInput[]
    createMany?: RateCardCreateManyVendorInputEnvelope
    connect?: RateCardWhereUniqueInput | RateCardWhereUniqueInput[]
  }

  export type QuoteResponseCreateNestedManyWithoutVendorInput = {
    create?: XOR<QuoteResponseCreateWithoutVendorInput, QuoteResponseUncheckedCreateWithoutVendorInput> | QuoteResponseCreateWithoutVendorInput[] | QuoteResponseUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: QuoteResponseCreateOrConnectWithoutVendorInput | QuoteResponseCreateOrConnectWithoutVendorInput[]
    createMany?: QuoteResponseCreateManyVendorInputEnvelope
    connect?: QuoteResponseWhereUniqueInput | QuoteResponseWhereUniqueInput[]
  }

  export type ShipmentCreateNestedManyWithoutVendorInput = {
    create?: XOR<ShipmentCreateWithoutVendorInput, ShipmentUncheckedCreateWithoutVendorInput> | ShipmentCreateWithoutVendorInput[] | ShipmentUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ShipmentCreateOrConnectWithoutVendorInput | ShipmentCreateOrConnectWithoutVendorInput[]
    createMany?: ShipmentCreateManyVendorInputEnvelope
    connect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
  }

  export type DriverCreateNestedManyWithoutVendorInput = {
    create?: XOR<DriverCreateWithoutVendorInput, DriverUncheckedCreateWithoutVendorInput> | DriverCreateWithoutVendorInput[] | DriverUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: DriverCreateOrConnectWithoutVendorInput | DriverCreateOrConnectWithoutVendorInput[]
    createMany?: DriverCreateManyVendorInputEnvelope
    connect?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutVendorInput = {
    create?: XOR<UserCreateWithoutVendorInput, UserUncheckedCreateWithoutVendorInput> | UserCreateWithoutVendorInput[] | UserUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: UserCreateOrConnectWithoutVendorInput | UserCreateOrConnectWithoutVendorInput[]
    createMany?: UserCreateManyVendorInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type VendorProfileUncheckedCreateNestedOneWithoutVendorInput = {
    create?: XOR<VendorProfileCreateWithoutVendorInput, VendorProfileUncheckedCreateWithoutVendorInput>
    connectOrCreate?: VendorProfileCreateOrConnectWithoutVendorInput
    connect?: VendorProfileWhereUniqueInput
  }

  export type AgreementUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<AgreementCreateWithoutVendorInput, AgreementUncheckedCreateWithoutVendorInput> | AgreementCreateWithoutVendorInput[] | AgreementUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: AgreementCreateOrConnectWithoutVendorInput | AgreementCreateOrConnectWithoutVendorInput[]
    createMany?: AgreementCreateManyVendorInputEnvelope
    connect?: AgreementWhereUniqueInput | AgreementWhereUniqueInput[]
  }

  export type RateCardUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<RateCardCreateWithoutVendorInput, RateCardUncheckedCreateWithoutVendorInput> | RateCardCreateWithoutVendorInput[] | RateCardUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: RateCardCreateOrConnectWithoutVendorInput | RateCardCreateOrConnectWithoutVendorInput[]
    createMany?: RateCardCreateManyVendorInputEnvelope
    connect?: RateCardWhereUniqueInput | RateCardWhereUniqueInput[]
  }

  export type QuoteResponseUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<QuoteResponseCreateWithoutVendorInput, QuoteResponseUncheckedCreateWithoutVendorInput> | QuoteResponseCreateWithoutVendorInput[] | QuoteResponseUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: QuoteResponseCreateOrConnectWithoutVendorInput | QuoteResponseCreateOrConnectWithoutVendorInput[]
    createMany?: QuoteResponseCreateManyVendorInputEnvelope
    connect?: QuoteResponseWhereUniqueInput | QuoteResponseWhereUniqueInput[]
  }

  export type ShipmentUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<ShipmentCreateWithoutVendorInput, ShipmentUncheckedCreateWithoutVendorInput> | ShipmentCreateWithoutVendorInput[] | ShipmentUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ShipmentCreateOrConnectWithoutVendorInput | ShipmentCreateOrConnectWithoutVendorInput[]
    createMany?: ShipmentCreateManyVendorInputEnvelope
    connect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
  }

  export type DriverUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<DriverCreateWithoutVendorInput, DriverUncheckedCreateWithoutVendorInput> | DriverCreateWithoutVendorInput[] | DriverUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: DriverCreateOrConnectWithoutVendorInput | DriverCreateOrConnectWithoutVendorInput[]
    createMany?: DriverCreateManyVendorInputEnvelope
    connect?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<UserCreateWithoutVendorInput, UserUncheckedCreateWithoutVendorInput> | UserCreateWithoutVendorInput[] | UserUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: UserCreateOrConnectWithoutVendorInput | UserCreateOrConnectWithoutVendorInput[]
    createMany?: UserCreateManyVendorInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CompanyUpdateOneWithoutVendorsNestedInput = {
    create?: XOR<CompanyCreateWithoutVendorsInput, CompanyUncheckedCreateWithoutVendorsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutVendorsInput
    upsert?: CompanyUpsertWithoutVendorsInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutVendorsInput, CompanyUpdateWithoutVendorsInput>, CompanyUncheckedUpdateWithoutVendorsInput>
  }

  export type VendorProfileUpdateOneWithoutVendorNestedInput = {
    create?: XOR<VendorProfileCreateWithoutVendorInput, VendorProfileUncheckedCreateWithoutVendorInput>
    connectOrCreate?: VendorProfileCreateOrConnectWithoutVendorInput
    upsert?: VendorProfileUpsertWithoutVendorInput
    disconnect?: VendorProfileWhereInput | boolean
    delete?: VendorProfileWhereInput | boolean
    connect?: VendorProfileWhereUniqueInput
    update?: XOR<XOR<VendorProfileUpdateToOneWithWhereWithoutVendorInput, VendorProfileUpdateWithoutVendorInput>, VendorProfileUncheckedUpdateWithoutVendorInput>
  }

  export type AgreementUpdateManyWithoutVendorNestedInput = {
    create?: XOR<AgreementCreateWithoutVendorInput, AgreementUncheckedCreateWithoutVendorInput> | AgreementCreateWithoutVendorInput[] | AgreementUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: AgreementCreateOrConnectWithoutVendorInput | AgreementCreateOrConnectWithoutVendorInput[]
    upsert?: AgreementUpsertWithWhereUniqueWithoutVendorInput | AgreementUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: AgreementCreateManyVendorInputEnvelope
    set?: AgreementWhereUniqueInput | AgreementWhereUniqueInput[]
    disconnect?: AgreementWhereUniqueInput | AgreementWhereUniqueInput[]
    delete?: AgreementWhereUniqueInput | AgreementWhereUniqueInput[]
    connect?: AgreementWhereUniqueInput | AgreementWhereUniqueInput[]
    update?: AgreementUpdateWithWhereUniqueWithoutVendorInput | AgreementUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: AgreementUpdateManyWithWhereWithoutVendorInput | AgreementUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: AgreementScalarWhereInput | AgreementScalarWhereInput[]
  }

  export type RateCardUpdateManyWithoutVendorNestedInput = {
    create?: XOR<RateCardCreateWithoutVendorInput, RateCardUncheckedCreateWithoutVendorInput> | RateCardCreateWithoutVendorInput[] | RateCardUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: RateCardCreateOrConnectWithoutVendorInput | RateCardCreateOrConnectWithoutVendorInput[]
    upsert?: RateCardUpsertWithWhereUniqueWithoutVendorInput | RateCardUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: RateCardCreateManyVendorInputEnvelope
    set?: RateCardWhereUniqueInput | RateCardWhereUniqueInput[]
    disconnect?: RateCardWhereUniqueInput | RateCardWhereUniqueInput[]
    delete?: RateCardWhereUniqueInput | RateCardWhereUniqueInput[]
    connect?: RateCardWhereUniqueInput | RateCardWhereUniqueInput[]
    update?: RateCardUpdateWithWhereUniqueWithoutVendorInput | RateCardUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: RateCardUpdateManyWithWhereWithoutVendorInput | RateCardUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: RateCardScalarWhereInput | RateCardScalarWhereInput[]
  }

  export type QuoteResponseUpdateManyWithoutVendorNestedInput = {
    create?: XOR<QuoteResponseCreateWithoutVendorInput, QuoteResponseUncheckedCreateWithoutVendorInput> | QuoteResponseCreateWithoutVendorInput[] | QuoteResponseUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: QuoteResponseCreateOrConnectWithoutVendorInput | QuoteResponseCreateOrConnectWithoutVendorInput[]
    upsert?: QuoteResponseUpsertWithWhereUniqueWithoutVendorInput | QuoteResponseUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: QuoteResponseCreateManyVendorInputEnvelope
    set?: QuoteResponseWhereUniqueInput | QuoteResponseWhereUniqueInput[]
    disconnect?: QuoteResponseWhereUniqueInput | QuoteResponseWhereUniqueInput[]
    delete?: QuoteResponseWhereUniqueInput | QuoteResponseWhereUniqueInput[]
    connect?: QuoteResponseWhereUniqueInput | QuoteResponseWhereUniqueInput[]
    update?: QuoteResponseUpdateWithWhereUniqueWithoutVendorInput | QuoteResponseUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: QuoteResponseUpdateManyWithWhereWithoutVendorInput | QuoteResponseUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: QuoteResponseScalarWhereInput | QuoteResponseScalarWhereInput[]
  }

  export type ShipmentUpdateManyWithoutVendorNestedInput = {
    create?: XOR<ShipmentCreateWithoutVendorInput, ShipmentUncheckedCreateWithoutVendorInput> | ShipmentCreateWithoutVendorInput[] | ShipmentUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ShipmentCreateOrConnectWithoutVendorInput | ShipmentCreateOrConnectWithoutVendorInput[]
    upsert?: ShipmentUpsertWithWhereUniqueWithoutVendorInput | ShipmentUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: ShipmentCreateManyVendorInputEnvelope
    set?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    disconnect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    delete?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    connect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    update?: ShipmentUpdateWithWhereUniqueWithoutVendorInput | ShipmentUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: ShipmentUpdateManyWithWhereWithoutVendorInput | ShipmentUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: ShipmentScalarWhereInput | ShipmentScalarWhereInput[]
  }

  export type DriverUpdateManyWithoutVendorNestedInput = {
    create?: XOR<DriverCreateWithoutVendorInput, DriverUncheckedCreateWithoutVendorInput> | DriverCreateWithoutVendorInput[] | DriverUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: DriverCreateOrConnectWithoutVendorInput | DriverCreateOrConnectWithoutVendorInput[]
    upsert?: DriverUpsertWithWhereUniqueWithoutVendorInput | DriverUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: DriverCreateManyVendorInputEnvelope
    set?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    disconnect?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    delete?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    connect?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    update?: DriverUpdateWithWhereUniqueWithoutVendorInput | DriverUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: DriverUpdateManyWithWhereWithoutVendorInput | DriverUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: DriverScalarWhereInput | DriverScalarWhereInput[]
  }

  export type UserUpdateManyWithoutVendorNestedInput = {
    create?: XOR<UserCreateWithoutVendorInput, UserUncheckedCreateWithoutVendorInput> | UserCreateWithoutVendorInput[] | UserUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: UserCreateOrConnectWithoutVendorInput | UserCreateOrConnectWithoutVendorInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutVendorInput | UserUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: UserCreateManyVendorInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutVendorInput | UserUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: UserUpdateManyWithWhereWithoutVendorInput | UserUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type VendorProfileUncheckedUpdateOneWithoutVendorNestedInput = {
    create?: XOR<VendorProfileCreateWithoutVendorInput, VendorProfileUncheckedCreateWithoutVendorInput>
    connectOrCreate?: VendorProfileCreateOrConnectWithoutVendorInput
    upsert?: VendorProfileUpsertWithoutVendorInput
    disconnect?: VendorProfileWhereInput | boolean
    delete?: VendorProfileWhereInput | boolean
    connect?: VendorProfileWhereUniqueInput
    update?: XOR<XOR<VendorProfileUpdateToOneWithWhereWithoutVendorInput, VendorProfileUpdateWithoutVendorInput>, VendorProfileUncheckedUpdateWithoutVendorInput>
  }

  export type AgreementUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<AgreementCreateWithoutVendorInput, AgreementUncheckedCreateWithoutVendorInput> | AgreementCreateWithoutVendorInput[] | AgreementUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: AgreementCreateOrConnectWithoutVendorInput | AgreementCreateOrConnectWithoutVendorInput[]
    upsert?: AgreementUpsertWithWhereUniqueWithoutVendorInput | AgreementUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: AgreementCreateManyVendorInputEnvelope
    set?: AgreementWhereUniqueInput | AgreementWhereUniqueInput[]
    disconnect?: AgreementWhereUniqueInput | AgreementWhereUniqueInput[]
    delete?: AgreementWhereUniqueInput | AgreementWhereUniqueInput[]
    connect?: AgreementWhereUniqueInput | AgreementWhereUniqueInput[]
    update?: AgreementUpdateWithWhereUniqueWithoutVendorInput | AgreementUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: AgreementUpdateManyWithWhereWithoutVendorInput | AgreementUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: AgreementScalarWhereInput | AgreementScalarWhereInput[]
  }

  export type RateCardUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<RateCardCreateWithoutVendorInput, RateCardUncheckedCreateWithoutVendorInput> | RateCardCreateWithoutVendorInput[] | RateCardUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: RateCardCreateOrConnectWithoutVendorInput | RateCardCreateOrConnectWithoutVendorInput[]
    upsert?: RateCardUpsertWithWhereUniqueWithoutVendorInput | RateCardUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: RateCardCreateManyVendorInputEnvelope
    set?: RateCardWhereUniqueInput | RateCardWhereUniqueInput[]
    disconnect?: RateCardWhereUniqueInput | RateCardWhereUniqueInput[]
    delete?: RateCardWhereUniqueInput | RateCardWhereUniqueInput[]
    connect?: RateCardWhereUniqueInput | RateCardWhereUniqueInput[]
    update?: RateCardUpdateWithWhereUniqueWithoutVendorInput | RateCardUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: RateCardUpdateManyWithWhereWithoutVendorInput | RateCardUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: RateCardScalarWhereInput | RateCardScalarWhereInput[]
  }

  export type QuoteResponseUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<QuoteResponseCreateWithoutVendorInput, QuoteResponseUncheckedCreateWithoutVendorInput> | QuoteResponseCreateWithoutVendorInput[] | QuoteResponseUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: QuoteResponseCreateOrConnectWithoutVendorInput | QuoteResponseCreateOrConnectWithoutVendorInput[]
    upsert?: QuoteResponseUpsertWithWhereUniqueWithoutVendorInput | QuoteResponseUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: QuoteResponseCreateManyVendorInputEnvelope
    set?: QuoteResponseWhereUniqueInput | QuoteResponseWhereUniqueInput[]
    disconnect?: QuoteResponseWhereUniqueInput | QuoteResponseWhereUniqueInput[]
    delete?: QuoteResponseWhereUniqueInput | QuoteResponseWhereUniqueInput[]
    connect?: QuoteResponseWhereUniqueInput | QuoteResponseWhereUniqueInput[]
    update?: QuoteResponseUpdateWithWhereUniqueWithoutVendorInput | QuoteResponseUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: QuoteResponseUpdateManyWithWhereWithoutVendorInput | QuoteResponseUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: QuoteResponseScalarWhereInput | QuoteResponseScalarWhereInput[]
  }

  export type ShipmentUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<ShipmentCreateWithoutVendorInput, ShipmentUncheckedCreateWithoutVendorInput> | ShipmentCreateWithoutVendorInput[] | ShipmentUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: ShipmentCreateOrConnectWithoutVendorInput | ShipmentCreateOrConnectWithoutVendorInput[]
    upsert?: ShipmentUpsertWithWhereUniqueWithoutVendorInput | ShipmentUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: ShipmentCreateManyVendorInputEnvelope
    set?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    disconnect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    delete?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    connect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    update?: ShipmentUpdateWithWhereUniqueWithoutVendorInput | ShipmentUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: ShipmentUpdateManyWithWhereWithoutVendorInput | ShipmentUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: ShipmentScalarWhereInput | ShipmentScalarWhereInput[]
  }

  export type DriverUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<DriverCreateWithoutVendorInput, DriverUncheckedCreateWithoutVendorInput> | DriverCreateWithoutVendorInput[] | DriverUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: DriverCreateOrConnectWithoutVendorInput | DriverCreateOrConnectWithoutVendorInput[]
    upsert?: DriverUpsertWithWhereUniqueWithoutVendorInput | DriverUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: DriverCreateManyVendorInputEnvelope
    set?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    disconnect?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    delete?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    connect?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    update?: DriverUpdateWithWhereUniqueWithoutVendorInput | DriverUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: DriverUpdateManyWithWhereWithoutVendorInput | DriverUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: DriverScalarWhereInput | DriverScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<UserCreateWithoutVendorInput, UserUncheckedCreateWithoutVendorInput> | UserCreateWithoutVendorInput[] | UserUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: UserCreateOrConnectWithoutVendorInput | UserCreateOrConnectWithoutVendorInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutVendorInput | UserUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: UserCreateManyVendorInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutVendorInput | UserUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: UserUpdateManyWithWhereWithoutVendorInput | UserUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type VendorCreateNestedOneWithoutProfileInput = {
    create?: XOR<VendorCreateWithoutProfileInput, VendorUncheckedCreateWithoutProfileInput>
    connectOrCreate?: VendorCreateOrConnectWithoutProfileInput
    connect?: VendorWhereUniqueInput
  }

  export type VendorUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<VendorCreateWithoutProfileInput, VendorUncheckedCreateWithoutProfileInput>
    connectOrCreate?: VendorCreateOrConnectWithoutProfileInput
    upsert?: VendorUpsertWithoutProfileInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutProfileInput, VendorUpdateWithoutProfileInput>, VendorUncheckedUpdateWithoutProfileInput>
  }

  export type VendorCreateNestedOneWithoutDriversInput = {
    create?: XOR<VendorCreateWithoutDriversInput, VendorUncheckedCreateWithoutDriversInput>
    connectOrCreate?: VendorCreateOrConnectWithoutDriversInput
    connect?: VendorWhereUniqueInput
  }

  export type VendorUpdateOneRequiredWithoutDriversNestedInput = {
    create?: XOR<VendorCreateWithoutDriversInput, VendorUncheckedCreateWithoutDriversInput>
    connectOrCreate?: VendorCreateOrConnectWithoutDriversInput
    upsert?: VendorUpsertWithoutDriversInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutDriversInput, VendorUpdateWithoutDriversInput>, VendorUncheckedUpdateWithoutDriversInput>
  }

  export type VendorCreateNestedOneWithoutAgreementsInput = {
    create?: XOR<VendorCreateWithoutAgreementsInput, VendorUncheckedCreateWithoutAgreementsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutAgreementsInput
    connect?: VendorWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAgreementsReviewedInput = {
    create?: XOR<UserCreateWithoutAgreementsReviewedInput, UserUncheckedCreateWithoutAgreementsReviewedInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgreementsReviewedInput
    connect?: UserWhereUniqueInput
  }

  export type RateCardCreateNestedManyWithoutAgreementInput = {
    create?: XOR<RateCardCreateWithoutAgreementInput, RateCardUncheckedCreateWithoutAgreementInput> | RateCardCreateWithoutAgreementInput[] | RateCardUncheckedCreateWithoutAgreementInput[]
    connectOrCreate?: RateCardCreateOrConnectWithoutAgreementInput | RateCardCreateOrConnectWithoutAgreementInput[]
    createMany?: RateCardCreateManyAgreementInputEnvelope
    connect?: RateCardWhereUniqueInput | RateCardWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutAgreementsInput = {
    create?: XOR<CompanyCreateWithoutAgreementsInput, CompanyUncheckedCreateWithoutAgreementsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAgreementsInput
    connect?: CompanyWhereUniqueInput
  }

  export type RateCardUncheckedCreateNestedManyWithoutAgreementInput = {
    create?: XOR<RateCardCreateWithoutAgreementInput, RateCardUncheckedCreateWithoutAgreementInput> | RateCardCreateWithoutAgreementInput[] | RateCardUncheckedCreateWithoutAgreementInput[]
    connectOrCreate?: RateCardCreateOrConnectWithoutAgreementInput | RateCardCreateOrConnectWithoutAgreementInput[]
    createMany?: RateCardCreateManyAgreementInputEnvelope
    connect?: RateCardWhereUniqueInput | RateCardWhereUniqueInput[]
  }

  export type VendorUpdateOneRequiredWithoutAgreementsNestedInput = {
    create?: XOR<VendorCreateWithoutAgreementsInput, VendorUncheckedCreateWithoutAgreementsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutAgreementsInput
    upsert?: VendorUpsertWithoutAgreementsInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutAgreementsInput, VendorUpdateWithoutAgreementsInput>, VendorUncheckedUpdateWithoutAgreementsInput>
  }

  export type UserUpdateOneWithoutAgreementsReviewedNestedInput = {
    create?: XOR<UserCreateWithoutAgreementsReviewedInput, UserUncheckedCreateWithoutAgreementsReviewedInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgreementsReviewedInput
    upsert?: UserUpsertWithoutAgreementsReviewedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAgreementsReviewedInput, UserUpdateWithoutAgreementsReviewedInput>, UserUncheckedUpdateWithoutAgreementsReviewedInput>
  }

  export type RateCardUpdateManyWithoutAgreementNestedInput = {
    create?: XOR<RateCardCreateWithoutAgreementInput, RateCardUncheckedCreateWithoutAgreementInput> | RateCardCreateWithoutAgreementInput[] | RateCardUncheckedCreateWithoutAgreementInput[]
    connectOrCreate?: RateCardCreateOrConnectWithoutAgreementInput | RateCardCreateOrConnectWithoutAgreementInput[]
    upsert?: RateCardUpsertWithWhereUniqueWithoutAgreementInput | RateCardUpsertWithWhereUniqueWithoutAgreementInput[]
    createMany?: RateCardCreateManyAgreementInputEnvelope
    set?: RateCardWhereUniqueInput | RateCardWhereUniqueInput[]
    disconnect?: RateCardWhereUniqueInput | RateCardWhereUniqueInput[]
    delete?: RateCardWhereUniqueInput | RateCardWhereUniqueInput[]
    connect?: RateCardWhereUniqueInput | RateCardWhereUniqueInput[]
    update?: RateCardUpdateWithWhereUniqueWithoutAgreementInput | RateCardUpdateWithWhereUniqueWithoutAgreementInput[]
    updateMany?: RateCardUpdateManyWithWhereWithoutAgreementInput | RateCardUpdateManyWithWhereWithoutAgreementInput[]
    deleteMany?: RateCardScalarWhereInput | RateCardScalarWhereInput[]
  }

  export type CompanyUpdateOneWithoutAgreementsNestedInput = {
    create?: XOR<CompanyCreateWithoutAgreementsInput, CompanyUncheckedCreateWithoutAgreementsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAgreementsInput
    upsert?: CompanyUpsertWithoutAgreementsInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutAgreementsInput, CompanyUpdateWithoutAgreementsInput>, CompanyUncheckedUpdateWithoutAgreementsInput>
  }

  export type RateCardUncheckedUpdateManyWithoutAgreementNestedInput = {
    create?: XOR<RateCardCreateWithoutAgreementInput, RateCardUncheckedCreateWithoutAgreementInput> | RateCardCreateWithoutAgreementInput[] | RateCardUncheckedCreateWithoutAgreementInput[]
    connectOrCreate?: RateCardCreateOrConnectWithoutAgreementInput | RateCardCreateOrConnectWithoutAgreementInput[]
    upsert?: RateCardUpsertWithWhereUniqueWithoutAgreementInput | RateCardUpsertWithWhereUniqueWithoutAgreementInput[]
    createMany?: RateCardCreateManyAgreementInputEnvelope
    set?: RateCardWhereUniqueInput | RateCardWhereUniqueInput[]
    disconnect?: RateCardWhereUniqueInput | RateCardWhereUniqueInput[]
    delete?: RateCardWhereUniqueInput | RateCardWhereUniqueInput[]
    connect?: RateCardWhereUniqueInput | RateCardWhereUniqueInput[]
    update?: RateCardUpdateWithWhereUniqueWithoutAgreementInput | RateCardUpdateWithWhereUniqueWithoutAgreementInput[]
    updateMany?: RateCardUpdateManyWithWhereWithoutAgreementInput | RateCardUpdateManyWithWhereWithoutAgreementInput[]
    deleteMany?: RateCardScalarWhereInput | RateCardScalarWhereInput[]
  }

  export type AgreementCreateNestedOneWithoutRateCardsInput = {
    create?: XOR<AgreementCreateWithoutRateCardsInput, AgreementUncheckedCreateWithoutRateCardsInput>
    connectOrCreate?: AgreementCreateOrConnectWithoutRateCardsInput
    connect?: AgreementWhereUniqueInput
  }

  export type VendorCreateNestedOneWithoutRateCardsInput = {
    create?: XOR<VendorCreateWithoutRateCardsInput, VendorUncheckedCreateWithoutRateCardsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutRateCardsInput
    connect?: VendorWhereUniqueInput
  }

  export type ShipmentCreateNestedManyWithoutRateCardInput = {
    create?: XOR<ShipmentCreateWithoutRateCardInput, ShipmentUncheckedCreateWithoutRateCardInput> | ShipmentCreateWithoutRateCardInput[] | ShipmentUncheckedCreateWithoutRateCardInput[]
    connectOrCreate?: ShipmentCreateOrConnectWithoutRateCardInput | ShipmentCreateOrConnectWithoutRateCardInput[]
    createMany?: ShipmentCreateManyRateCardInputEnvelope
    connect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
  }

  export type ShipmentUncheckedCreateNestedManyWithoutRateCardInput = {
    create?: XOR<ShipmentCreateWithoutRateCardInput, ShipmentUncheckedCreateWithoutRateCardInput> | ShipmentCreateWithoutRateCardInput[] | ShipmentUncheckedCreateWithoutRateCardInput[]
    connectOrCreate?: ShipmentCreateOrConnectWithoutRateCardInput | ShipmentCreateOrConnectWithoutRateCardInput[]
    createMany?: ShipmentCreateManyRateCardInputEnvelope
    connect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AgreementUpdateOneRequiredWithoutRateCardsNestedInput = {
    create?: XOR<AgreementCreateWithoutRateCardsInput, AgreementUncheckedCreateWithoutRateCardsInput>
    connectOrCreate?: AgreementCreateOrConnectWithoutRateCardsInput
    upsert?: AgreementUpsertWithoutRateCardsInput
    connect?: AgreementWhereUniqueInput
    update?: XOR<XOR<AgreementUpdateToOneWithWhereWithoutRateCardsInput, AgreementUpdateWithoutRateCardsInput>, AgreementUncheckedUpdateWithoutRateCardsInput>
  }

  export type VendorUpdateOneWithoutRateCardsNestedInput = {
    create?: XOR<VendorCreateWithoutRateCardsInput, VendorUncheckedCreateWithoutRateCardsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutRateCardsInput
    upsert?: VendorUpsertWithoutRateCardsInput
    disconnect?: VendorWhereInput | boolean
    delete?: VendorWhereInput | boolean
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutRateCardsInput, VendorUpdateWithoutRateCardsInput>, VendorUncheckedUpdateWithoutRateCardsInput>
  }

  export type ShipmentUpdateManyWithoutRateCardNestedInput = {
    create?: XOR<ShipmentCreateWithoutRateCardInput, ShipmentUncheckedCreateWithoutRateCardInput> | ShipmentCreateWithoutRateCardInput[] | ShipmentUncheckedCreateWithoutRateCardInput[]
    connectOrCreate?: ShipmentCreateOrConnectWithoutRateCardInput | ShipmentCreateOrConnectWithoutRateCardInput[]
    upsert?: ShipmentUpsertWithWhereUniqueWithoutRateCardInput | ShipmentUpsertWithWhereUniqueWithoutRateCardInput[]
    createMany?: ShipmentCreateManyRateCardInputEnvelope
    set?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    disconnect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    delete?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    connect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    update?: ShipmentUpdateWithWhereUniqueWithoutRateCardInput | ShipmentUpdateWithWhereUniqueWithoutRateCardInput[]
    updateMany?: ShipmentUpdateManyWithWhereWithoutRateCardInput | ShipmentUpdateManyWithWhereWithoutRateCardInput[]
    deleteMany?: ShipmentScalarWhereInput | ShipmentScalarWhereInput[]
  }

  export type ShipmentUncheckedUpdateManyWithoutRateCardNestedInput = {
    create?: XOR<ShipmentCreateWithoutRateCardInput, ShipmentUncheckedCreateWithoutRateCardInput> | ShipmentCreateWithoutRateCardInput[] | ShipmentUncheckedCreateWithoutRateCardInput[]
    connectOrCreate?: ShipmentCreateOrConnectWithoutRateCardInput | ShipmentCreateOrConnectWithoutRateCardInput[]
    upsert?: ShipmentUpsertWithWhereUniqueWithoutRateCardInput | ShipmentUpsertWithWhereUniqueWithoutRateCardInput[]
    createMany?: ShipmentCreateManyRateCardInputEnvelope
    set?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    disconnect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    delete?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    connect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    update?: ShipmentUpdateWithWhereUniqueWithoutRateCardInput | ShipmentUpdateWithWhereUniqueWithoutRateCardInput[]
    updateMany?: ShipmentUpdateManyWithWhereWithoutRateCardInput | ShipmentUpdateManyWithWhereWithoutRateCardInput[]
    deleteMany?: ShipmentScalarWhereInput | ShipmentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutQuoteRequestInput = {
    create?: XOR<UserCreateWithoutQuoteRequestInput, UserUncheckedCreateWithoutQuoteRequestInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuoteRequestInput
    connect?: UserWhereUniqueInput
  }

  export type QuoteResponseCreateNestedManyWithoutQuoteRequestInput = {
    create?: XOR<QuoteResponseCreateWithoutQuoteRequestInput, QuoteResponseUncheckedCreateWithoutQuoteRequestInput> | QuoteResponseCreateWithoutQuoteRequestInput[] | QuoteResponseUncheckedCreateWithoutQuoteRequestInput[]
    connectOrCreate?: QuoteResponseCreateOrConnectWithoutQuoteRequestInput | QuoteResponseCreateOrConnectWithoutQuoteRequestInput[]
    createMany?: QuoteResponseCreateManyQuoteRequestInputEnvelope
    connect?: QuoteResponseWhereUniqueInput | QuoteResponseWhereUniqueInput[]
  }

  export type QuoteResponseCreateNestedOneWithoutApprovedForInput = {
    create?: XOR<QuoteResponseCreateWithoutApprovedForInput, QuoteResponseUncheckedCreateWithoutApprovedForInput>
    connectOrCreate?: QuoteResponseCreateOrConnectWithoutApprovedForInput
    connect?: QuoteResponseWhereUniqueInput
  }

  export type ShipmentCreateNestedOneWithoutQuoteRequestInput = {
    create?: XOR<ShipmentCreateWithoutQuoteRequestInput, ShipmentUncheckedCreateWithoutQuoteRequestInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutQuoteRequestInput
    connect?: ShipmentWhereUniqueInput
  }

  export type QuoteResponseUncheckedCreateNestedManyWithoutQuoteRequestInput = {
    create?: XOR<QuoteResponseCreateWithoutQuoteRequestInput, QuoteResponseUncheckedCreateWithoutQuoteRequestInput> | QuoteResponseCreateWithoutQuoteRequestInput[] | QuoteResponseUncheckedCreateWithoutQuoteRequestInput[]
    connectOrCreate?: QuoteResponseCreateOrConnectWithoutQuoteRequestInput | QuoteResponseCreateOrConnectWithoutQuoteRequestInput[]
    createMany?: QuoteResponseCreateManyQuoteRequestInputEnvelope
    connect?: QuoteResponseWhereUniqueInput | QuoteResponseWhereUniqueInput[]
  }

  export type ShipmentUncheckedCreateNestedOneWithoutQuoteRequestInput = {
    create?: XOR<ShipmentCreateWithoutQuoteRequestInput, ShipmentUncheckedCreateWithoutQuoteRequestInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutQuoteRequestInput
    connect?: ShipmentWhereUniqueInput
  }

  export type EnumQuoteStatusFieldUpdateOperationsInput = {
    set?: $Enums.QuoteStatus
  }

  export type UserUpdateOneRequiredWithoutQuoteRequestNestedInput = {
    create?: XOR<UserCreateWithoutQuoteRequestInput, UserUncheckedCreateWithoutQuoteRequestInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuoteRequestInput
    upsert?: UserUpsertWithoutQuoteRequestInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutQuoteRequestInput, UserUpdateWithoutQuoteRequestInput>, UserUncheckedUpdateWithoutQuoteRequestInput>
  }

  export type QuoteResponseUpdateManyWithoutQuoteRequestNestedInput = {
    create?: XOR<QuoteResponseCreateWithoutQuoteRequestInput, QuoteResponseUncheckedCreateWithoutQuoteRequestInput> | QuoteResponseCreateWithoutQuoteRequestInput[] | QuoteResponseUncheckedCreateWithoutQuoteRequestInput[]
    connectOrCreate?: QuoteResponseCreateOrConnectWithoutQuoteRequestInput | QuoteResponseCreateOrConnectWithoutQuoteRequestInput[]
    upsert?: QuoteResponseUpsertWithWhereUniqueWithoutQuoteRequestInput | QuoteResponseUpsertWithWhereUniqueWithoutQuoteRequestInput[]
    createMany?: QuoteResponseCreateManyQuoteRequestInputEnvelope
    set?: QuoteResponseWhereUniqueInput | QuoteResponseWhereUniqueInput[]
    disconnect?: QuoteResponseWhereUniqueInput | QuoteResponseWhereUniqueInput[]
    delete?: QuoteResponseWhereUniqueInput | QuoteResponseWhereUniqueInput[]
    connect?: QuoteResponseWhereUniqueInput | QuoteResponseWhereUniqueInput[]
    update?: QuoteResponseUpdateWithWhereUniqueWithoutQuoteRequestInput | QuoteResponseUpdateWithWhereUniqueWithoutQuoteRequestInput[]
    updateMany?: QuoteResponseUpdateManyWithWhereWithoutQuoteRequestInput | QuoteResponseUpdateManyWithWhereWithoutQuoteRequestInput[]
    deleteMany?: QuoteResponseScalarWhereInput | QuoteResponseScalarWhereInput[]
  }

  export type QuoteResponseUpdateOneWithoutApprovedForNestedInput = {
    create?: XOR<QuoteResponseCreateWithoutApprovedForInput, QuoteResponseUncheckedCreateWithoutApprovedForInput>
    connectOrCreate?: QuoteResponseCreateOrConnectWithoutApprovedForInput
    upsert?: QuoteResponseUpsertWithoutApprovedForInput
    disconnect?: QuoteResponseWhereInput | boolean
    delete?: QuoteResponseWhereInput | boolean
    connect?: QuoteResponseWhereUniqueInput
    update?: XOR<XOR<QuoteResponseUpdateToOneWithWhereWithoutApprovedForInput, QuoteResponseUpdateWithoutApprovedForInput>, QuoteResponseUncheckedUpdateWithoutApprovedForInput>
  }

  export type ShipmentUpdateOneWithoutQuoteRequestNestedInput = {
    create?: XOR<ShipmentCreateWithoutQuoteRequestInput, ShipmentUncheckedCreateWithoutQuoteRequestInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutQuoteRequestInput
    upsert?: ShipmentUpsertWithoutQuoteRequestInput
    disconnect?: ShipmentWhereInput | boolean
    delete?: ShipmentWhereInput | boolean
    connect?: ShipmentWhereUniqueInput
    update?: XOR<XOR<ShipmentUpdateToOneWithWhereWithoutQuoteRequestInput, ShipmentUpdateWithoutQuoteRequestInput>, ShipmentUncheckedUpdateWithoutQuoteRequestInput>
  }

  export type QuoteResponseUncheckedUpdateManyWithoutQuoteRequestNestedInput = {
    create?: XOR<QuoteResponseCreateWithoutQuoteRequestInput, QuoteResponseUncheckedCreateWithoutQuoteRequestInput> | QuoteResponseCreateWithoutQuoteRequestInput[] | QuoteResponseUncheckedCreateWithoutQuoteRequestInput[]
    connectOrCreate?: QuoteResponseCreateOrConnectWithoutQuoteRequestInput | QuoteResponseCreateOrConnectWithoutQuoteRequestInput[]
    upsert?: QuoteResponseUpsertWithWhereUniqueWithoutQuoteRequestInput | QuoteResponseUpsertWithWhereUniqueWithoutQuoteRequestInput[]
    createMany?: QuoteResponseCreateManyQuoteRequestInputEnvelope
    set?: QuoteResponseWhereUniqueInput | QuoteResponseWhereUniqueInput[]
    disconnect?: QuoteResponseWhereUniqueInput | QuoteResponseWhereUniqueInput[]
    delete?: QuoteResponseWhereUniqueInput | QuoteResponseWhereUniqueInput[]
    connect?: QuoteResponseWhereUniqueInput | QuoteResponseWhereUniqueInput[]
    update?: QuoteResponseUpdateWithWhereUniqueWithoutQuoteRequestInput | QuoteResponseUpdateWithWhereUniqueWithoutQuoteRequestInput[]
    updateMany?: QuoteResponseUpdateManyWithWhereWithoutQuoteRequestInput | QuoteResponseUpdateManyWithWhereWithoutQuoteRequestInput[]
    deleteMany?: QuoteResponseScalarWhereInput | QuoteResponseScalarWhereInput[]
  }

  export type ShipmentUncheckedUpdateOneWithoutQuoteRequestNestedInput = {
    create?: XOR<ShipmentCreateWithoutQuoteRequestInput, ShipmentUncheckedCreateWithoutQuoteRequestInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutQuoteRequestInput
    upsert?: ShipmentUpsertWithoutQuoteRequestInput
    disconnect?: ShipmentWhereInput | boolean
    delete?: ShipmentWhereInput | boolean
    connect?: ShipmentWhereUniqueInput
    update?: XOR<XOR<ShipmentUpdateToOneWithWhereWithoutQuoteRequestInput, ShipmentUpdateWithoutQuoteRequestInput>, ShipmentUncheckedUpdateWithoutQuoteRequestInput>
  }

  export type QuoteRequestCreateNestedOneWithoutResponsesInput = {
    create?: XOR<QuoteRequestCreateWithoutResponsesInput, QuoteRequestUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: QuoteRequestCreateOrConnectWithoutResponsesInput
    connect?: QuoteRequestWhereUniqueInput
  }

  export type VendorCreateNestedOneWithoutQuoteResponsesInput = {
    create?: XOR<VendorCreateWithoutQuoteResponsesInput, VendorUncheckedCreateWithoutQuoteResponsesInput>
    connectOrCreate?: VendorCreateOrConnectWithoutQuoteResponsesInput
    connect?: VendorWhereUniqueInput
  }

  export type ShipmentCreateNestedOneWithoutTransporterQuoteInput = {
    create?: XOR<ShipmentCreateWithoutTransporterQuoteInput, ShipmentUncheckedCreateWithoutTransporterQuoteInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutTransporterQuoteInput
    connect?: ShipmentWhereUniqueInput
  }

  export type QuoteRequestCreateNestedOneWithoutApprovedResponseInput = {
    create?: XOR<QuoteRequestCreateWithoutApprovedResponseInput, QuoteRequestUncheckedCreateWithoutApprovedResponseInput>
    connectOrCreate?: QuoteRequestCreateOrConnectWithoutApprovedResponseInput
    connect?: QuoteRequestWhereUniqueInput
  }

  export type ConsentLogCreateNestedManyWithoutQuoteResponseInput = {
    create?: XOR<ConsentLogCreateWithoutQuoteResponseInput, ConsentLogUncheckedCreateWithoutQuoteResponseInput> | ConsentLogCreateWithoutQuoteResponseInput[] | ConsentLogUncheckedCreateWithoutQuoteResponseInput[]
    connectOrCreate?: ConsentLogCreateOrConnectWithoutQuoteResponseInput | ConsentLogCreateOrConnectWithoutQuoteResponseInput[]
    createMany?: ConsentLogCreateManyQuoteResponseInputEnvelope
    connect?: ConsentLogWhereUniqueInput | ConsentLogWhereUniqueInput[]
  }

  export type ShipmentUncheckedCreateNestedOneWithoutTransporterQuoteInput = {
    create?: XOR<ShipmentCreateWithoutTransporterQuoteInput, ShipmentUncheckedCreateWithoutTransporterQuoteInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutTransporterQuoteInput
    connect?: ShipmentWhereUniqueInput
  }

  export type QuoteRequestUncheckedCreateNestedOneWithoutApprovedResponseInput = {
    create?: XOR<QuoteRequestCreateWithoutApprovedResponseInput, QuoteRequestUncheckedCreateWithoutApprovedResponseInput>
    connectOrCreate?: QuoteRequestCreateOrConnectWithoutApprovedResponseInput
    connect?: QuoteRequestWhereUniqueInput
  }

  export type ConsentLogUncheckedCreateNestedManyWithoutQuoteResponseInput = {
    create?: XOR<ConsentLogCreateWithoutQuoteResponseInput, ConsentLogUncheckedCreateWithoutQuoteResponseInput> | ConsentLogCreateWithoutQuoteResponseInput[] | ConsentLogUncheckedCreateWithoutQuoteResponseInput[]
    connectOrCreate?: ConsentLogCreateOrConnectWithoutQuoteResponseInput | ConsentLogCreateOrConnectWithoutQuoteResponseInput[]
    createMany?: ConsentLogCreateManyQuoteResponseInputEnvelope
    connect?: ConsentLogWhereUniqueInput | ConsentLogWhereUniqueInput[]
  }

  export type EnumQuoteResponseStatusFieldUpdateOperationsInput = {
    set?: $Enums.QuoteResponseStatus
  }

  export type QuoteRequestUpdateOneRequiredWithoutResponsesNestedInput = {
    create?: XOR<QuoteRequestCreateWithoutResponsesInput, QuoteRequestUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: QuoteRequestCreateOrConnectWithoutResponsesInput
    upsert?: QuoteRequestUpsertWithoutResponsesInput
    connect?: QuoteRequestWhereUniqueInput
    update?: XOR<XOR<QuoteRequestUpdateToOneWithWhereWithoutResponsesInput, QuoteRequestUpdateWithoutResponsesInput>, QuoteRequestUncheckedUpdateWithoutResponsesInput>
  }

  export type VendorUpdateOneRequiredWithoutQuoteResponsesNestedInput = {
    create?: XOR<VendorCreateWithoutQuoteResponsesInput, VendorUncheckedCreateWithoutQuoteResponsesInput>
    connectOrCreate?: VendorCreateOrConnectWithoutQuoteResponsesInput
    upsert?: VendorUpsertWithoutQuoteResponsesInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutQuoteResponsesInput, VendorUpdateWithoutQuoteResponsesInput>, VendorUncheckedUpdateWithoutQuoteResponsesInput>
  }

  export type ShipmentUpdateOneWithoutTransporterQuoteNestedInput = {
    create?: XOR<ShipmentCreateWithoutTransporterQuoteInput, ShipmentUncheckedCreateWithoutTransporterQuoteInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutTransporterQuoteInput
    upsert?: ShipmentUpsertWithoutTransporterQuoteInput
    disconnect?: ShipmentWhereInput | boolean
    delete?: ShipmentWhereInput | boolean
    connect?: ShipmentWhereUniqueInput
    update?: XOR<XOR<ShipmentUpdateToOneWithWhereWithoutTransporterQuoteInput, ShipmentUpdateWithoutTransporterQuoteInput>, ShipmentUncheckedUpdateWithoutTransporterQuoteInput>
  }

  export type QuoteRequestUpdateOneWithoutApprovedResponseNestedInput = {
    create?: XOR<QuoteRequestCreateWithoutApprovedResponseInput, QuoteRequestUncheckedCreateWithoutApprovedResponseInput>
    connectOrCreate?: QuoteRequestCreateOrConnectWithoutApprovedResponseInput
    upsert?: QuoteRequestUpsertWithoutApprovedResponseInput
    disconnect?: QuoteRequestWhereInput | boolean
    delete?: QuoteRequestWhereInput | boolean
    connect?: QuoteRequestWhereUniqueInput
    update?: XOR<XOR<QuoteRequestUpdateToOneWithWhereWithoutApprovedResponseInput, QuoteRequestUpdateWithoutApprovedResponseInput>, QuoteRequestUncheckedUpdateWithoutApprovedResponseInput>
  }

  export type ConsentLogUpdateManyWithoutQuoteResponseNestedInput = {
    create?: XOR<ConsentLogCreateWithoutQuoteResponseInput, ConsentLogUncheckedCreateWithoutQuoteResponseInput> | ConsentLogCreateWithoutQuoteResponseInput[] | ConsentLogUncheckedCreateWithoutQuoteResponseInput[]
    connectOrCreate?: ConsentLogCreateOrConnectWithoutQuoteResponseInput | ConsentLogCreateOrConnectWithoutQuoteResponseInput[]
    upsert?: ConsentLogUpsertWithWhereUniqueWithoutQuoteResponseInput | ConsentLogUpsertWithWhereUniqueWithoutQuoteResponseInput[]
    createMany?: ConsentLogCreateManyQuoteResponseInputEnvelope
    set?: ConsentLogWhereUniqueInput | ConsentLogWhereUniqueInput[]
    disconnect?: ConsentLogWhereUniqueInput | ConsentLogWhereUniqueInput[]
    delete?: ConsentLogWhereUniqueInput | ConsentLogWhereUniqueInput[]
    connect?: ConsentLogWhereUniqueInput | ConsentLogWhereUniqueInput[]
    update?: ConsentLogUpdateWithWhereUniqueWithoutQuoteResponseInput | ConsentLogUpdateWithWhereUniqueWithoutQuoteResponseInput[]
    updateMany?: ConsentLogUpdateManyWithWhereWithoutQuoteResponseInput | ConsentLogUpdateManyWithWhereWithoutQuoteResponseInput[]
    deleteMany?: ConsentLogScalarWhereInput | ConsentLogScalarWhereInput[]
  }

  export type ShipmentUncheckedUpdateOneWithoutTransporterQuoteNestedInput = {
    create?: XOR<ShipmentCreateWithoutTransporterQuoteInput, ShipmentUncheckedCreateWithoutTransporterQuoteInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutTransporterQuoteInput
    upsert?: ShipmentUpsertWithoutTransporterQuoteInput
    disconnect?: ShipmentWhereInput | boolean
    delete?: ShipmentWhereInput | boolean
    connect?: ShipmentWhereUniqueInput
    update?: XOR<XOR<ShipmentUpdateToOneWithWhereWithoutTransporterQuoteInput, ShipmentUpdateWithoutTransporterQuoteInput>, ShipmentUncheckedUpdateWithoutTransporterQuoteInput>
  }

  export type QuoteRequestUncheckedUpdateOneWithoutApprovedResponseNestedInput = {
    create?: XOR<QuoteRequestCreateWithoutApprovedResponseInput, QuoteRequestUncheckedCreateWithoutApprovedResponseInput>
    connectOrCreate?: QuoteRequestCreateOrConnectWithoutApprovedResponseInput
    upsert?: QuoteRequestUpsertWithoutApprovedResponseInput
    disconnect?: QuoteRequestWhereInput | boolean
    delete?: QuoteRequestWhereInput | boolean
    connect?: QuoteRequestWhereUniqueInput
    update?: XOR<XOR<QuoteRequestUpdateToOneWithWhereWithoutApprovedResponseInput, QuoteRequestUpdateWithoutApprovedResponseInput>, QuoteRequestUncheckedUpdateWithoutApprovedResponseInput>
  }

  export type ConsentLogUncheckedUpdateManyWithoutQuoteResponseNestedInput = {
    create?: XOR<ConsentLogCreateWithoutQuoteResponseInput, ConsentLogUncheckedCreateWithoutQuoteResponseInput> | ConsentLogCreateWithoutQuoteResponseInput[] | ConsentLogUncheckedCreateWithoutQuoteResponseInput[]
    connectOrCreate?: ConsentLogCreateOrConnectWithoutQuoteResponseInput | ConsentLogCreateOrConnectWithoutQuoteResponseInput[]
    upsert?: ConsentLogUpsertWithWhereUniqueWithoutQuoteResponseInput | ConsentLogUpsertWithWhereUniqueWithoutQuoteResponseInput[]
    createMany?: ConsentLogCreateManyQuoteResponseInputEnvelope
    set?: ConsentLogWhereUniqueInput | ConsentLogWhereUniqueInput[]
    disconnect?: ConsentLogWhereUniqueInput | ConsentLogWhereUniqueInput[]
    delete?: ConsentLogWhereUniqueInput | ConsentLogWhereUniqueInput[]
    connect?: ConsentLogWhereUniqueInput | ConsentLogWhereUniqueInput[]
    update?: ConsentLogUpdateWithWhereUniqueWithoutQuoteResponseInput | ConsentLogUpdateWithWhereUniqueWithoutQuoteResponseInput[]
    updateMany?: ConsentLogUpdateManyWithWhereWithoutQuoteResponseInput | ConsentLogUpdateManyWithWhereWithoutQuoteResponseInput[]
    deleteMany?: ConsentLogScalarWhereInput | ConsentLogScalarWhereInput[]
  }

  export type QuoteResponseCreateNestedOneWithoutConsentLogsInput = {
    create?: XOR<QuoteResponseCreateWithoutConsentLogsInput, QuoteResponseUncheckedCreateWithoutConsentLogsInput>
    connectOrCreate?: QuoteResponseCreateOrConnectWithoutConsentLogsInput
    connect?: QuoteResponseWhereUniqueInput
  }

  export type ShipmentCreateNestedOneWithoutConsentLogsInput = {
    create?: XOR<ShipmentCreateWithoutConsentLogsInput, ShipmentUncheckedCreateWithoutConsentLogsInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutConsentLogsInput
    connect?: ShipmentWhereUniqueInput
  }

  export type QuoteResponseUpdateOneRequiredWithoutConsentLogsNestedInput = {
    create?: XOR<QuoteResponseCreateWithoutConsentLogsInput, QuoteResponseUncheckedCreateWithoutConsentLogsInput>
    connectOrCreate?: QuoteResponseCreateOrConnectWithoutConsentLogsInput
    upsert?: QuoteResponseUpsertWithoutConsentLogsInput
    connect?: QuoteResponseWhereUniqueInput
    update?: XOR<XOR<QuoteResponseUpdateToOneWithWhereWithoutConsentLogsInput, QuoteResponseUpdateWithoutConsentLogsInput>, QuoteResponseUncheckedUpdateWithoutConsentLogsInput>
  }

  export type ShipmentUpdateOneWithoutConsentLogsNestedInput = {
    create?: XOR<ShipmentCreateWithoutConsentLogsInput, ShipmentUncheckedCreateWithoutConsentLogsInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutConsentLogsInput
    upsert?: ShipmentUpsertWithoutConsentLogsInput
    disconnect?: ShipmentWhereInput | boolean
    delete?: ShipmentWhereInput | boolean
    connect?: ShipmentWhereUniqueInput
    update?: XOR<XOR<ShipmentUpdateToOneWithWhereWithoutConsentLogsInput, ShipmentUpdateWithoutConsentLogsInput>, ShipmentUncheckedUpdateWithoutConsentLogsInput>
  }

  export type UserCreateNestedOneWithoutShipmentsInput = {
    create?: XOR<UserCreateWithoutShipmentsInput, UserUncheckedCreateWithoutShipmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutShipmentsInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutShipmentsInput = {
    create?: XOR<CompanyCreateWithoutShipmentsInput, CompanyUncheckedCreateWithoutShipmentsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutShipmentsInput
    connect?: CompanyWhereUniqueInput
  }

  export type QuoteRequestCreateNestedOneWithoutShipmentInput = {
    create?: XOR<QuoteRequestCreateWithoutShipmentInput, QuoteRequestUncheckedCreateWithoutShipmentInput>
    connectOrCreate?: QuoteRequestCreateOrConnectWithoutShipmentInput
    connect?: QuoteRequestWhereUniqueInput
  }

  export type QuoteResponseCreateNestedOneWithoutShipmentInput = {
    create?: XOR<QuoteResponseCreateWithoutShipmentInput, QuoteResponseUncheckedCreateWithoutShipmentInput>
    connectOrCreate?: QuoteResponseCreateOrConnectWithoutShipmentInput
    connect?: QuoteResponseWhereUniqueInput
  }

  export type RateCardCreateNestedOneWithoutShipmentsInput = {
    create?: XOR<RateCardCreateWithoutShipmentsInput, RateCardUncheckedCreateWithoutShipmentsInput>
    connectOrCreate?: RateCardCreateOrConnectWithoutShipmentsInput
    connect?: RateCardWhereUniqueInput
  }

  export type VendorCreateNestedOneWithoutShipmentsInput = {
    create?: XOR<VendorCreateWithoutShipmentsInput, VendorUncheckedCreateWithoutShipmentsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutShipmentsInput
    connect?: VendorWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignedShipmentsInput = {
    create?: XOR<UserCreateWithoutAssignedShipmentsInput, UserUncheckedCreateWithoutAssignedShipmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedShipmentsInput
    connect?: UserWhereUniqueInput
  }

  export type StatusHistoryCreateNestedManyWithoutShipmentInput = {
    create?: XOR<StatusHistoryCreateWithoutShipmentInput, StatusHistoryUncheckedCreateWithoutShipmentInput> | StatusHistoryCreateWithoutShipmentInput[] | StatusHistoryUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: StatusHistoryCreateOrConnectWithoutShipmentInput | StatusHistoryCreateOrConnectWithoutShipmentInput[]
    createMany?: StatusHistoryCreateManyShipmentInputEnvelope
    connect?: StatusHistoryWhereUniqueInput | StatusHistoryWhereUniqueInput[]
  }

  export type ComplianceDocumentCreateNestedManyWithoutShipmentInput = {
    create?: XOR<ComplianceDocumentCreateWithoutShipmentInput, ComplianceDocumentUncheckedCreateWithoutShipmentInput> | ComplianceDocumentCreateWithoutShipmentInput[] | ComplianceDocumentUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: ComplianceDocumentCreateOrConnectWithoutShipmentInput | ComplianceDocumentCreateOrConnectWithoutShipmentInput[]
    createMany?: ComplianceDocumentCreateManyShipmentInputEnvelope
    connect?: ComplianceDocumentWhereUniqueInput | ComplianceDocumentWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutShipmentInput = {
    create?: XOR<PaymentCreateWithoutShipmentInput, PaymentUncheckedCreateWithoutShipmentInput> | PaymentCreateWithoutShipmentInput[] | PaymentUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutShipmentInput | PaymentCreateOrConnectWithoutShipmentInput[]
    createMany?: PaymentCreateManyShipmentInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type InvoiceCreateNestedOneWithoutShipmentInput = {
    create?: XOR<InvoiceCreateWithoutShipmentInput, InvoiceUncheckedCreateWithoutShipmentInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutShipmentInput
    connect?: InvoiceWhereUniqueInput
  }

  export type ConsentLogCreateNestedManyWithoutShipmentInput = {
    create?: XOR<ConsentLogCreateWithoutShipmentInput, ConsentLogUncheckedCreateWithoutShipmentInput> | ConsentLogCreateWithoutShipmentInput[] | ConsentLogUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: ConsentLogCreateOrConnectWithoutShipmentInput | ConsentLogCreateOrConnectWithoutShipmentInput[]
    createMany?: ConsentLogCreateManyShipmentInputEnvelope
    connect?: ConsentLogWhereUniqueInput | ConsentLogWhereUniqueInput[]
  }

  export type TransporterInvoiceCreateNestedManyWithoutShipmentInput = {
    create?: XOR<TransporterInvoiceCreateWithoutShipmentInput, TransporterInvoiceUncheckedCreateWithoutShipmentInput> | TransporterInvoiceCreateWithoutShipmentInput[] | TransporterInvoiceUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: TransporterInvoiceCreateOrConnectWithoutShipmentInput | TransporterInvoiceCreateOrConnectWithoutShipmentInput[]
    createMany?: TransporterInvoiceCreateManyShipmentInputEnvelope
    connect?: TransporterInvoiceWhereUniqueInput | TransporterInvoiceWhereUniqueInput[]
  }

  export type StatusHistoryUncheckedCreateNestedManyWithoutShipmentInput = {
    create?: XOR<StatusHistoryCreateWithoutShipmentInput, StatusHistoryUncheckedCreateWithoutShipmentInput> | StatusHistoryCreateWithoutShipmentInput[] | StatusHistoryUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: StatusHistoryCreateOrConnectWithoutShipmentInput | StatusHistoryCreateOrConnectWithoutShipmentInput[]
    createMany?: StatusHistoryCreateManyShipmentInputEnvelope
    connect?: StatusHistoryWhereUniqueInput | StatusHistoryWhereUniqueInput[]
  }

  export type ComplianceDocumentUncheckedCreateNestedManyWithoutShipmentInput = {
    create?: XOR<ComplianceDocumentCreateWithoutShipmentInput, ComplianceDocumentUncheckedCreateWithoutShipmentInput> | ComplianceDocumentCreateWithoutShipmentInput[] | ComplianceDocumentUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: ComplianceDocumentCreateOrConnectWithoutShipmentInput | ComplianceDocumentCreateOrConnectWithoutShipmentInput[]
    createMany?: ComplianceDocumentCreateManyShipmentInputEnvelope
    connect?: ComplianceDocumentWhereUniqueInput | ComplianceDocumentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutShipmentInput = {
    create?: XOR<PaymentCreateWithoutShipmentInput, PaymentUncheckedCreateWithoutShipmentInput> | PaymentCreateWithoutShipmentInput[] | PaymentUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutShipmentInput | PaymentCreateOrConnectWithoutShipmentInput[]
    createMany?: PaymentCreateManyShipmentInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedOneWithoutShipmentInput = {
    create?: XOR<InvoiceCreateWithoutShipmentInput, InvoiceUncheckedCreateWithoutShipmentInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutShipmentInput
    connect?: InvoiceWhereUniqueInput
  }

  export type ConsentLogUncheckedCreateNestedManyWithoutShipmentInput = {
    create?: XOR<ConsentLogCreateWithoutShipmentInput, ConsentLogUncheckedCreateWithoutShipmentInput> | ConsentLogCreateWithoutShipmentInput[] | ConsentLogUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: ConsentLogCreateOrConnectWithoutShipmentInput | ConsentLogCreateOrConnectWithoutShipmentInput[]
    createMany?: ConsentLogCreateManyShipmentInputEnvelope
    connect?: ConsentLogWhereUniqueInput | ConsentLogWhereUniqueInput[]
  }

  export type TransporterInvoiceUncheckedCreateNestedManyWithoutShipmentInput = {
    create?: XOR<TransporterInvoiceCreateWithoutShipmentInput, TransporterInvoiceUncheckedCreateWithoutShipmentInput> | TransporterInvoiceCreateWithoutShipmentInput[] | TransporterInvoiceUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: TransporterInvoiceCreateOrConnectWithoutShipmentInput | TransporterInvoiceCreateOrConnectWithoutShipmentInput[]
    createMany?: TransporterInvoiceCreateManyShipmentInputEnvelope
    connect?: TransporterInvoiceWhereUniqueInput | TransporterInvoiceWhereUniqueInput[]
  }

  export type EnumShipmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.ShipmentStatus
  }

  export type NullableEnumBookingStatusFieldUpdateOperationsInput = {
    set?: $Enums.BookingStatus | null
  }

  export type NullableEnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus | null
  }

  export type EnumComplianceStatusFieldUpdateOperationsInput = {
    set?: $Enums.ComplianceStatus
  }

  export type UserUpdateOneRequiredWithoutShipmentsNestedInput = {
    create?: XOR<UserCreateWithoutShipmentsInput, UserUncheckedCreateWithoutShipmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutShipmentsInput
    upsert?: UserUpsertWithoutShipmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutShipmentsInput, UserUpdateWithoutShipmentsInput>, UserUncheckedUpdateWithoutShipmentsInput>
  }

  export type CompanyUpdateOneWithoutShipmentsNestedInput = {
    create?: XOR<CompanyCreateWithoutShipmentsInput, CompanyUncheckedCreateWithoutShipmentsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutShipmentsInput
    upsert?: CompanyUpsertWithoutShipmentsInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutShipmentsInput, CompanyUpdateWithoutShipmentsInput>, CompanyUncheckedUpdateWithoutShipmentsInput>
  }

  export type QuoteRequestUpdateOneWithoutShipmentNestedInput = {
    create?: XOR<QuoteRequestCreateWithoutShipmentInput, QuoteRequestUncheckedCreateWithoutShipmentInput>
    connectOrCreate?: QuoteRequestCreateOrConnectWithoutShipmentInput
    upsert?: QuoteRequestUpsertWithoutShipmentInput
    disconnect?: QuoteRequestWhereInput | boolean
    delete?: QuoteRequestWhereInput | boolean
    connect?: QuoteRequestWhereUniqueInput
    update?: XOR<XOR<QuoteRequestUpdateToOneWithWhereWithoutShipmentInput, QuoteRequestUpdateWithoutShipmentInput>, QuoteRequestUncheckedUpdateWithoutShipmentInput>
  }

  export type QuoteResponseUpdateOneWithoutShipmentNestedInput = {
    create?: XOR<QuoteResponseCreateWithoutShipmentInput, QuoteResponseUncheckedCreateWithoutShipmentInput>
    connectOrCreate?: QuoteResponseCreateOrConnectWithoutShipmentInput
    upsert?: QuoteResponseUpsertWithoutShipmentInput
    disconnect?: QuoteResponseWhereInput | boolean
    delete?: QuoteResponseWhereInput | boolean
    connect?: QuoteResponseWhereUniqueInput
    update?: XOR<XOR<QuoteResponseUpdateToOneWithWhereWithoutShipmentInput, QuoteResponseUpdateWithoutShipmentInput>, QuoteResponseUncheckedUpdateWithoutShipmentInput>
  }

  export type RateCardUpdateOneWithoutShipmentsNestedInput = {
    create?: XOR<RateCardCreateWithoutShipmentsInput, RateCardUncheckedCreateWithoutShipmentsInput>
    connectOrCreate?: RateCardCreateOrConnectWithoutShipmentsInput
    upsert?: RateCardUpsertWithoutShipmentsInput
    disconnect?: RateCardWhereInput | boolean
    delete?: RateCardWhereInput | boolean
    connect?: RateCardWhereUniqueInput
    update?: XOR<XOR<RateCardUpdateToOneWithWhereWithoutShipmentsInput, RateCardUpdateWithoutShipmentsInput>, RateCardUncheckedUpdateWithoutShipmentsInput>
  }

  export type VendorUpdateOneWithoutShipmentsNestedInput = {
    create?: XOR<VendorCreateWithoutShipmentsInput, VendorUncheckedCreateWithoutShipmentsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutShipmentsInput
    upsert?: VendorUpsertWithoutShipmentsInput
    disconnect?: VendorWhereInput | boolean
    delete?: VendorWhereInput | boolean
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutShipmentsInput, VendorUpdateWithoutShipmentsInput>, VendorUncheckedUpdateWithoutShipmentsInput>
  }

  export type UserUpdateOneWithoutAssignedShipmentsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedShipmentsInput, UserUncheckedCreateWithoutAssignedShipmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedShipmentsInput
    upsert?: UserUpsertWithoutAssignedShipmentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedShipmentsInput, UserUpdateWithoutAssignedShipmentsInput>, UserUncheckedUpdateWithoutAssignedShipmentsInput>
  }

  export type StatusHistoryUpdateManyWithoutShipmentNestedInput = {
    create?: XOR<StatusHistoryCreateWithoutShipmentInput, StatusHistoryUncheckedCreateWithoutShipmentInput> | StatusHistoryCreateWithoutShipmentInput[] | StatusHistoryUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: StatusHistoryCreateOrConnectWithoutShipmentInput | StatusHistoryCreateOrConnectWithoutShipmentInput[]
    upsert?: StatusHistoryUpsertWithWhereUniqueWithoutShipmentInput | StatusHistoryUpsertWithWhereUniqueWithoutShipmentInput[]
    createMany?: StatusHistoryCreateManyShipmentInputEnvelope
    set?: StatusHistoryWhereUniqueInput | StatusHistoryWhereUniqueInput[]
    disconnect?: StatusHistoryWhereUniqueInput | StatusHistoryWhereUniqueInput[]
    delete?: StatusHistoryWhereUniqueInput | StatusHistoryWhereUniqueInput[]
    connect?: StatusHistoryWhereUniqueInput | StatusHistoryWhereUniqueInput[]
    update?: StatusHistoryUpdateWithWhereUniqueWithoutShipmentInput | StatusHistoryUpdateWithWhereUniqueWithoutShipmentInput[]
    updateMany?: StatusHistoryUpdateManyWithWhereWithoutShipmentInput | StatusHistoryUpdateManyWithWhereWithoutShipmentInput[]
    deleteMany?: StatusHistoryScalarWhereInput | StatusHistoryScalarWhereInput[]
  }

  export type ComplianceDocumentUpdateManyWithoutShipmentNestedInput = {
    create?: XOR<ComplianceDocumentCreateWithoutShipmentInput, ComplianceDocumentUncheckedCreateWithoutShipmentInput> | ComplianceDocumentCreateWithoutShipmentInput[] | ComplianceDocumentUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: ComplianceDocumentCreateOrConnectWithoutShipmentInput | ComplianceDocumentCreateOrConnectWithoutShipmentInput[]
    upsert?: ComplianceDocumentUpsertWithWhereUniqueWithoutShipmentInput | ComplianceDocumentUpsertWithWhereUniqueWithoutShipmentInput[]
    createMany?: ComplianceDocumentCreateManyShipmentInputEnvelope
    set?: ComplianceDocumentWhereUniqueInput | ComplianceDocumentWhereUniqueInput[]
    disconnect?: ComplianceDocumentWhereUniqueInput | ComplianceDocumentWhereUniqueInput[]
    delete?: ComplianceDocumentWhereUniqueInput | ComplianceDocumentWhereUniqueInput[]
    connect?: ComplianceDocumentWhereUniqueInput | ComplianceDocumentWhereUniqueInput[]
    update?: ComplianceDocumentUpdateWithWhereUniqueWithoutShipmentInput | ComplianceDocumentUpdateWithWhereUniqueWithoutShipmentInput[]
    updateMany?: ComplianceDocumentUpdateManyWithWhereWithoutShipmentInput | ComplianceDocumentUpdateManyWithWhereWithoutShipmentInput[]
    deleteMany?: ComplianceDocumentScalarWhereInput | ComplianceDocumentScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutShipmentNestedInput = {
    create?: XOR<PaymentCreateWithoutShipmentInput, PaymentUncheckedCreateWithoutShipmentInput> | PaymentCreateWithoutShipmentInput[] | PaymentUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutShipmentInput | PaymentCreateOrConnectWithoutShipmentInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutShipmentInput | PaymentUpsertWithWhereUniqueWithoutShipmentInput[]
    createMany?: PaymentCreateManyShipmentInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutShipmentInput | PaymentUpdateWithWhereUniqueWithoutShipmentInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutShipmentInput | PaymentUpdateManyWithWhereWithoutShipmentInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type InvoiceUpdateOneWithoutShipmentNestedInput = {
    create?: XOR<InvoiceCreateWithoutShipmentInput, InvoiceUncheckedCreateWithoutShipmentInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutShipmentInput
    upsert?: InvoiceUpsertWithoutShipmentInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutShipmentInput, InvoiceUpdateWithoutShipmentInput>, InvoiceUncheckedUpdateWithoutShipmentInput>
  }

  export type ConsentLogUpdateManyWithoutShipmentNestedInput = {
    create?: XOR<ConsentLogCreateWithoutShipmentInput, ConsentLogUncheckedCreateWithoutShipmentInput> | ConsentLogCreateWithoutShipmentInput[] | ConsentLogUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: ConsentLogCreateOrConnectWithoutShipmentInput | ConsentLogCreateOrConnectWithoutShipmentInput[]
    upsert?: ConsentLogUpsertWithWhereUniqueWithoutShipmentInput | ConsentLogUpsertWithWhereUniqueWithoutShipmentInput[]
    createMany?: ConsentLogCreateManyShipmentInputEnvelope
    set?: ConsentLogWhereUniqueInput | ConsentLogWhereUniqueInput[]
    disconnect?: ConsentLogWhereUniqueInput | ConsentLogWhereUniqueInput[]
    delete?: ConsentLogWhereUniqueInput | ConsentLogWhereUniqueInput[]
    connect?: ConsentLogWhereUniqueInput | ConsentLogWhereUniqueInput[]
    update?: ConsentLogUpdateWithWhereUniqueWithoutShipmentInput | ConsentLogUpdateWithWhereUniqueWithoutShipmentInput[]
    updateMany?: ConsentLogUpdateManyWithWhereWithoutShipmentInput | ConsentLogUpdateManyWithWhereWithoutShipmentInput[]
    deleteMany?: ConsentLogScalarWhereInput | ConsentLogScalarWhereInput[]
  }

  export type TransporterInvoiceUpdateManyWithoutShipmentNestedInput = {
    create?: XOR<TransporterInvoiceCreateWithoutShipmentInput, TransporterInvoiceUncheckedCreateWithoutShipmentInput> | TransporterInvoiceCreateWithoutShipmentInput[] | TransporterInvoiceUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: TransporterInvoiceCreateOrConnectWithoutShipmentInput | TransporterInvoiceCreateOrConnectWithoutShipmentInput[]
    upsert?: TransporterInvoiceUpsertWithWhereUniqueWithoutShipmentInput | TransporterInvoiceUpsertWithWhereUniqueWithoutShipmentInput[]
    createMany?: TransporterInvoiceCreateManyShipmentInputEnvelope
    set?: TransporterInvoiceWhereUniqueInput | TransporterInvoiceWhereUniqueInput[]
    disconnect?: TransporterInvoiceWhereUniqueInput | TransporterInvoiceWhereUniqueInput[]
    delete?: TransporterInvoiceWhereUniqueInput | TransporterInvoiceWhereUniqueInput[]
    connect?: TransporterInvoiceWhereUniqueInput | TransporterInvoiceWhereUniqueInput[]
    update?: TransporterInvoiceUpdateWithWhereUniqueWithoutShipmentInput | TransporterInvoiceUpdateWithWhereUniqueWithoutShipmentInput[]
    updateMany?: TransporterInvoiceUpdateManyWithWhereWithoutShipmentInput | TransporterInvoiceUpdateManyWithWhereWithoutShipmentInput[]
    deleteMany?: TransporterInvoiceScalarWhereInput | TransporterInvoiceScalarWhereInput[]
  }

  export type StatusHistoryUncheckedUpdateManyWithoutShipmentNestedInput = {
    create?: XOR<StatusHistoryCreateWithoutShipmentInput, StatusHistoryUncheckedCreateWithoutShipmentInput> | StatusHistoryCreateWithoutShipmentInput[] | StatusHistoryUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: StatusHistoryCreateOrConnectWithoutShipmentInput | StatusHistoryCreateOrConnectWithoutShipmentInput[]
    upsert?: StatusHistoryUpsertWithWhereUniqueWithoutShipmentInput | StatusHistoryUpsertWithWhereUniqueWithoutShipmentInput[]
    createMany?: StatusHistoryCreateManyShipmentInputEnvelope
    set?: StatusHistoryWhereUniqueInput | StatusHistoryWhereUniqueInput[]
    disconnect?: StatusHistoryWhereUniqueInput | StatusHistoryWhereUniqueInput[]
    delete?: StatusHistoryWhereUniqueInput | StatusHistoryWhereUniqueInput[]
    connect?: StatusHistoryWhereUniqueInput | StatusHistoryWhereUniqueInput[]
    update?: StatusHistoryUpdateWithWhereUniqueWithoutShipmentInput | StatusHistoryUpdateWithWhereUniqueWithoutShipmentInput[]
    updateMany?: StatusHistoryUpdateManyWithWhereWithoutShipmentInput | StatusHistoryUpdateManyWithWhereWithoutShipmentInput[]
    deleteMany?: StatusHistoryScalarWhereInput | StatusHistoryScalarWhereInput[]
  }

  export type ComplianceDocumentUncheckedUpdateManyWithoutShipmentNestedInput = {
    create?: XOR<ComplianceDocumentCreateWithoutShipmentInput, ComplianceDocumentUncheckedCreateWithoutShipmentInput> | ComplianceDocumentCreateWithoutShipmentInput[] | ComplianceDocumentUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: ComplianceDocumentCreateOrConnectWithoutShipmentInput | ComplianceDocumentCreateOrConnectWithoutShipmentInput[]
    upsert?: ComplianceDocumentUpsertWithWhereUniqueWithoutShipmentInput | ComplianceDocumentUpsertWithWhereUniqueWithoutShipmentInput[]
    createMany?: ComplianceDocumentCreateManyShipmentInputEnvelope
    set?: ComplianceDocumentWhereUniqueInput | ComplianceDocumentWhereUniqueInput[]
    disconnect?: ComplianceDocumentWhereUniqueInput | ComplianceDocumentWhereUniqueInput[]
    delete?: ComplianceDocumentWhereUniqueInput | ComplianceDocumentWhereUniqueInput[]
    connect?: ComplianceDocumentWhereUniqueInput | ComplianceDocumentWhereUniqueInput[]
    update?: ComplianceDocumentUpdateWithWhereUniqueWithoutShipmentInput | ComplianceDocumentUpdateWithWhereUniqueWithoutShipmentInput[]
    updateMany?: ComplianceDocumentUpdateManyWithWhereWithoutShipmentInput | ComplianceDocumentUpdateManyWithWhereWithoutShipmentInput[]
    deleteMany?: ComplianceDocumentScalarWhereInput | ComplianceDocumentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutShipmentNestedInput = {
    create?: XOR<PaymentCreateWithoutShipmentInput, PaymentUncheckedCreateWithoutShipmentInput> | PaymentCreateWithoutShipmentInput[] | PaymentUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutShipmentInput | PaymentCreateOrConnectWithoutShipmentInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutShipmentInput | PaymentUpsertWithWhereUniqueWithoutShipmentInput[]
    createMany?: PaymentCreateManyShipmentInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutShipmentInput | PaymentUpdateWithWhereUniqueWithoutShipmentInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutShipmentInput | PaymentUpdateManyWithWhereWithoutShipmentInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateOneWithoutShipmentNestedInput = {
    create?: XOR<InvoiceCreateWithoutShipmentInput, InvoiceUncheckedCreateWithoutShipmentInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutShipmentInput
    upsert?: InvoiceUpsertWithoutShipmentInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutShipmentInput, InvoiceUpdateWithoutShipmentInput>, InvoiceUncheckedUpdateWithoutShipmentInput>
  }

  export type ConsentLogUncheckedUpdateManyWithoutShipmentNestedInput = {
    create?: XOR<ConsentLogCreateWithoutShipmentInput, ConsentLogUncheckedCreateWithoutShipmentInput> | ConsentLogCreateWithoutShipmentInput[] | ConsentLogUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: ConsentLogCreateOrConnectWithoutShipmentInput | ConsentLogCreateOrConnectWithoutShipmentInput[]
    upsert?: ConsentLogUpsertWithWhereUniqueWithoutShipmentInput | ConsentLogUpsertWithWhereUniqueWithoutShipmentInput[]
    createMany?: ConsentLogCreateManyShipmentInputEnvelope
    set?: ConsentLogWhereUniqueInput | ConsentLogWhereUniqueInput[]
    disconnect?: ConsentLogWhereUniqueInput | ConsentLogWhereUniqueInput[]
    delete?: ConsentLogWhereUniqueInput | ConsentLogWhereUniqueInput[]
    connect?: ConsentLogWhereUniqueInput | ConsentLogWhereUniqueInput[]
    update?: ConsentLogUpdateWithWhereUniqueWithoutShipmentInput | ConsentLogUpdateWithWhereUniqueWithoutShipmentInput[]
    updateMany?: ConsentLogUpdateManyWithWhereWithoutShipmentInput | ConsentLogUpdateManyWithWhereWithoutShipmentInput[]
    deleteMany?: ConsentLogScalarWhereInput | ConsentLogScalarWhereInput[]
  }

  export type TransporterInvoiceUncheckedUpdateManyWithoutShipmentNestedInput = {
    create?: XOR<TransporterInvoiceCreateWithoutShipmentInput, TransporterInvoiceUncheckedCreateWithoutShipmentInput> | TransporterInvoiceCreateWithoutShipmentInput[] | TransporterInvoiceUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: TransporterInvoiceCreateOrConnectWithoutShipmentInput | TransporterInvoiceCreateOrConnectWithoutShipmentInput[]
    upsert?: TransporterInvoiceUpsertWithWhereUniqueWithoutShipmentInput | TransporterInvoiceUpsertWithWhereUniqueWithoutShipmentInput[]
    createMany?: TransporterInvoiceCreateManyShipmentInputEnvelope
    set?: TransporterInvoiceWhereUniqueInput | TransporterInvoiceWhereUniqueInput[]
    disconnect?: TransporterInvoiceWhereUniqueInput | TransporterInvoiceWhereUniqueInput[]
    delete?: TransporterInvoiceWhereUniqueInput | TransporterInvoiceWhereUniqueInput[]
    connect?: TransporterInvoiceWhereUniqueInput | TransporterInvoiceWhereUniqueInput[]
    update?: TransporterInvoiceUpdateWithWhereUniqueWithoutShipmentInput | TransporterInvoiceUpdateWithWhereUniqueWithoutShipmentInput[]
    updateMany?: TransporterInvoiceUpdateManyWithWhereWithoutShipmentInput | TransporterInvoiceUpdateManyWithWhereWithoutShipmentInput[]
    deleteMany?: TransporterInvoiceScalarWhereInput | TransporterInvoiceScalarWhereInput[]
  }

  export type ShipmentCreateNestedOneWithoutStatusHistoryInput = {
    create?: XOR<ShipmentCreateWithoutStatusHistoryInput, ShipmentUncheckedCreateWithoutStatusHistoryInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutStatusHistoryInput
    connect?: ShipmentWhereUniqueInput
  }

  export type ShipmentUpdateOneRequiredWithoutStatusHistoryNestedInput = {
    create?: XOR<ShipmentCreateWithoutStatusHistoryInput, ShipmentUncheckedCreateWithoutStatusHistoryInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutStatusHistoryInput
    upsert?: ShipmentUpsertWithoutStatusHistoryInput
    connect?: ShipmentWhereUniqueInput
    update?: XOR<XOR<ShipmentUpdateToOneWithWhereWithoutStatusHistoryInput, ShipmentUpdateWithoutStatusHistoryInput>, ShipmentUncheckedUpdateWithoutStatusHistoryInput>
  }

  export type ShipmentCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<ShipmentCreateWithoutInvoiceInput, ShipmentUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutInvoiceInput
    connect?: ShipmentWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<CompanyCreateWithoutInvoicesInput, CompanyUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutInvoicesInput
    connect?: CompanyWhereUniqueInput
  }

  export type PaymentUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type EnumInvoiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceStatus
  }

  export type ShipmentUpdateOneRequiredWithoutInvoiceNestedInput = {
    create?: XOR<ShipmentCreateWithoutInvoiceInput, ShipmentUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutInvoiceInput
    upsert?: ShipmentUpsertWithoutInvoiceInput
    connect?: ShipmentWhereUniqueInput
    update?: XOR<XOR<ShipmentUpdateToOneWithWhereWithoutInvoiceInput, ShipmentUpdateWithoutInvoiceInput>, ShipmentUncheckedUpdateWithoutInvoiceInput>
  }

  export type PaymentUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type CompanyUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<CompanyCreateWithoutInvoicesInput, CompanyUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutInvoicesInput
    upsert?: CompanyUpsertWithoutInvoicesInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutInvoicesInput, CompanyUpdateWithoutInvoicesInput>, CompanyUncheckedUpdateWithoutInvoicesInput>
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ShipmentCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<ShipmentCreateWithoutPaymentsInput, ShipmentUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutPaymentsInput
    connect?: ShipmentWhereUniqueInput
  }

  export type InvoiceCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type PaymentEventCreateNestedManyWithoutPaymentInput = {
    create?: XOR<PaymentEventCreateWithoutPaymentInput, PaymentEventUncheckedCreateWithoutPaymentInput> | PaymentEventCreateWithoutPaymentInput[] | PaymentEventUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: PaymentEventCreateOrConnectWithoutPaymentInput | PaymentEventCreateOrConnectWithoutPaymentInput[]
    createMany?: PaymentEventCreateManyPaymentInputEnvelope
    connect?: PaymentEventWhereUniqueInput | PaymentEventWhereUniqueInput[]
  }

  export type PaymentEventUncheckedCreateNestedManyWithoutPaymentInput = {
    create?: XOR<PaymentEventCreateWithoutPaymentInput, PaymentEventUncheckedCreateWithoutPaymentInput> | PaymentEventCreateWithoutPaymentInput[] | PaymentEventUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: PaymentEventCreateOrConnectWithoutPaymentInput | PaymentEventCreateOrConnectWithoutPaymentInput[]
    createMany?: PaymentEventCreateManyPaymentInputEnvelope
    connect?: PaymentEventWhereUniqueInput | PaymentEventWhereUniqueInput[]
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type ShipmentUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<ShipmentCreateWithoutPaymentsInput, ShipmentUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutPaymentsInput
    upsert?: ShipmentUpsertWithoutPaymentsInput
    connect?: ShipmentWhereUniqueInput
    update?: XOR<XOR<ShipmentUpdateToOneWithWhereWithoutPaymentsInput, ShipmentUpdateWithoutPaymentsInput>, ShipmentUncheckedUpdateWithoutPaymentsInput>
  }

  export type InvoiceUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    upsert?: InvoiceUpsertWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutPaymentsInput, InvoiceUpdateWithoutPaymentsInput>, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type PaymentEventUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<PaymentEventCreateWithoutPaymentInput, PaymentEventUncheckedCreateWithoutPaymentInput> | PaymentEventCreateWithoutPaymentInput[] | PaymentEventUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: PaymentEventCreateOrConnectWithoutPaymentInput | PaymentEventCreateOrConnectWithoutPaymentInput[]
    upsert?: PaymentEventUpsertWithWhereUniqueWithoutPaymentInput | PaymentEventUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: PaymentEventCreateManyPaymentInputEnvelope
    set?: PaymentEventWhereUniqueInput | PaymentEventWhereUniqueInput[]
    disconnect?: PaymentEventWhereUniqueInput | PaymentEventWhereUniqueInput[]
    delete?: PaymentEventWhereUniqueInput | PaymentEventWhereUniqueInput[]
    connect?: PaymentEventWhereUniqueInput | PaymentEventWhereUniqueInput[]
    update?: PaymentEventUpdateWithWhereUniqueWithoutPaymentInput | PaymentEventUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: PaymentEventUpdateManyWithWhereWithoutPaymentInput | PaymentEventUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: PaymentEventScalarWhereInput | PaymentEventScalarWhereInput[]
  }

  export type PaymentEventUncheckedUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<PaymentEventCreateWithoutPaymentInput, PaymentEventUncheckedCreateWithoutPaymentInput> | PaymentEventCreateWithoutPaymentInput[] | PaymentEventUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: PaymentEventCreateOrConnectWithoutPaymentInput | PaymentEventCreateOrConnectWithoutPaymentInput[]
    upsert?: PaymentEventUpsertWithWhereUniqueWithoutPaymentInput | PaymentEventUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: PaymentEventCreateManyPaymentInputEnvelope
    set?: PaymentEventWhereUniqueInput | PaymentEventWhereUniqueInput[]
    disconnect?: PaymentEventWhereUniqueInput | PaymentEventWhereUniqueInput[]
    delete?: PaymentEventWhereUniqueInput | PaymentEventWhereUniqueInput[]
    connect?: PaymentEventWhereUniqueInput | PaymentEventWhereUniqueInput[]
    update?: PaymentEventUpdateWithWhereUniqueWithoutPaymentInput | PaymentEventUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: PaymentEventUpdateManyWithWhereWithoutPaymentInput | PaymentEventUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: PaymentEventScalarWhereInput | PaymentEventScalarWhereInput[]
  }

  export type PaymentCreateNestedOneWithoutEventsInput = {
    create?: XOR<PaymentCreateWithoutEventsInput, PaymentUncheckedCreateWithoutEventsInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutEventsInput
    connect?: PaymentWhereUniqueInput
  }

  export type PaymentUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<PaymentCreateWithoutEventsInput, PaymentUncheckedCreateWithoutEventsInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutEventsInput
    upsert?: PaymentUpsertWithoutEventsInput
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutEventsInput, PaymentUpdateWithoutEventsInput>, PaymentUncheckedUpdateWithoutEventsInput>
  }

  export type CompanyCreateNestedOneWithoutTransporterInvoicesInput = {
    create?: XOR<CompanyCreateWithoutTransporterInvoicesInput, CompanyUncheckedCreateWithoutTransporterInvoicesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutTransporterInvoicesInput
    connect?: CompanyWhereUniqueInput
  }

  export type ShipmentCreateNestedOneWithoutTransporterInvoicesInput = {
    create?: XOR<ShipmentCreateWithoutTransporterInvoicesInput, ShipmentUncheckedCreateWithoutTransporterInvoicesInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutTransporterInvoicesInput
    connect?: ShipmentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTransporterInvoicesInput = {
    create?: XOR<UserCreateWithoutTransporterInvoicesInput, UserUncheckedCreateWithoutTransporterInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransporterInvoicesInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutTransporterInvoicesNestedInput = {
    create?: XOR<CompanyCreateWithoutTransporterInvoicesInput, CompanyUncheckedCreateWithoutTransporterInvoicesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutTransporterInvoicesInput
    upsert?: CompanyUpsertWithoutTransporterInvoicesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutTransporterInvoicesInput, CompanyUpdateWithoutTransporterInvoicesInput>, CompanyUncheckedUpdateWithoutTransporterInvoicesInput>
  }

  export type ShipmentUpdateOneRequiredWithoutTransporterInvoicesNestedInput = {
    create?: XOR<ShipmentCreateWithoutTransporterInvoicesInput, ShipmentUncheckedCreateWithoutTransporterInvoicesInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutTransporterInvoicesInput
    upsert?: ShipmentUpsertWithoutTransporterInvoicesInput
    connect?: ShipmentWhereUniqueInput
    update?: XOR<XOR<ShipmentUpdateToOneWithWhereWithoutTransporterInvoicesInput, ShipmentUpdateWithoutTransporterInvoicesInput>, ShipmentUncheckedUpdateWithoutTransporterInvoicesInput>
  }

  export type UserUpdateOneWithoutTransporterInvoicesNestedInput = {
    create?: XOR<UserCreateWithoutTransporterInvoicesInput, UserUncheckedCreateWithoutTransporterInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransporterInvoicesInput
    upsert?: UserUpsertWithoutTransporterInvoicesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransporterInvoicesInput, UserUpdateWithoutTransporterInvoicesInput>, UserUncheckedUpdateWithoutTransporterInvoicesInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type ShipmentCreateNestedOneWithoutComplianceDocsInput = {
    create?: XOR<ShipmentCreateWithoutComplianceDocsInput, ShipmentUncheckedCreateWithoutComplianceDocsInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutComplianceDocsInput
    connect?: ShipmentWhereUniqueInput
  }

  export type ComplianceEventCreateNestedManyWithoutDocumentInput = {
    create?: XOR<ComplianceEventCreateWithoutDocumentInput, ComplianceEventUncheckedCreateWithoutDocumentInput> | ComplianceEventCreateWithoutDocumentInput[] | ComplianceEventUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: ComplianceEventCreateOrConnectWithoutDocumentInput | ComplianceEventCreateOrConnectWithoutDocumentInput[]
    createMany?: ComplianceEventCreateManyDocumentInputEnvelope
    connect?: ComplianceEventWhereUniqueInput | ComplianceEventWhereUniqueInput[]
  }

  export type ComplianceEventUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<ComplianceEventCreateWithoutDocumentInput, ComplianceEventUncheckedCreateWithoutDocumentInput> | ComplianceEventCreateWithoutDocumentInput[] | ComplianceEventUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: ComplianceEventCreateOrConnectWithoutDocumentInput | ComplianceEventCreateOrConnectWithoutDocumentInput[]
    createMany?: ComplianceEventCreateManyDocumentInputEnvelope
    connect?: ComplianceEventWhereUniqueInput | ComplianceEventWhereUniqueInput[]
  }

  export type EnumDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocumentType
  }

  export type ShipmentUpdateOneRequiredWithoutComplianceDocsNestedInput = {
    create?: XOR<ShipmentCreateWithoutComplianceDocsInput, ShipmentUncheckedCreateWithoutComplianceDocsInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutComplianceDocsInput
    upsert?: ShipmentUpsertWithoutComplianceDocsInput
    connect?: ShipmentWhereUniqueInput
    update?: XOR<XOR<ShipmentUpdateToOneWithWhereWithoutComplianceDocsInput, ShipmentUpdateWithoutComplianceDocsInput>, ShipmentUncheckedUpdateWithoutComplianceDocsInput>
  }

  export type ComplianceEventUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<ComplianceEventCreateWithoutDocumentInput, ComplianceEventUncheckedCreateWithoutDocumentInput> | ComplianceEventCreateWithoutDocumentInput[] | ComplianceEventUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: ComplianceEventCreateOrConnectWithoutDocumentInput | ComplianceEventCreateOrConnectWithoutDocumentInput[]
    upsert?: ComplianceEventUpsertWithWhereUniqueWithoutDocumentInput | ComplianceEventUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: ComplianceEventCreateManyDocumentInputEnvelope
    set?: ComplianceEventWhereUniqueInput | ComplianceEventWhereUniqueInput[]
    disconnect?: ComplianceEventWhereUniqueInput | ComplianceEventWhereUniqueInput[]
    delete?: ComplianceEventWhereUniqueInput | ComplianceEventWhereUniqueInput[]
    connect?: ComplianceEventWhereUniqueInput | ComplianceEventWhereUniqueInput[]
    update?: ComplianceEventUpdateWithWhereUniqueWithoutDocumentInput | ComplianceEventUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: ComplianceEventUpdateManyWithWhereWithoutDocumentInput | ComplianceEventUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: ComplianceEventScalarWhereInput | ComplianceEventScalarWhereInput[]
  }

  export type ComplianceEventUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<ComplianceEventCreateWithoutDocumentInput, ComplianceEventUncheckedCreateWithoutDocumentInput> | ComplianceEventCreateWithoutDocumentInput[] | ComplianceEventUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: ComplianceEventCreateOrConnectWithoutDocumentInput | ComplianceEventCreateOrConnectWithoutDocumentInput[]
    upsert?: ComplianceEventUpsertWithWhereUniqueWithoutDocumentInput | ComplianceEventUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: ComplianceEventCreateManyDocumentInputEnvelope
    set?: ComplianceEventWhereUniqueInput | ComplianceEventWhereUniqueInput[]
    disconnect?: ComplianceEventWhereUniqueInput | ComplianceEventWhereUniqueInput[]
    delete?: ComplianceEventWhereUniqueInput | ComplianceEventWhereUniqueInput[]
    connect?: ComplianceEventWhereUniqueInput | ComplianceEventWhereUniqueInput[]
    update?: ComplianceEventUpdateWithWhereUniqueWithoutDocumentInput | ComplianceEventUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: ComplianceEventUpdateManyWithWhereWithoutDocumentInput | ComplianceEventUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: ComplianceEventScalarWhereInput | ComplianceEventScalarWhereInput[]
  }

  export type ComplianceDocumentCreateNestedOneWithoutEventsInput = {
    create?: XOR<ComplianceDocumentCreateWithoutEventsInput, ComplianceDocumentUncheckedCreateWithoutEventsInput>
    connectOrCreate?: ComplianceDocumentCreateOrConnectWithoutEventsInput
    connect?: ComplianceDocumentWhereUniqueInput
  }

  export type ComplianceDocumentUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<ComplianceDocumentCreateWithoutEventsInput, ComplianceDocumentUncheckedCreateWithoutEventsInput>
    connectOrCreate?: ComplianceDocumentCreateOrConnectWithoutEventsInput
    upsert?: ComplianceDocumentUpsertWithoutEventsInput
    connect?: ComplianceDocumentWhereUniqueInput
    update?: XOR<XOR<ComplianceDocumentUpdateToOneWithWhereWithoutEventsInput, ComplianceDocumentUpdateWithoutEventsInput>, ComplianceDocumentUncheckedUpdateWithoutEventsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumApprovalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusFilter<$PrismaModel> | $Enums.ApprovalStatus
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApprovalStatusFilter<$PrismaModel>
    _max?: NestedEnumApprovalStatusFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumConsentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsentStatus | EnumConsentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConsentStatus[] | ListEnumConsentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsentStatus[] | ListEnumConsentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConsentStatusFilter<$PrismaModel> | $Enums.ConsentStatus
  }

  export type NestedEnumConsentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsentStatus | EnumConsentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConsentStatus[] | ListEnumConsentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsentStatus[] | ListEnumConsentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConsentStatusWithAggregatesFilter<$PrismaModel> | $Enums.ConsentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConsentStatusFilter<$PrismaModel>
    _max?: NestedEnumConsentStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumQuoteStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QuoteStatus | EnumQuoteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuoteStatusFilter<$PrismaModel> | $Enums.QuoteStatus
  }

  export type NestedEnumQuoteStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuoteStatus | EnumQuoteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuoteStatusWithAggregatesFilter<$PrismaModel> | $Enums.QuoteStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuoteStatusFilter<$PrismaModel>
    _max?: NestedEnumQuoteStatusFilter<$PrismaModel>
  }

  export type NestedEnumQuoteResponseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QuoteResponseStatus | EnumQuoteResponseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuoteResponseStatus[] | ListEnumQuoteResponseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuoteResponseStatus[] | ListEnumQuoteResponseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuoteResponseStatusFilter<$PrismaModel> | $Enums.QuoteResponseStatus
  }

  export type NestedEnumQuoteResponseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuoteResponseStatus | EnumQuoteResponseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuoteResponseStatus[] | ListEnumQuoteResponseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuoteResponseStatus[] | ListEnumQuoteResponseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuoteResponseStatusWithAggregatesFilter<$PrismaModel> | $Enums.QuoteResponseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuoteResponseStatusFilter<$PrismaModel>
    _max?: NestedEnumQuoteResponseStatusFilter<$PrismaModel>
  }

  export type NestedEnumShipmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ShipmentStatus | EnumShipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShipmentStatus[] | ListEnumShipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShipmentStatus[] | ListEnumShipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShipmentStatusFilter<$PrismaModel> | $Enums.ShipmentStatus
  }

  export type NestedEnumBookingStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBookingStatusNullableFilter<$PrismaModel> | $Enums.BookingStatus | null
  }

  export type NestedEnumPaymentStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentStatusNullableFilter<$PrismaModel> | $Enums.PaymentStatus | null
  }

  export type NestedEnumComplianceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplianceStatus | EnumComplianceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplianceStatus[] | ListEnumComplianceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplianceStatus[] | ListEnumComplianceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumComplianceStatusFilter<$PrismaModel> | $Enums.ComplianceStatus
  }

  export type NestedEnumShipmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShipmentStatus | EnumShipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShipmentStatus[] | ListEnumShipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShipmentStatus[] | ListEnumShipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShipmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.ShipmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShipmentStatusFilter<$PrismaModel>
    _max?: NestedEnumShipmentStatusFilter<$PrismaModel>
  }

  export type NestedEnumBookingStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBookingStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumComplianceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplianceStatus | EnumComplianceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplianceStatus[] | ListEnumComplianceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplianceStatus[] | ListEnumComplianceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumComplianceStatusWithAggregatesFilter<$PrismaModel> | $Enums.ComplianceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComplianceStatusFilter<$PrismaModel>
    _max?: NestedEnumComplianceStatusFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type UserCreateWithoutCompanyInput = {
    email: string
    passwordHash: string
    name?: string | null
    phone?: string | null
    role?: $Enums.Role
    approvalStatus?: $Enums.ApprovalStatus
    approvalNote?: string | null
    rejectionReason?: string | null
    reviewedById?: number | null
    reviewedAt?: Date | string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorChannel?: string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor?: VendorCreateNestedOneWithoutUserInput
    shipments?: ShipmentCreateNestedManyWithoutUserInput
    assignedShipments?: ShipmentCreateNestedManyWithoutAssignedToInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    agreementsReviewed?: AgreementCreateNestedManyWithoutReviewedByInput
    transporterInvoices?: TransporterInvoiceCreateNestedManyWithoutApprovedByInput
    QuoteRequest?: QuoteRequestCreateNestedManyWithoutCreatedByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    twoFactorChallenges?: TwoFactorChallengeCreateNestedManyWithoutUserInput
    userConsents?: UserConsentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCompanyInput = {
    id?: number
    email: string
    passwordHash: string
    name?: string | null
    phone?: string | null
    role?: $Enums.Role
    approvalStatus?: $Enums.ApprovalStatus
    approvalNote?: string | null
    rejectionReason?: string | null
    reviewedById?: number | null
    reviewedAt?: Date | string | null
    isActive?: boolean
    vendorId?: number | null
    lastLoginAt?: Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorChannel?: string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    shipments?: ShipmentUncheckedCreateNestedManyWithoutUserInput
    assignedShipments?: ShipmentUncheckedCreateNestedManyWithoutAssignedToInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    agreementsReviewed?: AgreementUncheckedCreateNestedManyWithoutReviewedByInput
    transporterInvoices?: TransporterInvoiceUncheckedCreateNestedManyWithoutApprovedByInput
    QuoteRequest?: QuoteRequestUncheckedCreateNestedManyWithoutCreatedByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    twoFactorChallenges?: TwoFactorChallengeUncheckedCreateNestedManyWithoutUserInput
    userConsents?: UserConsentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCompanyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput>
  }

  export type UserCreateManyCompanyInputEnvelope = {
    data: UserCreateManyCompanyInput | UserCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ShipmentCreateWithoutCompanyInput = {
    agreementId?: number | null
    trackingNumber?: string | null
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.ShipmentStatus
    bookingStatus?: $Enums.BookingStatus | null
    paymentStatus?: $Enums.PaymentStatus | null
    cost?: number | null
    distance?: number | null
    estimatedDelivery?: Date | string | null
    pickupTime?: Date | string | null
    deliveryTime?: Date | string | null
    assignedDriver?: string | null
    driverPhone?: string | null
    driverEta?: Date | string | null
    transporterResponseNotes?: string | null
    notes?: string | null
    ewayBillNumber?: string | null
    gstInvoiceId?: number | null
    complianceStatus?: $Enums.ComplianceStatus
    source?: string
    podStatus?: string
    podUrl?: string | null
    podNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutShipmentsInput
    quoteRequest?: QuoteRequestCreateNestedOneWithoutShipmentInput
    transporterQuote?: QuoteResponseCreateNestedOneWithoutShipmentInput
    rateCard?: RateCardCreateNestedOneWithoutShipmentsInput
    vendor?: VendorCreateNestedOneWithoutShipmentsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedShipmentsInput
    statusHistory?: StatusHistoryCreateNestedManyWithoutShipmentInput
    complianceDocs?: ComplianceDocumentCreateNestedManyWithoutShipmentInput
    payments?: PaymentCreateNestedManyWithoutShipmentInput
    invoice?: InvoiceCreateNestedOneWithoutShipmentInput
    consentLogs?: ConsentLogCreateNestedManyWithoutShipmentInput
    transporterInvoices?: TransporterInvoiceCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentUncheckedCreateWithoutCompanyInput = {
    id?: number
    userId: number
    quoteRequestId?: number | null
    transporterQuoteId?: number | null
    selectedVendorId?: number | null
    agreementId?: number | null
    rateCardId?: number | null
    trackingNumber?: string | null
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.ShipmentStatus
    bookingStatus?: $Enums.BookingStatus | null
    paymentStatus?: $Enums.PaymentStatus | null
    cost?: number | null
    distance?: number | null
    estimatedDelivery?: Date | string | null
    pickupTime?: Date | string | null
    deliveryTime?: Date | string | null
    assignedToId?: number | null
    assignedDriver?: string | null
    driverPhone?: string | null
    driverEta?: Date | string | null
    transporterResponseNotes?: string | null
    notes?: string | null
    ewayBillNumber?: string | null
    gstInvoiceId?: number | null
    complianceStatus?: $Enums.ComplianceStatus
    source?: string
    podStatus?: string
    podUrl?: string | null
    podNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    statusHistory?: StatusHistoryUncheckedCreateNestedManyWithoutShipmentInput
    complianceDocs?: ComplianceDocumentUncheckedCreateNestedManyWithoutShipmentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutShipmentInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutShipmentInput
    consentLogs?: ConsentLogUncheckedCreateNestedManyWithoutShipmentInput
    transporterInvoices?: TransporterInvoiceUncheckedCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentCreateOrConnectWithoutCompanyInput = {
    where: ShipmentWhereUniqueInput
    create: XOR<ShipmentCreateWithoutCompanyInput, ShipmentUncheckedCreateWithoutCompanyInput>
  }

  export type ShipmentCreateManyCompanyInputEnvelope = {
    data: ShipmentCreateManyCompanyInput | ShipmentCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type AgreementCreateWithoutCompanyInput = {
    title: string
    referenceCode: string
    status?: string
    effectiveFrom?: Date | string | null
    effectiveTo?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutAgreementsInput
    reviewedBy?: UserCreateNestedOneWithoutAgreementsReviewedInput
    rateCards?: RateCardCreateNestedManyWithoutAgreementInput
  }

  export type AgreementUncheckedCreateWithoutCompanyInput = {
    id?: number
    vendorId: number
    title: string
    referenceCode: string
    status?: string
    effectiveFrom?: Date | string | null
    effectiveTo?: Date | string | null
    notes?: string | null
    reviewedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rateCards?: RateCardUncheckedCreateNestedManyWithoutAgreementInput
  }

  export type AgreementCreateOrConnectWithoutCompanyInput = {
    where: AgreementWhereUniqueInput
    create: XOR<AgreementCreateWithoutCompanyInput, AgreementUncheckedCreateWithoutCompanyInput>
  }

  export type AgreementCreateManyCompanyInputEnvelope = {
    data: AgreementCreateManyCompanyInput | AgreementCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type TransporterInvoiceCreateWithoutCompanyInput = {
    invoiceNumber: string
    invoiceDate: Date | string
    invoiceAmount: number
    invoiceUrl: string
    approvalStatus?: string
    rejectionNotes?: string | null
    postedToErpAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shipment: ShipmentCreateNestedOneWithoutTransporterInvoicesInput
    approvedBy?: UserCreateNestedOneWithoutTransporterInvoicesInput
  }

  export type TransporterInvoiceUncheckedCreateWithoutCompanyInput = {
    id?: number
    shipmentId: number
    invoiceNumber: string
    invoiceDate: Date | string
    invoiceAmount: number
    invoiceUrl: string
    approvalStatus?: string
    rejectionNotes?: string | null
    postedToErpAt?: Date | string | null
    approvedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransporterInvoiceCreateOrConnectWithoutCompanyInput = {
    where: TransporterInvoiceWhereUniqueInput
    create: XOR<TransporterInvoiceCreateWithoutCompanyInput, TransporterInvoiceUncheckedCreateWithoutCompanyInput>
  }

  export type TransporterInvoiceCreateManyCompanyInputEnvelope = {
    data: TransporterInvoiceCreateManyCompanyInput | TransporterInvoiceCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutCompanyInput = {
    invoiceNumber: string
    status?: $Enums.InvoiceStatus
    issuedAt?: Date | string | null
    dueDate?: Date | string | null
    subtotal?: number
    taxTotal?: number
    grandTotal?: number
    lineItems: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    shipment: ShipmentCreateNestedOneWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutCompanyInput = {
    id?: number
    shipmentId: number
    invoiceNumber: string
    status?: $Enums.InvoiceStatus
    issuedAt?: Date | string | null
    dueDate?: Date | string | null
    subtotal?: number
    taxTotal?: number
    grandTotal?: number
    lineItems: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutCompanyInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutCompanyInput, InvoiceUncheckedCreateWithoutCompanyInput>
  }

  export type InvoiceCreateManyCompanyInputEnvelope = {
    data: InvoiceCreateManyCompanyInput | InvoiceCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CompanyProfileCreateWithoutCompanyInput = {
    legalName?: string | null
    gstin?: string | null
    pan?: string | null
    tan?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyProfileUncheckedCreateWithoutCompanyInput = {
    id?: number
    legalName?: string | null
    gstin?: string | null
    pan?: string | null
    tan?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyProfileCreateOrConnectWithoutCompanyInput = {
    where: CompanyProfileWhereUniqueInput
    create: XOR<CompanyProfileCreateWithoutCompanyInput, CompanyProfileUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyProfileCreateManyCompanyInputEnvelope = {
    data: CompanyProfileCreateManyCompanyInput | CompanyProfileCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type VendorCreateWithoutCompanyInput = {
    name: string
    email?: string | null
    phone?: string | null
    baseRate?: number | null
    rating?: number | null
    speed?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: VendorProfileCreateNestedOneWithoutVendorInput
    agreements?: AgreementCreateNestedManyWithoutVendorInput
    rateCards?: RateCardCreateNestedManyWithoutVendorInput
    quoteResponses?: QuoteResponseCreateNestedManyWithoutVendorInput
    shipments?: ShipmentCreateNestedManyWithoutVendorInput
    drivers?: DriverCreateNestedManyWithoutVendorInput
    User?: UserCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutCompanyInput = {
    id?: number
    name: string
    email?: string | null
    phone?: string | null
    baseRate?: number | null
    rating?: number | null
    speed?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: VendorProfileUncheckedCreateNestedOneWithoutVendorInput
    agreements?: AgreementUncheckedCreateNestedManyWithoutVendorInput
    rateCards?: RateCardUncheckedCreateNestedManyWithoutVendorInput
    quoteResponses?: QuoteResponseUncheckedCreateNestedManyWithoutVendorInput
    shipments?: ShipmentUncheckedCreateNestedManyWithoutVendorInput
    drivers?: DriverUncheckedCreateNestedManyWithoutVendorInput
    User?: UserUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutCompanyInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutCompanyInput, VendorUncheckedCreateWithoutCompanyInput>
  }

  export type VendorCreateManyCompanyInputEnvelope = {
    data: VendorCreateManyCompanyInput | VendorCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutCompanyInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCompanyInput, UserUncheckedUpdateWithoutCompanyInput>
    create: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCompanyInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCompanyInput, UserUncheckedUpdateWithoutCompanyInput>
  }

  export type UserUpdateManyWithWhereWithoutCompanyInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCompanyInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    approvalStatus?: EnumApprovalStatusFilter<"User"> | $Enums.ApprovalStatus
    approvalNote?: StringNullableFilter<"User"> | string | null
    rejectionReason?: StringNullableFilter<"User"> | string | null
    reviewedById?: IntNullableFilter<"User"> | number | null
    reviewedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isActive?: BoolFilter<"User"> | boolean
    vendorId?: IntNullableFilter<"User"> | number | null
    companyId?: IntNullableFilter<"User"> | number | null
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    notificationPreferences?: JsonNullableFilter<"User">
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorChannel?: StringNullableFilter<"User"> | string | null
    allowedIpRanges?: JsonNullableFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type ShipmentUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ShipmentWhereUniqueInput
    update: XOR<ShipmentUpdateWithoutCompanyInput, ShipmentUncheckedUpdateWithoutCompanyInput>
    create: XOR<ShipmentCreateWithoutCompanyInput, ShipmentUncheckedCreateWithoutCompanyInput>
  }

  export type ShipmentUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ShipmentWhereUniqueInput
    data: XOR<ShipmentUpdateWithoutCompanyInput, ShipmentUncheckedUpdateWithoutCompanyInput>
  }

  export type ShipmentUpdateManyWithWhereWithoutCompanyInput = {
    where: ShipmentScalarWhereInput
    data: XOR<ShipmentUpdateManyMutationInput, ShipmentUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ShipmentScalarWhereInput = {
    AND?: ShipmentScalarWhereInput | ShipmentScalarWhereInput[]
    OR?: ShipmentScalarWhereInput[]
    NOT?: ShipmentScalarWhereInput | ShipmentScalarWhereInput[]
    id?: IntFilter<"Shipment"> | number
    userId?: IntFilter<"Shipment"> | number
    companyId?: IntNullableFilter<"Shipment"> | number | null
    quoteRequestId?: IntNullableFilter<"Shipment"> | number | null
    transporterQuoteId?: IntNullableFilter<"Shipment"> | number | null
    selectedVendorId?: IntNullableFilter<"Shipment"> | number | null
    agreementId?: IntNullableFilter<"Shipment"> | number | null
    rateCardId?: IntNullableFilter<"Shipment"> | number | null
    trackingNumber?: StringNullableFilter<"Shipment"> | string | null
    fromLocation?: StringFilter<"Shipment"> | string
    toLocation?: StringFilter<"Shipment"> | string
    fromLat?: FloatNullableFilter<"Shipment"> | number | null
    fromLng?: FloatNullableFilter<"Shipment"> | number | null
    toLat?: FloatNullableFilter<"Shipment"> | number | null
    toLng?: FloatNullableFilter<"Shipment"> | number | null
    weight?: FloatNullableFilter<"Shipment"> | number | null
    shipmentType?: StringNullableFilter<"Shipment"> | string | null
    urgency?: StringNullableFilter<"Shipment"> | string | null
    status?: EnumShipmentStatusFilter<"Shipment"> | $Enums.ShipmentStatus
    bookingStatus?: EnumBookingStatusNullableFilter<"Shipment"> | $Enums.BookingStatus | null
    paymentStatus?: EnumPaymentStatusNullableFilter<"Shipment"> | $Enums.PaymentStatus | null
    cost?: FloatNullableFilter<"Shipment"> | number | null
    distance?: FloatNullableFilter<"Shipment"> | number | null
    estimatedDelivery?: DateTimeNullableFilter<"Shipment"> | Date | string | null
    pickupTime?: DateTimeNullableFilter<"Shipment"> | Date | string | null
    deliveryTime?: DateTimeNullableFilter<"Shipment"> | Date | string | null
    assignedToId?: IntNullableFilter<"Shipment"> | number | null
    assignedDriver?: StringNullableFilter<"Shipment"> | string | null
    driverPhone?: StringNullableFilter<"Shipment"> | string | null
    driverEta?: DateTimeNullableFilter<"Shipment"> | Date | string | null
    transporterResponseNotes?: StringNullableFilter<"Shipment"> | string | null
    notes?: StringNullableFilter<"Shipment"> | string | null
    ewayBillNumber?: StringNullableFilter<"Shipment"> | string | null
    gstInvoiceId?: IntNullableFilter<"Shipment"> | number | null
    complianceStatus?: EnumComplianceStatusFilter<"Shipment"> | $Enums.ComplianceStatus
    source?: StringFilter<"Shipment"> | string
    podStatus?: StringFilter<"Shipment"> | string
    podUrl?: StringNullableFilter<"Shipment"> | string | null
    podNotes?: StringNullableFilter<"Shipment"> | string | null
    createdAt?: DateTimeFilter<"Shipment"> | Date | string
    updatedAt?: DateTimeFilter<"Shipment"> | Date | string
  }

  export type AgreementUpsertWithWhereUniqueWithoutCompanyInput = {
    where: AgreementWhereUniqueInput
    update: XOR<AgreementUpdateWithoutCompanyInput, AgreementUncheckedUpdateWithoutCompanyInput>
    create: XOR<AgreementCreateWithoutCompanyInput, AgreementUncheckedCreateWithoutCompanyInput>
  }

  export type AgreementUpdateWithWhereUniqueWithoutCompanyInput = {
    where: AgreementWhereUniqueInput
    data: XOR<AgreementUpdateWithoutCompanyInput, AgreementUncheckedUpdateWithoutCompanyInput>
  }

  export type AgreementUpdateManyWithWhereWithoutCompanyInput = {
    where: AgreementScalarWhereInput
    data: XOR<AgreementUpdateManyMutationInput, AgreementUncheckedUpdateManyWithoutCompanyInput>
  }

  export type AgreementScalarWhereInput = {
    AND?: AgreementScalarWhereInput | AgreementScalarWhereInput[]
    OR?: AgreementScalarWhereInput[]
    NOT?: AgreementScalarWhereInput | AgreementScalarWhereInput[]
    id?: IntFilter<"Agreement"> | number
    vendorId?: IntFilter<"Agreement"> | number
    title?: StringFilter<"Agreement"> | string
    referenceCode?: StringFilter<"Agreement"> | string
    status?: StringFilter<"Agreement"> | string
    effectiveFrom?: DateTimeNullableFilter<"Agreement"> | Date | string | null
    effectiveTo?: DateTimeNullableFilter<"Agreement"> | Date | string | null
    notes?: StringNullableFilter<"Agreement"> | string | null
    reviewedById?: IntNullableFilter<"Agreement"> | number | null
    createdAt?: DateTimeFilter<"Agreement"> | Date | string
    updatedAt?: DateTimeFilter<"Agreement"> | Date | string
    companyId?: IntNullableFilter<"Agreement"> | number | null
  }

  export type TransporterInvoiceUpsertWithWhereUniqueWithoutCompanyInput = {
    where: TransporterInvoiceWhereUniqueInput
    update: XOR<TransporterInvoiceUpdateWithoutCompanyInput, TransporterInvoiceUncheckedUpdateWithoutCompanyInput>
    create: XOR<TransporterInvoiceCreateWithoutCompanyInput, TransporterInvoiceUncheckedCreateWithoutCompanyInput>
  }

  export type TransporterInvoiceUpdateWithWhereUniqueWithoutCompanyInput = {
    where: TransporterInvoiceWhereUniqueInput
    data: XOR<TransporterInvoiceUpdateWithoutCompanyInput, TransporterInvoiceUncheckedUpdateWithoutCompanyInput>
  }

  export type TransporterInvoiceUpdateManyWithWhereWithoutCompanyInput = {
    where: TransporterInvoiceScalarWhereInput
    data: XOR<TransporterInvoiceUpdateManyMutationInput, TransporterInvoiceUncheckedUpdateManyWithoutCompanyInput>
  }

  export type TransporterInvoiceScalarWhereInput = {
    AND?: TransporterInvoiceScalarWhereInput | TransporterInvoiceScalarWhereInput[]
    OR?: TransporterInvoiceScalarWhereInput[]
    NOT?: TransporterInvoiceScalarWhereInput | TransporterInvoiceScalarWhereInput[]
    id?: IntFilter<"TransporterInvoice"> | number
    companyId?: IntFilter<"TransporterInvoice"> | number
    shipmentId?: IntFilter<"TransporterInvoice"> | number
    invoiceNumber?: StringFilter<"TransporterInvoice"> | string
    invoiceDate?: DateTimeFilter<"TransporterInvoice"> | Date | string
    invoiceAmount?: FloatFilter<"TransporterInvoice"> | number
    invoiceUrl?: StringFilter<"TransporterInvoice"> | string
    approvalStatus?: StringFilter<"TransporterInvoice"> | string
    rejectionNotes?: StringNullableFilter<"TransporterInvoice"> | string | null
    postedToErpAt?: DateTimeNullableFilter<"TransporterInvoice"> | Date | string | null
    approvedById?: IntNullableFilter<"TransporterInvoice"> | number | null
    createdAt?: DateTimeFilter<"TransporterInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"TransporterInvoice"> | Date | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutCompanyInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutCompanyInput, InvoiceUncheckedUpdateWithoutCompanyInput>
    create: XOR<InvoiceCreateWithoutCompanyInput, InvoiceUncheckedCreateWithoutCompanyInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutCompanyInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutCompanyInput, InvoiceUncheckedUpdateWithoutCompanyInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutCompanyInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutCompanyInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: IntFilter<"Invoice"> | number
    shipmentId?: IntFilter<"Invoice"> | number
    invoiceNumber?: StringFilter<"Invoice"> | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    issuedAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    subtotal?: FloatFilter<"Invoice"> | number
    taxTotal?: FloatFilter<"Invoice"> | number
    grandTotal?: FloatFilter<"Invoice"> | number
    lineItems?: JsonFilter<"Invoice">
    metadata?: JsonNullableFilter<"Invoice">
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    companyId?: IntNullableFilter<"Invoice"> | number | null
  }

  export type CompanyProfileUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CompanyProfileWhereUniqueInput
    update: XOR<CompanyProfileUpdateWithoutCompanyInput, CompanyProfileUncheckedUpdateWithoutCompanyInput>
    create: XOR<CompanyProfileCreateWithoutCompanyInput, CompanyProfileUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyProfileUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CompanyProfileWhereUniqueInput
    data: XOR<CompanyProfileUpdateWithoutCompanyInput, CompanyProfileUncheckedUpdateWithoutCompanyInput>
  }

  export type CompanyProfileUpdateManyWithWhereWithoutCompanyInput = {
    where: CompanyProfileScalarWhereInput
    data: XOR<CompanyProfileUpdateManyMutationInput, CompanyProfileUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CompanyProfileScalarWhereInput = {
    AND?: CompanyProfileScalarWhereInput | CompanyProfileScalarWhereInput[]
    OR?: CompanyProfileScalarWhereInput[]
    NOT?: CompanyProfileScalarWhereInput | CompanyProfileScalarWhereInput[]
    id?: IntFilter<"CompanyProfile"> | number
    companyId?: IntNullableFilter<"CompanyProfile"> | number | null
    legalName?: StringNullableFilter<"CompanyProfile"> | string | null
    gstin?: StringNullableFilter<"CompanyProfile"> | string | null
    pan?: StringNullableFilter<"CompanyProfile"> | string | null
    tan?: StringNullableFilter<"CompanyProfile"> | string | null
    addressLine1?: StringNullableFilter<"CompanyProfile"> | string | null
    addressLine2?: StringNullableFilter<"CompanyProfile"> | string | null
    city?: StringNullableFilter<"CompanyProfile"> | string | null
    state?: StringNullableFilter<"CompanyProfile"> | string | null
    postalCode?: StringNullableFilter<"CompanyProfile"> | string | null
    country?: StringNullableFilter<"CompanyProfile"> | string | null
    createdAt?: DateTimeFilter<"CompanyProfile"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyProfile"> | Date | string
  }

  export type VendorUpsertWithWhereUniqueWithoutCompanyInput = {
    where: VendorWhereUniqueInput
    update: XOR<VendorUpdateWithoutCompanyInput, VendorUncheckedUpdateWithoutCompanyInput>
    create: XOR<VendorCreateWithoutCompanyInput, VendorUncheckedCreateWithoutCompanyInput>
  }

  export type VendorUpdateWithWhereUniqueWithoutCompanyInput = {
    where: VendorWhereUniqueInput
    data: XOR<VendorUpdateWithoutCompanyInput, VendorUncheckedUpdateWithoutCompanyInput>
  }

  export type VendorUpdateManyWithWhereWithoutCompanyInput = {
    where: VendorScalarWhereInput
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyWithoutCompanyInput>
  }

  export type VendorScalarWhereInput = {
    AND?: VendorScalarWhereInput | VendorScalarWhereInput[]
    OR?: VendorScalarWhereInput[]
    NOT?: VendorScalarWhereInput | VendorScalarWhereInput[]
    id?: IntFilter<"Vendor"> | number
    name?: StringFilter<"Vendor"> | string
    email?: StringNullableFilter<"Vendor"> | string | null
    phone?: StringNullableFilter<"Vendor"> | string | null
    baseRate?: FloatNullableFilter<"Vendor"> | number | null
    rating?: FloatNullableFilter<"Vendor"> | number | null
    speed?: FloatNullableFilter<"Vendor"> | number | null
    isActive?: BoolFilter<"Vendor"> | boolean
    companyId?: IntNullableFilter<"Vendor"> | number | null
    createdAt?: DateTimeFilter<"Vendor"> | Date | string
    updatedAt?: DateTimeFilter<"Vendor"> | Date | string
  }

  export type CompanyCreateWithoutProfilesInput = {
    name: string
    webhookSecret: string
    plan?: string
    subscriptionStatus?: string
    billingEmail?: string | null
    billingCustomerId?: string | null
    trialEndsAt?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    shipments?: ShipmentCreateNestedManyWithoutCompanyInput
    agreements?: AgreementCreateNestedManyWithoutCompanyInput
    transporterInvoices?: TransporterInvoiceCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutProfilesInput = {
    id?: number
    name: string
    webhookSecret: string
    plan?: string
    subscriptionStatus?: string
    billingEmail?: string | null
    billingCustomerId?: string | null
    trialEndsAt?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    shipments?: ShipmentUncheckedCreateNestedManyWithoutCompanyInput
    agreements?: AgreementUncheckedCreateNestedManyWithoutCompanyInput
    transporterInvoices?: TransporterInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutProfilesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutProfilesInput, CompanyUncheckedCreateWithoutProfilesInput>
  }

  export type CompanyUpsertWithoutProfilesInput = {
    update: XOR<CompanyUpdateWithoutProfilesInput, CompanyUncheckedUpdateWithoutProfilesInput>
    create: XOR<CompanyCreateWithoutProfilesInput, CompanyUncheckedCreateWithoutProfilesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutProfilesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutProfilesInput, CompanyUncheckedUpdateWithoutProfilesInput>
  }

  export type CompanyUpdateWithoutProfilesInput = {
    name?: StringFieldUpdateOperationsInput | string
    webhookSecret?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    billingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    billingCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    shipments?: ShipmentUpdateManyWithoutCompanyNestedInput
    agreements?: AgreementUpdateManyWithoutCompanyNestedInput
    transporterInvoices?: TransporterInvoiceUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutProfilesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    webhookSecret?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    billingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    billingCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    shipments?: ShipmentUncheckedUpdateManyWithoutCompanyNestedInput
    agreements?: AgreementUncheckedUpdateManyWithoutCompanyNestedInput
    transporterInvoices?: TransporterInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutUsersInput = {
    name: string
    webhookSecret: string
    plan?: string
    subscriptionStatus?: string
    billingEmail?: string | null
    billingCustomerId?: string | null
    trialEndsAt?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    shipments?: ShipmentCreateNestedManyWithoutCompanyInput
    agreements?: AgreementCreateNestedManyWithoutCompanyInput
    transporterInvoices?: TransporterInvoiceCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    profiles?: CompanyProfileCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    webhookSecret: string
    plan?: string
    subscriptionStatus?: string
    billingEmail?: string | null
    billingCustomerId?: string | null
    trialEndsAt?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    shipments?: ShipmentUncheckedCreateNestedManyWithoutCompanyInput
    agreements?: AgreementUncheckedCreateNestedManyWithoutCompanyInput
    transporterInvoices?: TransporterInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    profiles?: CompanyProfileUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutUsersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
  }

  export type VendorCreateWithoutUserInput = {
    name: string
    email?: string | null
    phone?: string | null
    baseRate?: number | null
    rating?: number | null
    speed?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutVendorsInput
    profile?: VendorProfileCreateNestedOneWithoutVendorInput
    agreements?: AgreementCreateNestedManyWithoutVendorInput
    rateCards?: RateCardCreateNestedManyWithoutVendorInput
    quoteResponses?: QuoteResponseCreateNestedManyWithoutVendorInput
    shipments?: ShipmentCreateNestedManyWithoutVendorInput
    drivers?: DriverCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    email?: string | null
    phone?: string | null
    baseRate?: number | null
    rating?: number | null
    speed?: number | null
    isActive?: boolean
    companyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: VendorProfileUncheckedCreateNestedOneWithoutVendorInput
    agreements?: AgreementUncheckedCreateNestedManyWithoutVendorInput
    rateCards?: RateCardUncheckedCreateNestedManyWithoutVendorInput
    quoteResponses?: QuoteResponseUncheckedCreateNestedManyWithoutVendorInput
    shipments?: ShipmentUncheckedCreateNestedManyWithoutVendorInput
    drivers?: DriverUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutUserInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutUserInput, VendorUncheckedCreateWithoutUserInput>
  }

  export type ShipmentCreateWithoutUserInput = {
    agreementId?: number | null
    trackingNumber?: string | null
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.ShipmentStatus
    bookingStatus?: $Enums.BookingStatus | null
    paymentStatus?: $Enums.PaymentStatus | null
    cost?: number | null
    distance?: number | null
    estimatedDelivery?: Date | string | null
    pickupTime?: Date | string | null
    deliveryTime?: Date | string | null
    assignedDriver?: string | null
    driverPhone?: string | null
    driverEta?: Date | string | null
    transporterResponseNotes?: string | null
    notes?: string | null
    ewayBillNumber?: string | null
    gstInvoiceId?: number | null
    complianceStatus?: $Enums.ComplianceStatus
    source?: string
    podStatus?: string
    podUrl?: string | null
    podNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutShipmentsInput
    quoteRequest?: QuoteRequestCreateNestedOneWithoutShipmentInput
    transporterQuote?: QuoteResponseCreateNestedOneWithoutShipmentInput
    rateCard?: RateCardCreateNestedOneWithoutShipmentsInput
    vendor?: VendorCreateNestedOneWithoutShipmentsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedShipmentsInput
    statusHistory?: StatusHistoryCreateNestedManyWithoutShipmentInput
    complianceDocs?: ComplianceDocumentCreateNestedManyWithoutShipmentInput
    payments?: PaymentCreateNestedManyWithoutShipmentInput
    invoice?: InvoiceCreateNestedOneWithoutShipmentInput
    consentLogs?: ConsentLogCreateNestedManyWithoutShipmentInput
    transporterInvoices?: TransporterInvoiceCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentUncheckedCreateWithoutUserInput = {
    id?: number
    companyId?: number | null
    quoteRequestId?: number | null
    transporterQuoteId?: number | null
    selectedVendorId?: number | null
    agreementId?: number | null
    rateCardId?: number | null
    trackingNumber?: string | null
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.ShipmentStatus
    bookingStatus?: $Enums.BookingStatus | null
    paymentStatus?: $Enums.PaymentStatus | null
    cost?: number | null
    distance?: number | null
    estimatedDelivery?: Date | string | null
    pickupTime?: Date | string | null
    deliveryTime?: Date | string | null
    assignedToId?: number | null
    assignedDriver?: string | null
    driverPhone?: string | null
    driverEta?: Date | string | null
    transporterResponseNotes?: string | null
    notes?: string | null
    ewayBillNumber?: string | null
    gstInvoiceId?: number | null
    complianceStatus?: $Enums.ComplianceStatus
    source?: string
    podStatus?: string
    podUrl?: string | null
    podNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    statusHistory?: StatusHistoryUncheckedCreateNestedManyWithoutShipmentInput
    complianceDocs?: ComplianceDocumentUncheckedCreateNestedManyWithoutShipmentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutShipmentInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutShipmentInput
    consentLogs?: ConsentLogUncheckedCreateNestedManyWithoutShipmentInput
    transporterInvoices?: TransporterInvoiceUncheckedCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentCreateOrConnectWithoutUserInput = {
    where: ShipmentWhereUniqueInput
    create: XOR<ShipmentCreateWithoutUserInput, ShipmentUncheckedCreateWithoutUserInput>
  }

  export type ShipmentCreateManyUserInputEnvelope = {
    data: ShipmentCreateManyUserInput | ShipmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ShipmentCreateWithoutAssignedToInput = {
    agreementId?: number | null
    trackingNumber?: string | null
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.ShipmentStatus
    bookingStatus?: $Enums.BookingStatus | null
    paymentStatus?: $Enums.PaymentStatus | null
    cost?: number | null
    distance?: number | null
    estimatedDelivery?: Date | string | null
    pickupTime?: Date | string | null
    deliveryTime?: Date | string | null
    assignedDriver?: string | null
    driverPhone?: string | null
    driverEta?: Date | string | null
    transporterResponseNotes?: string | null
    notes?: string | null
    ewayBillNumber?: string | null
    gstInvoiceId?: number | null
    complianceStatus?: $Enums.ComplianceStatus
    source?: string
    podStatus?: string
    podUrl?: string | null
    podNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutShipmentsInput
    company?: CompanyCreateNestedOneWithoutShipmentsInput
    quoteRequest?: QuoteRequestCreateNestedOneWithoutShipmentInput
    transporterQuote?: QuoteResponseCreateNestedOneWithoutShipmentInput
    rateCard?: RateCardCreateNestedOneWithoutShipmentsInput
    vendor?: VendorCreateNestedOneWithoutShipmentsInput
    statusHistory?: StatusHistoryCreateNestedManyWithoutShipmentInput
    complianceDocs?: ComplianceDocumentCreateNestedManyWithoutShipmentInput
    payments?: PaymentCreateNestedManyWithoutShipmentInput
    invoice?: InvoiceCreateNestedOneWithoutShipmentInput
    consentLogs?: ConsentLogCreateNestedManyWithoutShipmentInput
    transporterInvoices?: TransporterInvoiceCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentUncheckedCreateWithoutAssignedToInput = {
    id?: number
    userId: number
    companyId?: number | null
    quoteRequestId?: number | null
    transporterQuoteId?: number | null
    selectedVendorId?: number | null
    agreementId?: number | null
    rateCardId?: number | null
    trackingNumber?: string | null
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.ShipmentStatus
    bookingStatus?: $Enums.BookingStatus | null
    paymentStatus?: $Enums.PaymentStatus | null
    cost?: number | null
    distance?: number | null
    estimatedDelivery?: Date | string | null
    pickupTime?: Date | string | null
    deliveryTime?: Date | string | null
    assignedDriver?: string | null
    driverPhone?: string | null
    driverEta?: Date | string | null
    transporterResponseNotes?: string | null
    notes?: string | null
    ewayBillNumber?: string | null
    gstInvoiceId?: number | null
    complianceStatus?: $Enums.ComplianceStatus
    source?: string
    podStatus?: string
    podUrl?: string | null
    podNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    statusHistory?: StatusHistoryUncheckedCreateNestedManyWithoutShipmentInput
    complianceDocs?: ComplianceDocumentUncheckedCreateNestedManyWithoutShipmentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutShipmentInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutShipmentInput
    consentLogs?: ConsentLogUncheckedCreateNestedManyWithoutShipmentInput
    transporterInvoices?: TransporterInvoiceUncheckedCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentCreateOrConnectWithoutAssignedToInput = {
    where: ShipmentWhereUniqueInput
    create: XOR<ShipmentCreateWithoutAssignedToInput, ShipmentUncheckedCreateWithoutAssignedToInput>
  }

  export type ShipmentCreateManyAssignedToInputEnvelope = {
    data: ShipmentCreateManyAssignedToInput | ShipmentCreateManyAssignedToInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    title: string
    message: string
    type: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: number
    title: string
    message: string
    type: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    action: string
    entityType: string
    entityId?: number | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: number
    action: string
    entityType: string
    entityId?: number | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AgreementCreateWithoutReviewedByInput = {
    title: string
    referenceCode: string
    status?: string
    effectiveFrom?: Date | string | null
    effectiveTo?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutAgreementsInput
    rateCards?: RateCardCreateNestedManyWithoutAgreementInput
    Company?: CompanyCreateNestedOneWithoutAgreementsInput
  }

  export type AgreementUncheckedCreateWithoutReviewedByInput = {
    id?: number
    vendorId: number
    title: string
    referenceCode: string
    status?: string
    effectiveFrom?: Date | string | null
    effectiveTo?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: number | null
    rateCards?: RateCardUncheckedCreateNestedManyWithoutAgreementInput
  }

  export type AgreementCreateOrConnectWithoutReviewedByInput = {
    where: AgreementWhereUniqueInput
    create: XOR<AgreementCreateWithoutReviewedByInput, AgreementUncheckedCreateWithoutReviewedByInput>
  }

  export type AgreementCreateManyReviewedByInputEnvelope = {
    data: AgreementCreateManyReviewedByInput | AgreementCreateManyReviewedByInput[]
    skipDuplicates?: boolean
  }

  export type TransporterInvoiceCreateWithoutApprovedByInput = {
    invoiceNumber: string
    invoiceDate: Date | string
    invoiceAmount: number
    invoiceUrl: string
    approvalStatus?: string
    rejectionNotes?: string | null
    postedToErpAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutTransporterInvoicesInput
    shipment: ShipmentCreateNestedOneWithoutTransporterInvoicesInput
  }

  export type TransporterInvoiceUncheckedCreateWithoutApprovedByInput = {
    id?: number
    companyId: number
    shipmentId: number
    invoiceNumber: string
    invoiceDate: Date | string
    invoiceAmount: number
    invoiceUrl: string
    approvalStatus?: string
    rejectionNotes?: string | null
    postedToErpAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransporterInvoiceCreateOrConnectWithoutApprovedByInput = {
    where: TransporterInvoiceWhereUniqueInput
    create: XOR<TransporterInvoiceCreateWithoutApprovedByInput, TransporterInvoiceUncheckedCreateWithoutApprovedByInput>
  }

  export type TransporterInvoiceCreateManyApprovedByInputEnvelope = {
    data: TransporterInvoiceCreateManyApprovedByInput | TransporterInvoiceCreateManyApprovedByInput[]
    skipDuplicates?: boolean
  }

  export type QuoteRequestCreateWithoutCreatedByInput = {
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.QuoteStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: QuoteResponseCreateNestedManyWithoutQuoteRequestInput
    approvedResponse?: QuoteResponseCreateNestedOneWithoutApprovedForInput
    shipment?: ShipmentCreateNestedOneWithoutQuoteRequestInput
  }

  export type QuoteRequestUncheckedCreateWithoutCreatedByInput = {
    id?: number
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.QuoteStatus
    notes?: string | null
    approvedResponseId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: QuoteResponseUncheckedCreateNestedManyWithoutQuoteRequestInput
    shipment?: ShipmentUncheckedCreateNestedOneWithoutQuoteRequestInput
  }

  export type QuoteRequestCreateOrConnectWithoutCreatedByInput = {
    where: QuoteRequestWhereUniqueInput
    create: XOR<QuoteRequestCreateWithoutCreatedByInput, QuoteRequestUncheckedCreateWithoutCreatedByInput>
  }

  export type QuoteRequestCreateManyCreatedByInputEnvelope = {
    data: QuoteRequestCreateManyCreatedByInput | QuoteRequestCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type PasswordResetTokenCreateWithoutUserInput = {
    tokenHash: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
  }

  export type PasswordResetTokenUncheckedCreateWithoutUserInput = {
    id?: number
    tokenHash: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
  }

  export type PasswordResetTokenCreateOrConnectWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenCreateManyUserInputEnvelope = {
    data: PasswordResetTokenCreateManyUserInput | PasswordResetTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TwoFactorChallengeCreateWithoutUserInput = {
    codeHash: string
    expiresAt: Date | string
    consumed?: boolean
    createdAt?: Date | string
  }

  export type TwoFactorChallengeUncheckedCreateWithoutUserInput = {
    id?: number
    codeHash: string
    expiresAt: Date | string
    consumed?: boolean
    createdAt?: Date | string
  }

  export type TwoFactorChallengeCreateOrConnectWithoutUserInput = {
    where: TwoFactorChallengeWhereUniqueInput
    create: XOR<TwoFactorChallengeCreateWithoutUserInput, TwoFactorChallengeUncheckedCreateWithoutUserInput>
  }

  export type TwoFactorChallengeCreateManyUserInputEnvelope = {
    data: TwoFactorChallengeCreateManyUserInput | TwoFactorChallengeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserConsentCreateWithoutUserInput = {
    consentType: string
    status?: $Enums.ConsentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    recordedAt?: Date | string
  }

  export type UserConsentUncheckedCreateWithoutUserInput = {
    id?: number
    consentType: string
    status?: $Enums.ConsentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    recordedAt?: Date | string
  }

  export type UserConsentCreateOrConnectWithoutUserInput = {
    where: UserConsentWhereUniqueInput
    create: XOR<UserConsentCreateWithoutUserInput, UserConsentUncheckedCreateWithoutUserInput>
  }

  export type UserConsentCreateManyUserInputEnvelope = {
    data: UserConsentCreateManyUserInput | UserConsentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutUsersInput = {
    update: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutUsersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type CompanyUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    webhookSecret?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    billingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    billingCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipments?: ShipmentUpdateManyWithoutCompanyNestedInput
    agreements?: AgreementUpdateManyWithoutCompanyNestedInput
    transporterInvoices?: TransporterInvoiceUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    profiles?: CompanyProfileUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    webhookSecret?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    billingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    billingCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipments?: ShipmentUncheckedUpdateManyWithoutCompanyNestedInput
    agreements?: AgreementUncheckedUpdateManyWithoutCompanyNestedInput
    transporterInvoices?: TransporterInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    profiles?: CompanyProfileUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type VendorUpsertWithoutUserInput = {
    update: XOR<VendorUpdateWithoutUserInput, VendorUncheckedUpdateWithoutUserInput>
    create: XOR<VendorCreateWithoutUserInput, VendorUncheckedCreateWithoutUserInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutUserInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutUserInput, VendorUncheckedUpdateWithoutUserInput>
  }

  export type VendorUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    baseRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutVendorsNestedInput
    profile?: VendorProfileUpdateOneWithoutVendorNestedInput
    agreements?: AgreementUpdateManyWithoutVendorNestedInput
    rateCards?: RateCardUpdateManyWithoutVendorNestedInput
    quoteResponses?: QuoteResponseUpdateManyWithoutVendorNestedInput
    shipments?: ShipmentUpdateManyWithoutVendorNestedInput
    drivers?: DriverUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    baseRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: VendorProfileUncheckedUpdateOneWithoutVendorNestedInput
    agreements?: AgreementUncheckedUpdateManyWithoutVendorNestedInput
    rateCards?: RateCardUncheckedUpdateManyWithoutVendorNestedInput
    quoteResponses?: QuoteResponseUncheckedUpdateManyWithoutVendorNestedInput
    shipments?: ShipmentUncheckedUpdateManyWithoutVendorNestedInput
    drivers?: DriverUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type ShipmentUpsertWithWhereUniqueWithoutUserInput = {
    where: ShipmentWhereUniqueInput
    update: XOR<ShipmentUpdateWithoutUserInput, ShipmentUncheckedUpdateWithoutUserInput>
    create: XOR<ShipmentCreateWithoutUserInput, ShipmentUncheckedCreateWithoutUserInput>
  }

  export type ShipmentUpdateWithWhereUniqueWithoutUserInput = {
    where: ShipmentWhereUniqueInput
    data: XOR<ShipmentUpdateWithoutUserInput, ShipmentUncheckedUpdateWithoutUserInput>
  }

  export type ShipmentUpdateManyWithWhereWithoutUserInput = {
    where: ShipmentScalarWhereInput
    data: XOR<ShipmentUpdateManyMutationInput, ShipmentUncheckedUpdateManyWithoutUserInput>
  }

  export type ShipmentUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: ShipmentWhereUniqueInput
    update: XOR<ShipmentUpdateWithoutAssignedToInput, ShipmentUncheckedUpdateWithoutAssignedToInput>
    create: XOR<ShipmentCreateWithoutAssignedToInput, ShipmentUncheckedCreateWithoutAssignedToInput>
  }

  export type ShipmentUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: ShipmentWhereUniqueInput
    data: XOR<ShipmentUpdateWithoutAssignedToInput, ShipmentUncheckedUpdateWithoutAssignedToInput>
  }

  export type ShipmentUpdateManyWithWhereWithoutAssignedToInput = {
    where: ShipmentScalarWhereInput
    data: XOR<ShipmentUpdateManyMutationInput, ShipmentUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: IntFilter<"Notification"> | number
    userId?: IntFilter<"Notification"> | number
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    metadata?: JsonNullableFilter<"Notification">
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: IntFilter<"AuditLog"> | number
    userId?: IntNullableFilter<"AuditLog"> | number | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: IntNullableFilter<"AuditLog"> | number | null
    details?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type AgreementUpsertWithWhereUniqueWithoutReviewedByInput = {
    where: AgreementWhereUniqueInput
    update: XOR<AgreementUpdateWithoutReviewedByInput, AgreementUncheckedUpdateWithoutReviewedByInput>
    create: XOR<AgreementCreateWithoutReviewedByInput, AgreementUncheckedCreateWithoutReviewedByInput>
  }

  export type AgreementUpdateWithWhereUniqueWithoutReviewedByInput = {
    where: AgreementWhereUniqueInput
    data: XOR<AgreementUpdateWithoutReviewedByInput, AgreementUncheckedUpdateWithoutReviewedByInput>
  }

  export type AgreementUpdateManyWithWhereWithoutReviewedByInput = {
    where: AgreementScalarWhereInput
    data: XOR<AgreementUpdateManyMutationInput, AgreementUncheckedUpdateManyWithoutReviewedByInput>
  }

  export type TransporterInvoiceUpsertWithWhereUniqueWithoutApprovedByInput = {
    where: TransporterInvoiceWhereUniqueInput
    update: XOR<TransporterInvoiceUpdateWithoutApprovedByInput, TransporterInvoiceUncheckedUpdateWithoutApprovedByInput>
    create: XOR<TransporterInvoiceCreateWithoutApprovedByInput, TransporterInvoiceUncheckedCreateWithoutApprovedByInput>
  }

  export type TransporterInvoiceUpdateWithWhereUniqueWithoutApprovedByInput = {
    where: TransporterInvoiceWhereUniqueInput
    data: XOR<TransporterInvoiceUpdateWithoutApprovedByInput, TransporterInvoiceUncheckedUpdateWithoutApprovedByInput>
  }

  export type TransporterInvoiceUpdateManyWithWhereWithoutApprovedByInput = {
    where: TransporterInvoiceScalarWhereInput
    data: XOR<TransporterInvoiceUpdateManyMutationInput, TransporterInvoiceUncheckedUpdateManyWithoutApprovedByInput>
  }

  export type QuoteRequestUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: QuoteRequestWhereUniqueInput
    update: XOR<QuoteRequestUpdateWithoutCreatedByInput, QuoteRequestUncheckedUpdateWithoutCreatedByInput>
    create: XOR<QuoteRequestCreateWithoutCreatedByInput, QuoteRequestUncheckedCreateWithoutCreatedByInput>
  }

  export type QuoteRequestUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: QuoteRequestWhereUniqueInput
    data: XOR<QuoteRequestUpdateWithoutCreatedByInput, QuoteRequestUncheckedUpdateWithoutCreatedByInput>
  }

  export type QuoteRequestUpdateManyWithWhereWithoutCreatedByInput = {
    where: QuoteRequestScalarWhereInput
    data: XOR<QuoteRequestUpdateManyMutationInput, QuoteRequestUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type QuoteRequestScalarWhereInput = {
    AND?: QuoteRequestScalarWhereInput | QuoteRequestScalarWhereInput[]
    OR?: QuoteRequestScalarWhereInput[]
    NOT?: QuoteRequestScalarWhereInput | QuoteRequestScalarWhereInput[]
    id?: IntFilter<"QuoteRequest"> | number
    createdByUserId?: IntFilter<"QuoteRequest"> | number
    fromLocation?: StringFilter<"QuoteRequest"> | string
    toLocation?: StringFilter<"QuoteRequest"> | string
    fromLat?: FloatNullableFilter<"QuoteRequest"> | number | null
    fromLng?: FloatNullableFilter<"QuoteRequest"> | number | null
    toLat?: FloatNullableFilter<"QuoteRequest"> | number | null
    toLng?: FloatNullableFilter<"QuoteRequest"> | number | null
    weight?: FloatNullableFilter<"QuoteRequest"> | number | null
    shipmentType?: StringNullableFilter<"QuoteRequest"> | string | null
    urgency?: StringNullableFilter<"QuoteRequest"> | string | null
    status?: EnumQuoteStatusFilter<"QuoteRequest"> | $Enums.QuoteStatus
    notes?: StringNullableFilter<"QuoteRequest"> | string | null
    approvedResponseId?: IntNullableFilter<"QuoteRequest"> | number | null
    createdAt?: DateTimeFilter<"QuoteRequest"> | Date | string
    updatedAt?: DateTimeFilter<"QuoteRequest"> | Date | string
  }

  export type PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    update: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    data: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateManyWithWhereWithoutUserInput = {
    where: PasswordResetTokenScalarWhereInput
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type PasswordResetTokenScalarWhereInput = {
    AND?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
    OR?: PasswordResetTokenScalarWhereInput[]
    NOT?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
    id?: IntFilter<"PasswordResetToken"> | number
    userId?: IntFilter<"PasswordResetToken"> | number
    tokenHash?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    used?: BoolFilter<"PasswordResetToken"> | boolean
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
  }

  export type TwoFactorChallengeUpsertWithWhereUniqueWithoutUserInput = {
    where: TwoFactorChallengeWhereUniqueInput
    update: XOR<TwoFactorChallengeUpdateWithoutUserInput, TwoFactorChallengeUncheckedUpdateWithoutUserInput>
    create: XOR<TwoFactorChallengeCreateWithoutUserInput, TwoFactorChallengeUncheckedCreateWithoutUserInput>
  }

  export type TwoFactorChallengeUpdateWithWhereUniqueWithoutUserInput = {
    where: TwoFactorChallengeWhereUniqueInput
    data: XOR<TwoFactorChallengeUpdateWithoutUserInput, TwoFactorChallengeUncheckedUpdateWithoutUserInput>
  }

  export type TwoFactorChallengeUpdateManyWithWhereWithoutUserInput = {
    where: TwoFactorChallengeScalarWhereInput
    data: XOR<TwoFactorChallengeUpdateManyMutationInput, TwoFactorChallengeUncheckedUpdateManyWithoutUserInput>
  }

  export type TwoFactorChallengeScalarWhereInput = {
    AND?: TwoFactorChallengeScalarWhereInput | TwoFactorChallengeScalarWhereInput[]
    OR?: TwoFactorChallengeScalarWhereInput[]
    NOT?: TwoFactorChallengeScalarWhereInput | TwoFactorChallengeScalarWhereInput[]
    id?: IntFilter<"TwoFactorChallenge"> | number
    userId?: IntFilter<"TwoFactorChallenge"> | number
    codeHash?: StringFilter<"TwoFactorChallenge"> | string
    expiresAt?: DateTimeFilter<"TwoFactorChallenge"> | Date | string
    consumed?: BoolFilter<"TwoFactorChallenge"> | boolean
    createdAt?: DateTimeFilter<"TwoFactorChallenge"> | Date | string
  }

  export type UserConsentUpsertWithWhereUniqueWithoutUserInput = {
    where: UserConsentWhereUniqueInput
    update: XOR<UserConsentUpdateWithoutUserInput, UserConsentUncheckedUpdateWithoutUserInput>
    create: XOR<UserConsentCreateWithoutUserInput, UserConsentUncheckedCreateWithoutUserInput>
  }

  export type UserConsentUpdateWithWhereUniqueWithoutUserInput = {
    where: UserConsentWhereUniqueInput
    data: XOR<UserConsentUpdateWithoutUserInput, UserConsentUncheckedUpdateWithoutUserInput>
  }

  export type UserConsentUpdateManyWithWhereWithoutUserInput = {
    where: UserConsentScalarWhereInput
    data: XOR<UserConsentUpdateManyMutationInput, UserConsentUncheckedUpdateManyWithoutUserInput>
  }

  export type UserConsentScalarWhereInput = {
    AND?: UserConsentScalarWhereInput | UserConsentScalarWhereInput[]
    OR?: UserConsentScalarWhereInput[]
    NOT?: UserConsentScalarWhereInput | UserConsentScalarWhereInput[]
    id?: IntFilter<"UserConsent"> | number
    userId?: IntFilter<"UserConsent"> | number
    consentType?: StringFilter<"UserConsent"> | string
    status?: EnumConsentStatusFilter<"UserConsent"> | $Enums.ConsentStatus
    metadata?: JsonNullableFilter<"UserConsent">
    recordedAt?: DateTimeFilter<"UserConsent"> | Date | string
  }

  export type UserCreateWithoutPasswordResetTokensInput = {
    email: string
    passwordHash: string
    name?: string | null
    phone?: string | null
    role?: $Enums.Role
    approvalStatus?: $Enums.ApprovalStatus
    approvalNote?: string | null
    rejectionReason?: string | null
    reviewedById?: number | null
    reviewedAt?: Date | string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorChannel?: string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutUsersInput
    vendor?: VendorCreateNestedOneWithoutUserInput
    shipments?: ShipmentCreateNestedManyWithoutUserInput
    assignedShipments?: ShipmentCreateNestedManyWithoutAssignedToInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    agreementsReviewed?: AgreementCreateNestedManyWithoutReviewedByInput
    transporterInvoices?: TransporterInvoiceCreateNestedManyWithoutApprovedByInput
    QuoteRequest?: QuoteRequestCreateNestedManyWithoutCreatedByInput
    twoFactorChallenges?: TwoFactorChallengeCreateNestedManyWithoutUserInput
    userConsents?: UserConsentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPasswordResetTokensInput = {
    id?: number
    email: string
    passwordHash: string
    name?: string | null
    phone?: string | null
    role?: $Enums.Role
    approvalStatus?: $Enums.ApprovalStatus
    approvalNote?: string | null
    rejectionReason?: string | null
    reviewedById?: number | null
    reviewedAt?: Date | string | null
    isActive?: boolean
    vendorId?: number | null
    companyId?: number | null
    lastLoginAt?: Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorChannel?: string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    shipments?: ShipmentUncheckedCreateNestedManyWithoutUserInput
    assignedShipments?: ShipmentUncheckedCreateNestedManyWithoutAssignedToInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    agreementsReviewed?: AgreementUncheckedCreateNestedManyWithoutReviewedByInput
    transporterInvoices?: TransporterInvoiceUncheckedCreateNestedManyWithoutApprovedByInput
    QuoteRequest?: QuoteRequestUncheckedCreateNestedManyWithoutCreatedByInput
    twoFactorChallenges?: TwoFactorChallengeUncheckedCreateNestedManyWithoutUserInput
    userConsents?: UserConsentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPasswordResetTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
  }

  export type UserUpsertWithoutPasswordResetTokensInput = {
    update: XOR<UserUpdateWithoutPasswordResetTokensInput, UserUncheckedUpdateWithoutPasswordResetTokensInput>
    create: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasswordResetTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasswordResetTokensInput, UserUncheckedUpdateWithoutPasswordResetTokensInput>
  }

  export type UserUpdateWithoutPasswordResetTokensInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorChannel?: NullableStringFieldUpdateOperationsInput | string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutUsersNestedInput
    vendor?: VendorUpdateOneWithoutUserNestedInput
    shipments?: ShipmentUpdateManyWithoutUserNestedInput
    assignedShipments?: ShipmentUpdateManyWithoutAssignedToNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    agreementsReviewed?: AgreementUpdateManyWithoutReviewedByNestedInput
    transporterInvoices?: TransporterInvoiceUpdateManyWithoutApprovedByNestedInput
    QuoteRequest?: QuoteRequestUpdateManyWithoutCreatedByNestedInput
    twoFactorChallenges?: TwoFactorChallengeUpdateManyWithoutUserNestedInput
    userConsents?: UserConsentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordResetTokensInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorChannel?: NullableStringFieldUpdateOperationsInput | string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipments?: ShipmentUncheckedUpdateManyWithoutUserNestedInput
    assignedShipments?: ShipmentUncheckedUpdateManyWithoutAssignedToNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    agreementsReviewed?: AgreementUncheckedUpdateManyWithoutReviewedByNestedInput
    transporterInvoices?: TransporterInvoiceUncheckedUpdateManyWithoutApprovedByNestedInput
    QuoteRequest?: QuoteRequestUncheckedUpdateManyWithoutCreatedByNestedInput
    twoFactorChallenges?: TwoFactorChallengeUncheckedUpdateManyWithoutUserNestedInput
    userConsents?: UserConsentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutTwoFactorChallengesInput = {
    email: string
    passwordHash: string
    name?: string | null
    phone?: string | null
    role?: $Enums.Role
    approvalStatus?: $Enums.ApprovalStatus
    approvalNote?: string | null
    rejectionReason?: string | null
    reviewedById?: number | null
    reviewedAt?: Date | string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorChannel?: string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutUsersInput
    vendor?: VendorCreateNestedOneWithoutUserInput
    shipments?: ShipmentCreateNestedManyWithoutUserInput
    assignedShipments?: ShipmentCreateNestedManyWithoutAssignedToInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    agreementsReviewed?: AgreementCreateNestedManyWithoutReviewedByInput
    transporterInvoices?: TransporterInvoiceCreateNestedManyWithoutApprovedByInput
    QuoteRequest?: QuoteRequestCreateNestedManyWithoutCreatedByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    userConsents?: UserConsentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTwoFactorChallengesInput = {
    id?: number
    email: string
    passwordHash: string
    name?: string | null
    phone?: string | null
    role?: $Enums.Role
    approvalStatus?: $Enums.ApprovalStatus
    approvalNote?: string | null
    rejectionReason?: string | null
    reviewedById?: number | null
    reviewedAt?: Date | string | null
    isActive?: boolean
    vendorId?: number | null
    companyId?: number | null
    lastLoginAt?: Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorChannel?: string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    shipments?: ShipmentUncheckedCreateNestedManyWithoutUserInput
    assignedShipments?: ShipmentUncheckedCreateNestedManyWithoutAssignedToInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    agreementsReviewed?: AgreementUncheckedCreateNestedManyWithoutReviewedByInput
    transporterInvoices?: TransporterInvoiceUncheckedCreateNestedManyWithoutApprovedByInput
    QuoteRequest?: QuoteRequestUncheckedCreateNestedManyWithoutCreatedByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    userConsents?: UserConsentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTwoFactorChallengesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTwoFactorChallengesInput, UserUncheckedCreateWithoutTwoFactorChallengesInput>
  }

  export type UserUpsertWithoutTwoFactorChallengesInput = {
    update: XOR<UserUpdateWithoutTwoFactorChallengesInput, UserUncheckedUpdateWithoutTwoFactorChallengesInput>
    create: XOR<UserCreateWithoutTwoFactorChallengesInput, UserUncheckedCreateWithoutTwoFactorChallengesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTwoFactorChallengesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTwoFactorChallengesInput, UserUncheckedUpdateWithoutTwoFactorChallengesInput>
  }

  export type UserUpdateWithoutTwoFactorChallengesInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorChannel?: NullableStringFieldUpdateOperationsInput | string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutUsersNestedInput
    vendor?: VendorUpdateOneWithoutUserNestedInput
    shipments?: ShipmentUpdateManyWithoutUserNestedInput
    assignedShipments?: ShipmentUpdateManyWithoutAssignedToNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    agreementsReviewed?: AgreementUpdateManyWithoutReviewedByNestedInput
    transporterInvoices?: TransporterInvoiceUpdateManyWithoutApprovedByNestedInput
    QuoteRequest?: QuoteRequestUpdateManyWithoutCreatedByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    userConsents?: UserConsentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTwoFactorChallengesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorChannel?: NullableStringFieldUpdateOperationsInput | string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipments?: ShipmentUncheckedUpdateManyWithoutUserNestedInput
    assignedShipments?: ShipmentUncheckedUpdateManyWithoutAssignedToNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    agreementsReviewed?: AgreementUncheckedUpdateManyWithoutReviewedByNestedInput
    transporterInvoices?: TransporterInvoiceUncheckedUpdateManyWithoutApprovedByNestedInput
    QuoteRequest?: QuoteRequestUncheckedUpdateManyWithoutCreatedByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    userConsents?: UserConsentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutUserConsentsInput = {
    email: string
    passwordHash: string
    name?: string | null
    phone?: string | null
    role?: $Enums.Role
    approvalStatus?: $Enums.ApprovalStatus
    approvalNote?: string | null
    rejectionReason?: string | null
    reviewedById?: number | null
    reviewedAt?: Date | string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorChannel?: string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutUsersInput
    vendor?: VendorCreateNestedOneWithoutUserInput
    shipments?: ShipmentCreateNestedManyWithoutUserInput
    assignedShipments?: ShipmentCreateNestedManyWithoutAssignedToInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    agreementsReviewed?: AgreementCreateNestedManyWithoutReviewedByInput
    transporterInvoices?: TransporterInvoiceCreateNestedManyWithoutApprovedByInput
    QuoteRequest?: QuoteRequestCreateNestedManyWithoutCreatedByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    twoFactorChallenges?: TwoFactorChallengeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserConsentsInput = {
    id?: number
    email: string
    passwordHash: string
    name?: string | null
    phone?: string | null
    role?: $Enums.Role
    approvalStatus?: $Enums.ApprovalStatus
    approvalNote?: string | null
    rejectionReason?: string | null
    reviewedById?: number | null
    reviewedAt?: Date | string | null
    isActive?: boolean
    vendorId?: number | null
    companyId?: number | null
    lastLoginAt?: Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorChannel?: string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    shipments?: ShipmentUncheckedCreateNestedManyWithoutUserInput
    assignedShipments?: ShipmentUncheckedCreateNestedManyWithoutAssignedToInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    agreementsReviewed?: AgreementUncheckedCreateNestedManyWithoutReviewedByInput
    transporterInvoices?: TransporterInvoiceUncheckedCreateNestedManyWithoutApprovedByInput
    QuoteRequest?: QuoteRequestUncheckedCreateNestedManyWithoutCreatedByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    twoFactorChallenges?: TwoFactorChallengeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserConsentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserConsentsInput, UserUncheckedCreateWithoutUserConsentsInput>
  }

  export type UserUpsertWithoutUserConsentsInput = {
    update: XOR<UserUpdateWithoutUserConsentsInput, UserUncheckedUpdateWithoutUserConsentsInput>
    create: XOR<UserCreateWithoutUserConsentsInput, UserUncheckedCreateWithoutUserConsentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserConsentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserConsentsInput, UserUncheckedUpdateWithoutUserConsentsInput>
  }

  export type UserUpdateWithoutUserConsentsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorChannel?: NullableStringFieldUpdateOperationsInput | string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutUsersNestedInput
    vendor?: VendorUpdateOneWithoutUserNestedInput
    shipments?: ShipmentUpdateManyWithoutUserNestedInput
    assignedShipments?: ShipmentUpdateManyWithoutAssignedToNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    agreementsReviewed?: AgreementUpdateManyWithoutReviewedByNestedInput
    transporterInvoices?: TransporterInvoiceUpdateManyWithoutApprovedByNestedInput
    QuoteRequest?: QuoteRequestUpdateManyWithoutCreatedByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    twoFactorChallenges?: TwoFactorChallengeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserConsentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorChannel?: NullableStringFieldUpdateOperationsInput | string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipments?: ShipmentUncheckedUpdateManyWithoutUserNestedInput
    assignedShipments?: ShipmentUncheckedUpdateManyWithoutAssignedToNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    agreementsReviewed?: AgreementUncheckedUpdateManyWithoutReviewedByNestedInput
    transporterInvoices?: TransporterInvoiceUncheckedUpdateManyWithoutApprovedByNestedInput
    QuoteRequest?: QuoteRequestUncheckedUpdateManyWithoutCreatedByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    twoFactorChallenges?: TwoFactorChallengeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CompanyCreateWithoutVendorsInput = {
    name: string
    webhookSecret: string
    plan?: string
    subscriptionStatus?: string
    billingEmail?: string | null
    billingCustomerId?: string | null
    trialEndsAt?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    shipments?: ShipmentCreateNestedManyWithoutCompanyInput
    agreements?: AgreementCreateNestedManyWithoutCompanyInput
    transporterInvoices?: TransporterInvoiceCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    profiles?: CompanyProfileCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutVendorsInput = {
    id?: number
    name: string
    webhookSecret: string
    plan?: string
    subscriptionStatus?: string
    billingEmail?: string | null
    billingCustomerId?: string | null
    trialEndsAt?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    shipments?: ShipmentUncheckedCreateNestedManyWithoutCompanyInput
    agreements?: AgreementUncheckedCreateNestedManyWithoutCompanyInput
    transporterInvoices?: TransporterInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    profiles?: CompanyProfileUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutVendorsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutVendorsInput, CompanyUncheckedCreateWithoutVendorsInput>
  }

  export type VendorProfileCreateWithoutVendorInput = {
    legalName?: string | null
    gstin?: string | null
    pan?: string | null
    tan?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    rcmEligible?: boolean
    gstRegistrationType?: string | null
    contactPerson?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorProfileUncheckedCreateWithoutVendorInput = {
    id?: number
    legalName?: string | null
    gstin?: string | null
    pan?: string | null
    tan?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    rcmEligible?: boolean
    gstRegistrationType?: string | null
    contactPerson?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorProfileCreateOrConnectWithoutVendorInput = {
    where: VendorProfileWhereUniqueInput
    create: XOR<VendorProfileCreateWithoutVendorInput, VendorProfileUncheckedCreateWithoutVendorInput>
  }

  export type AgreementCreateWithoutVendorInput = {
    title: string
    referenceCode: string
    status?: string
    effectiveFrom?: Date | string | null
    effectiveTo?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedBy?: UserCreateNestedOneWithoutAgreementsReviewedInput
    rateCards?: RateCardCreateNestedManyWithoutAgreementInput
    Company?: CompanyCreateNestedOneWithoutAgreementsInput
  }

  export type AgreementUncheckedCreateWithoutVendorInput = {
    id?: number
    title: string
    referenceCode: string
    status?: string
    effectiveFrom?: Date | string | null
    effectiveTo?: Date | string | null
    notes?: string | null
    reviewedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: number | null
    rateCards?: RateCardUncheckedCreateNestedManyWithoutAgreementInput
  }

  export type AgreementCreateOrConnectWithoutVendorInput = {
    where: AgreementWhereUniqueInput
    create: XOR<AgreementCreateWithoutVendorInput, AgreementUncheckedCreateWithoutVendorInput>
  }

  export type AgreementCreateManyVendorInputEnvelope = {
    data: AgreementCreateManyVendorInput | AgreementCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type RateCardCreateWithoutVendorInput = {
    routeName: string
    origin: string
    destination: string
    distanceKm?: number | null
    ratePerKm: number
    uom: string
    vehicleType: string
    effectiveFrom?: Date | string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agreement: AgreementCreateNestedOneWithoutRateCardsInput
    shipments?: ShipmentCreateNestedManyWithoutRateCardInput
  }

  export type RateCardUncheckedCreateWithoutVendorInput = {
    id?: number
    agreementId: number
    routeName: string
    origin: string
    destination: string
    distanceKm?: number | null
    ratePerKm: number
    uom: string
    vehicleType: string
    effectiveFrom?: Date | string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shipments?: ShipmentUncheckedCreateNestedManyWithoutRateCardInput
  }

  export type RateCardCreateOrConnectWithoutVendorInput = {
    where: RateCardWhereUniqueInput
    create: XOR<RateCardCreateWithoutVendorInput, RateCardUncheckedCreateWithoutVendorInput>
  }

  export type RateCardCreateManyVendorInputEnvelope = {
    data: RateCardCreateManyVendorInput | RateCardCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type QuoteResponseCreateWithoutVendorInput = {
    quotedPrice?: number | null
    estimatedDelivery?: Date | string | null
    expiresAt?: Date | string | null
    status?: $Enums.QuoteResponseStatus
    consentStatus?: $Enums.ConsentStatus
    notes?: string | null
    transporterNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quoteRequest: QuoteRequestCreateNestedOneWithoutResponsesInput
    shipment?: ShipmentCreateNestedOneWithoutTransporterQuoteInput
    approvedFor?: QuoteRequestCreateNestedOneWithoutApprovedResponseInput
    consentLogs?: ConsentLogCreateNestedManyWithoutQuoteResponseInput
  }

  export type QuoteResponseUncheckedCreateWithoutVendorInput = {
    id?: number
    quoteRequestId: number
    quotedPrice?: number | null
    estimatedDelivery?: Date | string | null
    expiresAt?: Date | string | null
    status?: $Enums.QuoteResponseStatus
    consentStatus?: $Enums.ConsentStatus
    notes?: string | null
    transporterNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shipment?: ShipmentUncheckedCreateNestedOneWithoutTransporterQuoteInput
    approvedFor?: QuoteRequestUncheckedCreateNestedOneWithoutApprovedResponseInput
    consentLogs?: ConsentLogUncheckedCreateNestedManyWithoutQuoteResponseInput
  }

  export type QuoteResponseCreateOrConnectWithoutVendorInput = {
    where: QuoteResponseWhereUniqueInput
    create: XOR<QuoteResponseCreateWithoutVendorInput, QuoteResponseUncheckedCreateWithoutVendorInput>
  }

  export type QuoteResponseCreateManyVendorInputEnvelope = {
    data: QuoteResponseCreateManyVendorInput | QuoteResponseCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type ShipmentCreateWithoutVendorInput = {
    agreementId?: number | null
    trackingNumber?: string | null
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.ShipmentStatus
    bookingStatus?: $Enums.BookingStatus | null
    paymentStatus?: $Enums.PaymentStatus | null
    cost?: number | null
    distance?: number | null
    estimatedDelivery?: Date | string | null
    pickupTime?: Date | string | null
    deliveryTime?: Date | string | null
    assignedDriver?: string | null
    driverPhone?: string | null
    driverEta?: Date | string | null
    transporterResponseNotes?: string | null
    notes?: string | null
    ewayBillNumber?: string | null
    gstInvoiceId?: number | null
    complianceStatus?: $Enums.ComplianceStatus
    source?: string
    podStatus?: string
    podUrl?: string | null
    podNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutShipmentsInput
    company?: CompanyCreateNestedOneWithoutShipmentsInput
    quoteRequest?: QuoteRequestCreateNestedOneWithoutShipmentInput
    transporterQuote?: QuoteResponseCreateNestedOneWithoutShipmentInput
    rateCard?: RateCardCreateNestedOneWithoutShipmentsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedShipmentsInput
    statusHistory?: StatusHistoryCreateNestedManyWithoutShipmentInput
    complianceDocs?: ComplianceDocumentCreateNestedManyWithoutShipmentInput
    payments?: PaymentCreateNestedManyWithoutShipmentInput
    invoice?: InvoiceCreateNestedOneWithoutShipmentInput
    consentLogs?: ConsentLogCreateNestedManyWithoutShipmentInput
    transporterInvoices?: TransporterInvoiceCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentUncheckedCreateWithoutVendorInput = {
    id?: number
    userId: number
    companyId?: number | null
    quoteRequestId?: number | null
    transporterQuoteId?: number | null
    agreementId?: number | null
    rateCardId?: number | null
    trackingNumber?: string | null
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.ShipmentStatus
    bookingStatus?: $Enums.BookingStatus | null
    paymentStatus?: $Enums.PaymentStatus | null
    cost?: number | null
    distance?: number | null
    estimatedDelivery?: Date | string | null
    pickupTime?: Date | string | null
    deliveryTime?: Date | string | null
    assignedToId?: number | null
    assignedDriver?: string | null
    driverPhone?: string | null
    driverEta?: Date | string | null
    transporterResponseNotes?: string | null
    notes?: string | null
    ewayBillNumber?: string | null
    gstInvoiceId?: number | null
    complianceStatus?: $Enums.ComplianceStatus
    source?: string
    podStatus?: string
    podUrl?: string | null
    podNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    statusHistory?: StatusHistoryUncheckedCreateNestedManyWithoutShipmentInput
    complianceDocs?: ComplianceDocumentUncheckedCreateNestedManyWithoutShipmentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutShipmentInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutShipmentInput
    consentLogs?: ConsentLogUncheckedCreateNestedManyWithoutShipmentInput
    transporterInvoices?: TransporterInvoiceUncheckedCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentCreateOrConnectWithoutVendorInput = {
    where: ShipmentWhereUniqueInput
    create: XOR<ShipmentCreateWithoutVendorInput, ShipmentUncheckedCreateWithoutVendorInput>
  }

  export type ShipmentCreateManyVendorInputEnvelope = {
    data: ShipmentCreateManyVendorInput | ShipmentCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type DriverCreateWithoutVendorInput = {
    name: string
    phone?: string | null
    licenseNumber?: string | null
    vehicleNumber?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DriverUncheckedCreateWithoutVendorInput = {
    id?: number
    name: string
    phone?: string | null
    licenseNumber?: string | null
    vehicleNumber?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DriverCreateOrConnectWithoutVendorInput = {
    where: DriverWhereUniqueInput
    create: XOR<DriverCreateWithoutVendorInput, DriverUncheckedCreateWithoutVendorInput>
  }

  export type DriverCreateManyVendorInputEnvelope = {
    data: DriverCreateManyVendorInput | DriverCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutVendorInput = {
    email: string
    passwordHash: string
    name?: string | null
    phone?: string | null
    role?: $Enums.Role
    approvalStatus?: $Enums.ApprovalStatus
    approvalNote?: string | null
    rejectionReason?: string | null
    reviewedById?: number | null
    reviewedAt?: Date | string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorChannel?: string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutUsersInput
    shipments?: ShipmentCreateNestedManyWithoutUserInput
    assignedShipments?: ShipmentCreateNestedManyWithoutAssignedToInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    agreementsReviewed?: AgreementCreateNestedManyWithoutReviewedByInput
    transporterInvoices?: TransporterInvoiceCreateNestedManyWithoutApprovedByInput
    QuoteRequest?: QuoteRequestCreateNestedManyWithoutCreatedByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    twoFactorChallenges?: TwoFactorChallengeCreateNestedManyWithoutUserInput
    userConsents?: UserConsentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVendorInput = {
    id?: number
    email: string
    passwordHash: string
    name?: string | null
    phone?: string | null
    role?: $Enums.Role
    approvalStatus?: $Enums.ApprovalStatus
    approvalNote?: string | null
    rejectionReason?: string | null
    reviewedById?: number | null
    reviewedAt?: Date | string | null
    isActive?: boolean
    companyId?: number | null
    lastLoginAt?: Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorChannel?: string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    shipments?: ShipmentUncheckedCreateNestedManyWithoutUserInput
    assignedShipments?: ShipmentUncheckedCreateNestedManyWithoutAssignedToInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    agreementsReviewed?: AgreementUncheckedCreateNestedManyWithoutReviewedByInput
    transporterInvoices?: TransporterInvoiceUncheckedCreateNestedManyWithoutApprovedByInput
    QuoteRequest?: QuoteRequestUncheckedCreateNestedManyWithoutCreatedByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    twoFactorChallenges?: TwoFactorChallengeUncheckedCreateNestedManyWithoutUserInput
    userConsents?: UserConsentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVendorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVendorInput, UserUncheckedCreateWithoutVendorInput>
  }

  export type UserCreateManyVendorInputEnvelope = {
    data: UserCreateManyVendorInput | UserCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutVendorsInput = {
    update: XOR<CompanyUpdateWithoutVendorsInput, CompanyUncheckedUpdateWithoutVendorsInput>
    create: XOR<CompanyCreateWithoutVendorsInput, CompanyUncheckedCreateWithoutVendorsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutVendorsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutVendorsInput, CompanyUncheckedUpdateWithoutVendorsInput>
  }

  export type CompanyUpdateWithoutVendorsInput = {
    name?: StringFieldUpdateOperationsInput | string
    webhookSecret?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    billingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    billingCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    shipments?: ShipmentUpdateManyWithoutCompanyNestedInput
    agreements?: AgreementUpdateManyWithoutCompanyNestedInput
    transporterInvoices?: TransporterInvoiceUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    profiles?: CompanyProfileUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutVendorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    webhookSecret?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    billingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    billingCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    shipments?: ShipmentUncheckedUpdateManyWithoutCompanyNestedInput
    agreements?: AgreementUncheckedUpdateManyWithoutCompanyNestedInput
    transporterInvoices?: TransporterInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    profiles?: CompanyProfileUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type VendorProfileUpsertWithoutVendorInput = {
    update: XOR<VendorProfileUpdateWithoutVendorInput, VendorProfileUncheckedUpdateWithoutVendorInput>
    create: XOR<VendorProfileCreateWithoutVendorInput, VendorProfileUncheckedCreateWithoutVendorInput>
    where?: VendorProfileWhereInput
  }

  export type VendorProfileUpdateToOneWithWhereWithoutVendorInput = {
    where?: VendorProfileWhereInput
    data: XOR<VendorProfileUpdateWithoutVendorInput, VendorProfileUncheckedUpdateWithoutVendorInput>
  }

  export type VendorProfileUpdateWithoutVendorInput = {
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    tan?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    rcmEligible?: BoolFieldUpdateOperationsInput | boolean
    gstRegistrationType?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorProfileUncheckedUpdateWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    tan?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    rcmEligible?: BoolFieldUpdateOperationsInput | boolean
    gstRegistrationType?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgreementUpsertWithWhereUniqueWithoutVendorInput = {
    where: AgreementWhereUniqueInput
    update: XOR<AgreementUpdateWithoutVendorInput, AgreementUncheckedUpdateWithoutVendorInput>
    create: XOR<AgreementCreateWithoutVendorInput, AgreementUncheckedCreateWithoutVendorInput>
  }

  export type AgreementUpdateWithWhereUniqueWithoutVendorInput = {
    where: AgreementWhereUniqueInput
    data: XOR<AgreementUpdateWithoutVendorInput, AgreementUncheckedUpdateWithoutVendorInput>
  }

  export type AgreementUpdateManyWithWhereWithoutVendorInput = {
    where: AgreementScalarWhereInput
    data: XOR<AgreementUpdateManyMutationInput, AgreementUncheckedUpdateManyWithoutVendorInput>
  }

  export type RateCardUpsertWithWhereUniqueWithoutVendorInput = {
    where: RateCardWhereUniqueInput
    update: XOR<RateCardUpdateWithoutVendorInput, RateCardUncheckedUpdateWithoutVendorInput>
    create: XOR<RateCardCreateWithoutVendorInput, RateCardUncheckedCreateWithoutVendorInput>
  }

  export type RateCardUpdateWithWhereUniqueWithoutVendorInput = {
    where: RateCardWhereUniqueInput
    data: XOR<RateCardUpdateWithoutVendorInput, RateCardUncheckedUpdateWithoutVendorInput>
  }

  export type RateCardUpdateManyWithWhereWithoutVendorInput = {
    where: RateCardScalarWhereInput
    data: XOR<RateCardUpdateManyMutationInput, RateCardUncheckedUpdateManyWithoutVendorInput>
  }

  export type RateCardScalarWhereInput = {
    AND?: RateCardScalarWhereInput | RateCardScalarWhereInput[]
    OR?: RateCardScalarWhereInput[]
    NOT?: RateCardScalarWhereInput | RateCardScalarWhereInput[]
    id?: IntFilter<"RateCard"> | number
    agreementId?: IntFilter<"RateCard"> | number
    routeName?: StringFilter<"RateCard"> | string
    origin?: StringFilter<"RateCard"> | string
    destination?: StringFilter<"RateCard"> | string
    distanceKm?: FloatNullableFilter<"RateCard"> | number | null
    ratePerKm?: FloatFilter<"RateCard"> | number
    uom?: StringFilter<"RateCard"> | string
    vehicleType?: StringFilter<"RateCard"> | string
    effectiveFrom?: DateTimeNullableFilter<"RateCard"> | Date | string | null
    remarks?: StringNullableFilter<"RateCard"> | string | null
    createdAt?: DateTimeFilter<"RateCard"> | Date | string
    updatedAt?: DateTimeFilter<"RateCard"> | Date | string
    vendorId?: IntNullableFilter<"RateCard"> | number | null
  }

  export type QuoteResponseUpsertWithWhereUniqueWithoutVendorInput = {
    where: QuoteResponseWhereUniqueInput
    update: XOR<QuoteResponseUpdateWithoutVendorInput, QuoteResponseUncheckedUpdateWithoutVendorInput>
    create: XOR<QuoteResponseCreateWithoutVendorInput, QuoteResponseUncheckedCreateWithoutVendorInput>
  }

  export type QuoteResponseUpdateWithWhereUniqueWithoutVendorInput = {
    where: QuoteResponseWhereUniqueInput
    data: XOR<QuoteResponseUpdateWithoutVendorInput, QuoteResponseUncheckedUpdateWithoutVendorInput>
  }

  export type QuoteResponseUpdateManyWithWhereWithoutVendorInput = {
    where: QuoteResponseScalarWhereInput
    data: XOR<QuoteResponseUpdateManyMutationInput, QuoteResponseUncheckedUpdateManyWithoutVendorInput>
  }

  export type QuoteResponseScalarWhereInput = {
    AND?: QuoteResponseScalarWhereInput | QuoteResponseScalarWhereInput[]
    OR?: QuoteResponseScalarWhereInput[]
    NOT?: QuoteResponseScalarWhereInput | QuoteResponseScalarWhereInput[]
    id?: IntFilter<"QuoteResponse"> | number
    quoteRequestId?: IntFilter<"QuoteResponse"> | number
    vendorId?: IntFilter<"QuoteResponse"> | number
    quotedPrice?: FloatNullableFilter<"QuoteResponse"> | number | null
    estimatedDelivery?: DateTimeNullableFilter<"QuoteResponse"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"QuoteResponse"> | Date | string | null
    status?: EnumQuoteResponseStatusFilter<"QuoteResponse"> | $Enums.QuoteResponseStatus
    consentStatus?: EnumConsentStatusFilter<"QuoteResponse"> | $Enums.ConsentStatus
    notes?: StringNullableFilter<"QuoteResponse"> | string | null
    transporterNotes?: StringNullableFilter<"QuoteResponse"> | string | null
    createdAt?: DateTimeFilter<"QuoteResponse"> | Date | string
    updatedAt?: DateTimeFilter<"QuoteResponse"> | Date | string
  }

  export type ShipmentUpsertWithWhereUniqueWithoutVendorInput = {
    where: ShipmentWhereUniqueInput
    update: XOR<ShipmentUpdateWithoutVendorInput, ShipmentUncheckedUpdateWithoutVendorInput>
    create: XOR<ShipmentCreateWithoutVendorInput, ShipmentUncheckedCreateWithoutVendorInput>
  }

  export type ShipmentUpdateWithWhereUniqueWithoutVendorInput = {
    where: ShipmentWhereUniqueInput
    data: XOR<ShipmentUpdateWithoutVendorInput, ShipmentUncheckedUpdateWithoutVendorInput>
  }

  export type ShipmentUpdateManyWithWhereWithoutVendorInput = {
    where: ShipmentScalarWhereInput
    data: XOR<ShipmentUpdateManyMutationInput, ShipmentUncheckedUpdateManyWithoutVendorInput>
  }

  export type DriverUpsertWithWhereUniqueWithoutVendorInput = {
    where: DriverWhereUniqueInput
    update: XOR<DriverUpdateWithoutVendorInput, DriverUncheckedUpdateWithoutVendorInput>
    create: XOR<DriverCreateWithoutVendorInput, DriverUncheckedCreateWithoutVendorInput>
  }

  export type DriverUpdateWithWhereUniqueWithoutVendorInput = {
    where: DriverWhereUniqueInput
    data: XOR<DriverUpdateWithoutVendorInput, DriverUncheckedUpdateWithoutVendorInput>
  }

  export type DriverUpdateManyWithWhereWithoutVendorInput = {
    where: DriverScalarWhereInput
    data: XOR<DriverUpdateManyMutationInput, DriverUncheckedUpdateManyWithoutVendorInput>
  }

  export type DriverScalarWhereInput = {
    AND?: DriverScalarWhereInput | DriverScalarWhereInput[]
    OR?: DriverScalarWhereInput[]
    NOT?: DriverScalarWhereInput | DriverScalarWhereInput[]
    id?: IntFilter<"Driver"> | number
    vendorId?: IntFilter<"Driver"> | number
    name?: StringFilter<"Driver"> | string
    phone?: StringNullableFilter<"Driver"> | string | null
    licenseNumber?: StringNullableFilter<"Driver"> | string | null
    vehicleNumber?: StringNullableFilter<"Driver"> | string | null
    notes?: StringNullableFilter<"Driver"> | string | null
    isActive?: BoolFilter<"Driver"> | boolean
    createdAt?: DateTimeFilter<"Driver"> | Date | string
    updatedAt?: DateTimeFilter<"Driver"> | Date | string
  }

  export type UserUpsertWithWhereUniqueWithoutVendorInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutVendorInput, UserUncheckedUpdateWithoutVendorInput>
    create: XOR<UserCreateWithoutVendorInput, UserUncheckedCreateWithoutVendorInput>
  }

  export type UserUpdateWithWhereUniqueWithoutVendorInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutVendorInput, UserUncheckedUpdateWithoutVendorInput>
  }

  export type UserUpdateManyWithWhereWithoutVendorInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutVendorInput>
  }

  export type VendorCreateWithoutProfileInput = {
    name: string
    email?: string | null
    phone?: string | null
    baseRate?: number | null
    rating?: number | null
    speed?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutVendorsInput
    agreements?: AgreementCreateNestedManyWithoutVendorInput
    rateCards?: RateCardCreateNestedManyWithoutVendorInput
    quoteResponses?: QuoteResponseCreateNestedManyWithoutVendorInput
    shipments?: ShipmentCreateNestedManyWithoutVendorInput
    drivers?: DriverCreateNestedManyWithoutVendorInput
    User?: UserCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutProfileInput = {
    id?: number
    name: string
    email?: string | null
    phone?: string | null
    baseRate?: number | null
    rating?: number | null
    speed?: number | null
    isActive?: boolean
    companyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agreements?: AgreementUncheckedCreateNestedManyWithoutVendorInput
    rateCards?: RateCardUncheckedCreateNestedManyWithoutVendorInput
    quoteResponses?: QuoteResponseUncheckedCreateNestedManyWithoutVendorInput
    shipments?: ShipmentUncheckedCreateNestedManyWithoutVendorInput
    drivers?: DriverUncheckedCreateNestedManyWithoutVendorInput
    User?: UserUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutProfileInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutProfileInput, VendorUncheckedCreateWithoutProfileInput>
  }

  export type VendorUpsertWithoutProfileInput = {
    update: XOR<VendorUpdateWithoutProfileInput, VendorUncheckedUpdateWithoutProfileInput>
    create: XOR<VendorCreateWithoutProfileInput, VendorUncheckedCreateWithoutProfileInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutProfileInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutProfileInput, VendorUncheckedUpdateWithoutProfileInput>
  }

  export type VendorUpdateWithoutProfileInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    baseRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutVendorsNestedInput
    agreements?: AgreementUpdateManyWithoutVendorNestedInput
    rateCards?: RateCardUpdateManyWithoutVendorNestedInput
    quoteResponses?: QuoteResponseUpdateManyWithoutVendorNestedInput
    shipments?: ShipmentUpdateManyWithoutVendorNestedInput
    drivers?: DriverUpdateManyWithoutVendorNestedInput
    User?: UserUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    baseRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agreements?: AgreementUncheckedUpdateManyWithoutVendorNestedInput
    rateCards?: RateCardUncheckedUpdateManyWithoutVendorNestedInput
    quoteResponses?: QuoteResponseUncheckedUpdateManyWithoutVendorNestedInput
    shipments?: ShipmentUncheckedUpdateManyWithoutVendorNestedInput
    drivers?: DriverUncheckedUpdateManyWithoutVendorNestedInput
    User?: UserUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type VendorCreateWithoutDriversInput = {
    name: string
    email?: string | null
    phone?: string | null
    baseRate?: number | null
    rating?: number | null
    speed?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutVendorsInput
    profile?: VendorProfileCreateNestedOneWithoutVendorInput
    agreements?: AgreementCreateNestedManyWithoutVendorInput
    rateCards?: RateCardCreateNestedManyWithoutVendorInput
    quoteResponses?: QuoteResponseCreateNestedManyWithoutVendorInput
    shipments?: ShipmentCreateNestedManyWithoutVendorInput
    User?: UserCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutDriversInput = {
    id?: number
    name: string
    email?: string | null
    phone?: string | null
    baseRate?: number | null
    rating?: number | null
    speed?: number | null
    isActive?: boolean
    companyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: VendorProfileUncheckedCreateNestedOneWithoutVendorInput
    agreements?: AgreementUncheckedCreateNestedManyWithoutVendorInput
    rateCards?: RateCardUncheckedCreateNestedManyWithoutVendorInput
    quoteResponses?: QuoteResponseUncheckedCreateNestedManyWithoutVendorInput
    shipments?: ShipmentUncheckedCreateNestedManyWithoutVendorInput
    User?: UserUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutDriversInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutDriversInput, VendorUncheckedCreateWithoutDriversInput>
  }

  export type VendorUpsertWithoutDriversInput = {
    update: XOR<VendorUpdateWithoutDriversInput, VendorUncheckedUpdateWithoutDriversInput>
    create: XOR<VendorCreateWithoutDriversInput, VendorUncheckedCreateWithoutDriversInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutDriversInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutDriversInput, VendorUncheckedUpdateWithoutDriversInput>
  }

  export type VendorUpdateWithoutDriversInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    baseRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutVendorsNestedInput
    profile?: VendorProfileUpdateOneWithoutVendorNestedInput
    agreements?: AgreementUpdateManyWithoutVendorNestedInput
    rateCards?: RateCardUpdateManyWithoutVendorNestedInput
    quoteResponses?: QuoteResponseUpdateManyWithoutVendorNestedInput
    shipments?: ShipmentUpdateManyWithoutVendorNestedInput
    User?: UserUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutDriversInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    baseRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: VendorProfileUncheckedUpdateOneWithoutVendorNestedInput
    agreements?: AgreementUncheckedUpdateManyWithoutVendorNestedInput
    rateCards?: RateCardUncheckedUpdateManyWithoutVendorNestedInput
    quoteResponses?: QuoteResponseUncheckedUpdateManyWithoutVendorNestedInput
    shipments?: ShipmentUncheckedUpdateManyWithoutVendorNestedInput
    User?: UserUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type VendorCreateWithoutAgreementsInput = {
    name: string
    email?: string | null
    phone?: string | null
    baseRate?: number | null
    rating?: number | null
    speed?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutVendorsInput
    profile?: VendorProfileCreateNestedOneWithoutVendorInput
    rateCards?: RateCardCreateNestedManyWithoutVendorInput
    quoteResponses?: QuoteResponseCreateNestedManyWithoutVendorInput
    shipments?: ShipmentCreateNestedManyWithoutVendorInput
    drivers?: DriverCreateNestedManyWithoutVendorInput
    User?: UserCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutAgreementsInput = {
    id?: number
    name: string
    email?: string | null
    phone?: string | null
    baseRate?: number | null
    rating?: number | null
    speed?: number | null
    isActive?: boolean
    companyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: VendorProfileUncheckedCreateNestedOneWithoutVendorInput
    rateCards?: RateCardUncheckedCreateNestedManyWithoutVendorInput
    quoteResponses?: QuoteResponseUncheckedCreateNestedManyWithoutVendorInput
    shipments?: ShipmentUncheckedCreateNestedManyWithoutVendorInput
    drivers?: DriverUncheckedCreateNestedManyWithoutVendorInput
    User?: UserUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutAgreementsInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutAgreementsInput, VendorUncheckedCreateWithoutAgreementsInput>
  }

  export type UserCreateWithoutAgreementsReviewedInput = {
    email: string
    passwordHash: string
    name?: string | null
    phone?: string | null
    role?: $Enums.Role
    approvalStatus?: $Enums.ApprovalStatus
    approvalNote?: string | null
    rejectionReason?: string | null
    reviewedById?: number | null
    reviewedAt?: Date | string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorChannel?: string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutUsersInput
    vendor?: VendorCreateNestedOneWithoutUserInput
    shipments?: ShipmentCreateNestedManyWithoutUserInput
    assignedShipments?: ShipmentCreateNestedManyWithoutAssignedToInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    transporterInvoices?: TransporterInvoiceCreateNestedManyWithoutApprovedByInput
    QuoteRequest?: QuoteRequestCreateNestedManyWithoutCreatedByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    twoFactorChallenges?: TwoFactorChallengeCreateNestedManyWithoutUserInput
    userConsents?: UserConsentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAgreementsReviewedInput = {
    id?: number
    email: string
    passwordHash: string
    name?: string | null
    phone?: string | null
    role?: $Enums.Role
    approvalStatus?: $Enums.ApprovalStatus
    approvalNote?: string | null
    rejectionReason?: string | null
    reviewedById?: number | null
    reviewedAt?: Date | string | null
    isActive?: boolean
    vendorId?: number | null
    companyId?: number | null
    lastLoginAt?: Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorChannel?: string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    shipments?: ShipmentUncheckedCreateNestedManyWithoutUserInput
    assignedShipments?: ShipmentUncheckedCreateNestedManyWithoutAssignedToInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    transporterInvoices?: TransporterInvoiceUncheckedCreateNestedManyWithoutApprovedByInput
    QuoteRequest?: QuoteRequestUncheckedCreateNestedManyWithoutCreatedByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    twoFactorChallenges?: TwoFactorChallengeUncheckedCreateNestedManyWithoutUserInput
    userConsents?: UserConsentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAgreementsReviewedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAgreementsReviewedInput, UserUncheckedCreateWithoutAgreementsReviewedInput>
  }

  export type RateCardCreateWithoutAgreementInput = {
    routeName: string
    origin: string
    destination: string
    distanceKm?: number | null
    ratePerKm: number
    uom: string
    vehicleType: string
    effectiveFrom?: Date | string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Vendor?: VendorCreateNestedOneWithoutRateCardsInput
    shipments?: ShipmentCreateNestedManyWithoutRateCardInput
  }

  export type RateCardUncheckedCreateWithoutAgreementInput = {
    id?: number
    routeName: string
    origin: string
    destination: string
    distanceKm?: number | null
    ratePerKm: number
    uom: string
    vehicleType: string
    effectiveFrom?: Date | string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendorId?: number | null
    shipments?: ShipmentUncheckedCreateNestedManyWithoutRateCardInput
  }

  export type RateCardCreateOrConnectWithoutAgreementInput = {
    where: RateCardWhereUniqueInput
    create: XOR<RateCardCreateWithoutAgreementInput, RateCardUncheckedCreateWithoutAgreementInput>
  }

  export type RateCardCreateManyAgreementInputEnvelope = {
    data: RateCardCreateManyAgreementInput | RateCardCreateManyAgreementInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutAgreementsInput = {
    name: string
    webhookSecret: string
    plan?: string
    subscriptionStatus?: string
    billingEmail?: string | null
    billingCustomerId?: string | null
    trialEndsAt?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    shipments?: ShipmentCreateNestedManyWithoutCompanyInput
    transporterInvoices?: TransporterInvoiceCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    profiles?: CompanyProfileCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutAgreementsInput = {
    id?: number
    name: string
    webhookSecret: string
    plan?: string
    subscriptionStatus?: string
    billingEmail?: string | null
    billingCustomerId?: string | null
    trialEndsAt?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    shipments?: ShipmentUncheckedCreateNestedManyWithoutCompanyInput
    transporterInvoices?: TransporterInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    profiles?: CompanyProfileUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutAgreementsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutAgreementsInput, CompanyUncheckedCreateWithoutAgreementsInput>
  }

  export type VendorUpsertWithoutAgreementsInput = {
    update: XOR<VendorUpdateWithoutAgreementsInput, VendorUncheckedUpdateWithoutAgreementsInput>
    create: XOR<VendorCreateWithoutAgreementsInput, VendorUncheckedCreateWithoutAgreementsInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutAgreementsInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutAgreementsInput, VendorUncheckedUpdateWithoutAgreementsInput>
  }

  export type VendorUpdateWithoutAgreementsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    baseRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutVendorsNestedInput
    profile?: VendorProfileUpdateOneWithoutVendorNestedInput
    rateCards?: RateCardUpdateManyWithoutVendorNestedInput
    quoteResponses?: QuoteResponseUpdateManyWithoutVendorNestedInput
    shipments?: ShipmentUpdateManyWithoutVendorNestedInput
    drivers?: DriverUpdateManyWithoutVendorNestedInput
    User?: UserUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutAgreementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    baseRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: VendorProfileUncheckedUpdateOneWithoutVendorNestedInput
    rateCards?: RateCardUncheckedUpdateManyWithoutVendorNestedInput
    quoteResponses?: QuoteResponseUncheckedUpdateManyWithoutVendorNestedInput
    shipments?: ShipmentUncheckedUpdateManyWithoutVendorNestedInput
    drivers?: DriverUncheckedUpdateManyWithoutVendorNestedInput
    User?: UserUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type UserUpsertWithoutAgreementsReviewedInput = {
    update: XOR<UserUpdateWithoutAgreementsReviewedInput, UserUncheckedUpdateWithoutAgreementsReviewedInput>
    create: XOR<UserCreateWithoutAgreementsReviewedInput, UserUncheckedCreateWithoutAgreementsReviewedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAgreementsReviewedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAgreementsReviewedInput, UserUncheckedUpdateWithoutAgreementsReviewedInput>
  }

  export type UserUpdateWithoutAgreementsReviewedInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorChannel?: NullableStringFieldUpdateOperationsInput | string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutUsersNestedInput
    vendor?: VendorUpdateOneWithoutUserNestedInput
    shipments?: ShipmentUpdateManyWithoutUserNestedInput
    assignedShipments?: ShipmentUpdateManyWithoutAssignedToNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    transporterInvoices?: TransporterInvoiceUpdateManyWithoutApprovedByNestedInput
    QuoteRequest?: QuoteRequestUpdateManyWithoutCreatedByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    twoFactorChallenges?: TwoFactorChallengeUpdateManyWithoutUserNestedInput
    userConsents?: UserConsentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAgreementsReviewedInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorChannel?: NullableStringFieldUpdateOperationsInput | string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipments?: ShipmentUncheckedUpdateManyWithoutUserNestedInput
    assignedShipments?: ShipmentUncheckedUpdateManyWithoutAssignedToNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    transporterInvoices?: TransporterInvoiceUncheckedUpdateManyWithoutApprovedByNestedInput
    QuoteRequest?: QuoteRequestUncheckedUpdateManyWithoutCreatedByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    twoFactorChallenges?: TwoFactorChallengeUncheckedUpdateManyWithoutUserNestedInput
    userConsents?: UserConsentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RateCardUpsertWithWhereUniqueWithoutAgreementInput = {
    where: RateCardWhereUniqueInput
    update: XOR<RateCardUpdateWithoutAgreementInput, RateCardUncheckedUpdateWithoutAgreementInput>
    create: XOR<RateCardCreateWithoutAgreementInput, RateCardUncheckedCreateWithoutAgreementInput>
  }

  export type RateCardUpdateWithWhereUniqueWithoutAgreementInput = {
    where: RateCardWhereUniqueInput
    data: XOR<RateCardUpdateWithoutAgreementInput, RateCardUncheckedUpdateWithoutAgreementInput>
  }

  export type RateCardUpdateManyWithWhereWithoutAgreementInput = {
    where: RateCardScalarWhereInput
    data: XOR<RateCardUpdateManyMutationInput, RateCardUncheckedUpdateManyWithoutAgreementInput>
  }

  export type CompanyUpsertWithoutAgreementsInput = {
    update: XOR<CompanyUpdateWithoutAgreementsInput, CompanyUncheckedUpdateWithoutAgreementsInput>
    create: XOR<CompanyCreateWithoutAgreementsInput, CompanyUncheckedCreateWithoutAgreementsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutAgreementsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutAgreementsInput, CompanyUncheckedUpdateWithoutAgreementsInput>
  }

  export type CompanyUpdateWithoutAgreementsInput = {
    name?: StringFieldUpdateOperationsInput | string
    webhookSecret?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    billingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    billingCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    shipments?: ShipmentUpdateManyWithoutCompanyNestedInput
    transporterInvoices?: TransporterInvoiceUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    profiles?: CompanyProfileUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutAgreementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    webhookSecret?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    billingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    billingCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    shipments?: ShipmentUncheckedUpdateManyWithoutCompanyNestedInput
    transporterInvoices?: TransporterInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    profiles?: CompanyProfileUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type AgreementCreateWithoutRateCardsInput = {
    title: string
    referenceCode: string
    status?: string
    effectiveFrom?: Date | string | null
    effectiveTo?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutAgreementsInput
    reviewedBy?: UserCreateNestedOneWithoutAgreementsReviewedInput
    Company?: CompanyCreateNestedOneWithoutAgreementsInput
  }

  export type AgreementUncheckedCreateWithoutRateCardsInput = {
    id?: number
    vendorId: number
    title: string
    referenceCode: string
    status?: string
    effectiveFrom?: Date | string | null
    effectiveTo?: Date | string | null
    notes?: string | null
    reviewedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: number | null
  }

  export type AgreementCreateOrConnectWithoutRateCardsInput = {
    where: AgreementWhereUniqueInput
    create: XOR<AgreementCreateWithoutRateCardsInput, AgreementUncheckedCreateWithoutRateCardsInput>
  }

  export type VendorCreateWithoutRateCardsInput = {
    name: string
    email?: string | null
    phone?: string | null
    baseRate?: number | null
    rating?: number | null
    speed?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutVendorsInput
    profile?: VendorProfileCreateNestedOneWithoutVendorInput
    agreements?: AgreementCreateNestedManyWithoutVendorInput
    quoteResponses?: QuoteResponseCreateNestedManyWithoutVendorInput
    shipments?: ShipmentCreateNestedManyWithoutVendorInput
    drivers?: DriverCreateNestedManyWithoutVendorInput
    User?: UserCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutRateCardsInput = {
    id?: number
    name: string
    email?: string | null
    phone?: string | null
    baseRate?: number | null
    rating?: number | null
    speed?: number | null
    isActive?: boolean
    companyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: VendorProfileUncheckedCreateNestedOneWithoutVendorInput
    agreements?: AgreementUncheckedCreateNestedManyWithoutVendorInput
    quoteResponses?: QuoteResponseUncheckedCreateNestedManyWithoutVendorInput
    shipments?: ShipmentUncheckedCreateNestedManyWithoutVendorInput
    drivers?: DriverUncheckedCreateNestedManyWithoutVendorInput
    User?: UserUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutRateCardsInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutRateCardsInput, VendorUncheckedCreateWithoutRateCardsInput>
  }

  export type ShipmentCreateWithoutRateCardInput = {
    agreementId?: number | null
    trackingNumber?: string | null
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.ShipmentStatus
    bookingStatus?: $Enums.BookingStatus | null
    paymentStatus?: $Enums.PaymentStatus | null
    cost?: number | null
    distance?: number | null
    estimatedDelivery?: Date | string | null
    pickupTime?: Date | string | null
    deliveryTime?: Date | string | null
    assignedDriver?: string | null
    driverPhone?: string | null
    driverEta?: Date | string | null
    transporterResponseNotes?: string | null
    notes?: string | null
    ewayBillNumber?: string | null
    gstInvoiceId?: number | null
    complianceStatus?: $Enums.ComplianceStatus
    source?: string
    podStatus?: string
    podUrl?: string | null
    podNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutShipmentsInput
    company?: CompanyCreateNestedOneWithoutShipmentsInput
    quoteRequest?: QuoteRequestCreateNestedOneWithoutShipmentInput
    transporterQuote?: QuoteResponseCreateNestedOneWithoutShipmentInput
    vendor?: VendorCreateNestedOneWithoutShipmentsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedShipmentsInput
    statusHistory?: StatusHistoryCreateNestedManyWithoutShipmentInput
    complianceDocs?: ComplianceDocumentCreateNestedManyWithoutShipmentInput
    payments?: PaymentCreateNestedManyWithoutShipmentInput
    invoice?: InvoiceCreateNestedOneWithoutShipmentInput
    consentLogs?: ConsentLogCreateNestedManyWithoutShipmentInput
    transporterInvoices?: TransporterInvoiceCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentUncheckedCreateWithoutRateCardInput = {
    id?: number
    userId: number
    companyId?: number | null
    quoteRequestId?: number | null
    transporterQuoteId?: number | null
    selectedVendorId?: number | null
    agreementId?: number | null
    trackingNumber?: string | null
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.ShipmentStatus
    bookingStatus?: $Enums.BookingStatus | null
    paymentStatus?: $Enums.PaymentStatus | null
    cost?: number | null
    distance?: number | null
    estimatedDelivery?: Date | string | null
    pickupTime?: Date | string | null
    deliveryTime?: Date | string | null
    assignedToId?: number | null
    assignedDriver?: string | null
    driverPhone?: string | null
    driverEta?: Date | string | null
    transporterResponseNotes?: string | null
    notes?: string | null
    ewayBillNumber?: string | null
    gstInvoiceId?: number | null
    complianceStatus?: $Enums.ComplianceStatus
    source?: string
    podStatus?: string
    podUrl?: string | null
    podNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    statusHistory?: StatusHistoryUncheckedCreateNestedManyWithoutShipmentInput
    complianceDocs?: ComplianceDocumentUncheckedCreateNestedManyWithoutShipmentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutShipmentInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutShipmentInput
    consentLogs?: ConsentLogUncheckedCreateNestedManyWithoutShipmentInput
    transporterInvoices?: TransporterInvoiceUncheckedCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentCreateOrConnectWithoutRateCardInput = {
    where: ShipmentWhereUniqueInput
    create: XOR<ShipmentCreateWithoutRateCardInput, ShipmentUncheckedCreateWithoutRateCardInput>
  }

  export type ShipmentCreateManyRateCardInputEnvelope = {
    data: ShipmentCreateManyRateCardInput | ShipmentCreateManyRateCardInput[]
    skipDuplicates?: boolean
  }

  export type AgreementUpsertWithoutRateCardsInput = {
    update: XOR<AgreementUpdateWithoutRateCardsInput, AgreementUncheckedUpdateWithoutRateCardsInput>
    create: XOR<AgreementCreateWithoutRateCardsInput, AgreementUncheckedCreateWithoutRateCardsInput>
    where?: AgreementWhereInput
  }

  export type AgreementUpdateToOneWithWhereWithoutRateCardsInput = {
    where?: AgreementWhereInput
    data: XOR<AgreementUpdateWithoutRateCardsInput, AgreementUncheckedUpdateWithoutRateCardsInput>
  }

  export type AgreementUpdateWithoutRateCardsInput = {
    title?: StringFieldUpdateOperationsInput | string
    referenceCode?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutAgreementsNestedInput
    reviewedBy?: UserUpdateOneWithoutAgreementsReviewedNestedInput
    Company?: CompanyUpdateOneWithoutAgreementsNestedInput
  }

  export type AgreementUncheckedUpdateWithoutRateCardsInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    referenceCode?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VendorUpsertWithoutRateCardsInput = {
    update: XOR<VendorUpdateWithoutRateCardsInput, VendorUncheckedUpdateWithoutRateCardsInput>
    create: XOR<VendorCreateWithoutRateCardsInput, VendorUncheckedCreateWithoutRateCardsInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutRateCardsInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutRateCardsInput, VendorUncheckedUpdateWithoutRateCardsInput>
  }

  export type VendorUpdateWithoutRateCardsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    baseRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutVendorsNestedInput
    profile?: VendorProfileUpdateOneWithoutVendorNestedInput
    agreements?: AgreementUpdateManyWithoutVendorNestedInput
    quoteResponses?: QuoteResponseUpdateManyWithoutVendorNestedInput
    shipments?: ShipmentUpdateManyWithoutVendorNestedInput
    drivers?: DriverUpdateManyWithoutVendorNestedInput
    User?: UserUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutRateCardsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    baseRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: VendorProfileUncheckedUpdateOneWithoutVendorNestedInput
    agreements?: AgreementUncheckedUpdateManyWithoutVendorNestedInput
    quoteResponses?: QuoteResponseUncheckedUpdateManyWithoutVendorNestedInput
    shipments?: ShipmentUncheckedUpdateManyWithoutVendorNestedInput
    drivers?: DriverUncheckedUpdateManyWithoutVendorNestedInput
    User?: UserUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type ShipmentUpsertWithWhereUniqueWithoutRateCardInput = {
    where: ShipmentWhereUniqueInput
    update: XOR<ShipmentUpdateWithoutRateCardInput, ShipmentUncheckedUpdateWithoutRateCardInput>
    create: XOR<ShipmentCreateWithoutRateCardInput, ShipmentUncheckedCreateWithoutRateCardInput>
  }

  export type ShipmentUpdateWithWhereUniqueWithoutRateCardInput = {
    where: ShipmentWhereUniqueInput
    data: XOR<ShipmentUpdateWithoutRateCardInput, ShipmentUncheckedUpdateWithoutRateCardInput>
  }

  export type ShipmentUpdateManyWithWhereWithoutRateCardInput = {
    where: ShipmentScalarWhereInput
    data: XOR<ShipmentUpdateManyMutationInput, ShipmentUncheckedUpdateManyWithoutRateCardInput>
  }

  export type UserCreateWithoutQuoteRequestInput = {
    email: string
    passwordHash: string
    name?: string | null
    phone?: string | null
    role?: $Enums.Role
    approvalStatus?: $Enums.ApprovalStatus
    approvalNote?: string | null
    rejectionReason?: string | null
    reviewedById?: number | null
    reviewedAt?: Date | string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorChannel?: string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutUsersInput
    vendor?: VendorCreateNestedOneWithoutUserInput
    shipments?: ShipmentCreateNestedManyWithoutUserInput
    assignedShipments?: ShipmentCreateNestedManyWithoutAssignedToInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    agreementsReviewed?: AgreementCreateNestedManyWithoutReviewedByInput
    transporterInvoices?: TransporterInvoiceCreateNestedManyWithoutApprovedByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    twoFactorChallenges?: TwoFactorChallengeCreateNestedManyWithoutUserInput
    userConsents?: UserConsentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutQuoteRequestInput = {
    id?: number
    email: string
    passwordHash: string
    name?: string | null
    phone?: string | null
    role?: $Enums.Role
    approvalStatus?: $Enums.ApprovalStatus
    approvalNote?: string | null
    rejectionReason?: string | null
    reviewedById?: number | null
    reviewedAt?: Date | string | null
    isActive?: boolean
    vendorId?: number | null
    companyId?: number | null
    lastLoginAt?: Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorChannel?: string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    shipments?: ShipmentUncheckedCreateNestedManyWithoutUserInput
    assignedShipments?: ShipmentUncheckedCreateNestedManyWithoutAssignedToInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    agreementsReviewed?: AgreementUncheckedCreateNestedManyWithoutReviewedByInput
    transporterInvoices?: TransporterInvoiceUncheckedCreateNestedManyWithoutApprovedByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    twoFactorChallenges?: TwoFactorChallengeUncheckedCreateNestedManyWithoutUserInput
    userConsents?: UserConsentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutQuoteRequestInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQuoteRequestInput, UserUncheckedCreateWithoutQuoteRequestInput>
  }

  export type QuoteResponseCreateWithoutQuoteRequestInput = {
    quotedPrice?: number | null
    estimatedDelivery?: Date | string | null
    expiresAt?: Date | string | null
    status?: $Enums.QuoteResponseStatus
    consentStatus?: $Enums.ConsentStatus
    notes?: string | null
    transporterNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutQuoteResponsesInput
    shipment?: ShipmentCreateNestedOneWithoutTransporterQuoteInput
    approvedFor?: QuoteRequestCreateNestedOneWithoutApprovedResponseInput
    consentLogs?: ConsentLogCreateNestedManyWithoutQuoteResponseInput
  }

  export type QuoteResponseUncheckedCreateWithoutQuoteRequestInput = {
    id?: number
    vendorId: number
    quotedPrice?: number | null
    estimatedDelivery?: Date | string | null
    expiresAt?: Date | string | null
    status?: $Enums.QuoteResponseStatus
    consentStatus?: $Enums.ConsentStatus
    notes?: string | null
    transporterNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shipment?: ShipmentUncheckedCreateNestedOneWithoutTransporterQuoteInput
    approvedFor?: QuoteRequestUncheckedCreateNestedOneWithoutApprovedResponseInput
    consentLogs?: ConsentLogUncheckedCreateNestedManyWithoutQuoteResponseInput
  }

  export type QuoteResponseCreateOrConnectWithoutQuoteRequestInput = {
    where: QuoteResponseWhereUniqueInput
    create: XOR<QuoteResponseCreateWithoutQuoteRequestInput, QuoteResponseUncheckedCreateWithoutQuoteRequestInput>
  }

  export type QuoteResponseCreateManyQuoteRequestInputEnvelope = {
    data: QuoteResponseCreateManyQuoteRequestInput | QuoteResponseCreateManyQuoteRequestInput[]
    skipDuplicates?: boolean
  }

  export type QuoteResponseCreateWithoutApprovedForInput = {
    quotedPrice?: number | null
    estimatedDelivery?: Date | string | null
    expiresAt?: Date | string | null
    status?: $Enums.QuoteResponseStatus
    consentStatus?: $Enums.ConsentStatus
    notes?: string | null
    transporterNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quoteRequest: QuoteRequestCreateNestedOneWithoutResponsesInput
    vendor: VendorCreateNestedOneWithoutQuoteResponsesInput
    shipment?: ShipmentCreateNestedOneWithoutTransporterQuoteInput
    consentLogs?: ConsentLogCreateNestedManyWithoutQuoteResponseInput
  }

  export type QuoteResponseUncheckedCreateWithoutApprovedForInput = {
    id?: number
    quoteRequestId: number
    vendorId: number
    quotedPrice?: number | null
    estimatedDelivery?: Date | string | null
    expiresAt?: Date | string | null
    status?: $Enums.QuoteResponseStatus
    consentStatus?: $Enums.ConsentStatus
    notes?: string | null
    transporterNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shipment?: ShipmentUncheckedCreateNestedOneWithoutTransporterQuoteInput
    consentLogs?: ConsentLogUncheckedCreateNestedManyWithoutQuoteResponseInput
  }

  export type QuoteResponseCreateOrConnectWithoutApprovedForInput = {
    where: QuoteResponseWhereUniqueInput
    create: XOR<QuoteResponseCreateWithoutApprovedForInput, QuoteResponseUncheckedCreateWithoutApprovedForInput>
  }

  export type ShipmentCreateWithoutQuoteRequestInput = {
    agreementId?: number | null
    trackingNumber?: string | null
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.ShipmentStatus
    bookingStatus?: $Enums.BookingStatus | null
    paymentStatus?: $Enums.PaymentStatus | null
    cost?: number | null
    distance?: number | null
    estimatedDelivery?: Date | string | null
    pickupTime?: Date | string | null
    deliveryTime?: Date | string | null
    assignedDriver?: string | null
    driverPhone?: string | null
    driverEta?: Date | string | null
    transporterResponseNotes?: string | null
    notes?: string | null
    ewayBillNumber?: string | null
    gstInvoiceId?: number | null
    complianceStatus?: $Enums.ComplianceStatus
    source?: string
    podStatus?: string
    podUrl?: string | null
    podNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutShipmentsInput
    company?: CompanyCreateNestedOneWithoutShipmentsInput
    transporterQuote?: QuoteResponseCreateNestedOneWithoutShipmentInput
    rateCard?: RateCardCreateNestedOneWithoutShipmentsInput
    vendor?: VendorCreateNestedOneWithoutShipmentsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedShipmentsInput
    statusHistory?: StatusHistoryCreateNestedManyWithoutShipmentInput
    complianceDocs?: ComplianceDocumentCreateNestedManyWithoutShipmentInput
    payments?: PaymentCreateNestedManyWithoutShipmentInput
    invoice?: InvoiceCreateNestedOneWithoutShipmentInput
    consentLogs?: ConsentLogCreateNestedManyWithoutShipmentInput
    transporterInvoices?: TransporterInvoiceCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentUncheckedCreateWithoutQuoteRequestInput = {
    id?: number
    userId: number
    companyId?: number | null
    transporterQuoteId?: number | null
    selectedVendorId?: number | null
    agreementId?: number | null
    rateCardId?: number | null
    trackingNumber?: string | null
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.ShipmentStatus
    bookingStatus?: $Enums.BookingStatus | null
    paymentStatus?: $Enums.PaymentStatus | null
    cost?: number | null
    distance?: number | null
    estimatedDelivery?: Date | string | null
    pickupTime?: Date | string | null
    deliveryTime?: Date | string | null
    assignedToId?: number | null
    assignedDriver?: string | null
    driverPhone?: string | null
    driverEta?: Date | string | null
    transporterResponseNotes?: string | null
    notes?: string | null
    ewayBillNumber?: string | null
    gstInvoiceId?: number | null
    complianceStatus?: $Enums.ComplianceStatus
    source?: string
    podStatus?: string
    podUrl?: string | null
    podNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    statusHistory?: StatusHistoryUncheckedCreateNestedManyWithoutShipmentInput
    complianceDocs?: ComplianceDocumentUncheckedCreateNestedManyWithoutShipmentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutShipmentInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutShipmentInput
    consentLogs?: ConsentLogUncheckedCreateNestedManyWithoutShipmentInput
    transporterInvoices?: TransporterInvoiceUncheckedCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentCreateOrConnectWithoutQuoteRequestInput = {
    where: ShipmentWhereUniqueInput
    create: XOR<ShipmentCreateWithoutQuoteRequestInput, ShipmentUncheckedCreateWithoutQuoteRequestInput>
  }

  export type UserUpsertWithoutQuoteRequestInput = {
    update: XOR<UserUpdateWithoutQuoteRequestInput, UserUncheckedUpdateWithoutQuoteRequestInput>
    create: XOR<UserCreateWithoutQuoteRequestInput, UserUncheckedCreateWithoutQuoteRequestInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutQuoteRequestInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutQuoteRequestInput, UserUncheckedUpdateWithoutQuoteRequestInput>
  }

  export type UserUpdateWithoutQuoteRequestInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorChannel?: NullableStringFieldUpdateOperationsInput | string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutUsersNestedInput
    vendor?: VendorUpdateOneWithoutUserNestedInput
    shipments?: ShipmentUpdateManyWithoutUserNestedInput
    assignedShipments?: ShipmentUpdateManyWithoutAssignedToNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    agreementsReviewed?: AgreementUpdateManyWithoutReviewedByNestedInput
    transporterInvoices?: TransporterInvoiceUpdateManyWithoutApprovedByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    twoFactorChallenges?: TwoFactorChallengeUpdateManyWithoutUserNestedInput
    userConsents?: UserConsentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutQuoteRequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorChannel?: NullableStringFieldUpdateOperationsInput | string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipments?: ShipmentUncheckedUpdateManyWithoutUserNestedInput
    assignedShipments?: ShipmentUncheckedUpdateManyWithoutAssignedToNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    agreementsReviewed?: AgreementUncheckedUpdateManyWithoutReviewedByNestedInput
    transporterInvoices?: TransporterInvoiceUncheckedUpdateManyWithoutApprovedByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    twoFactorChallenges?: TwoFactorChallengeUncheckedUpdateManyWithoutUserNestedInput
    userConsents?: UserConsentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type QuoteResponseUpsertWithWhereUniqueWithoutQuoteRequestInput = {
    where: QuoteResponseWhereUniqueInput
    update: XOR<QuoteResponseUpdateWithoutQuoteRequestInput, QuoteResponseUncheckedUpdateWithoutQuoteRequestInput>
    create: XOR<QuoteResponseCreateWithoutQuoteRequestInput, QuoteResponseUncheckedCreateWithoutQuoteRequestInput>
  }

  export type QuoteResponseUpdateWithWhereUniqueWithoutQuoteRequestInput = {
    where: QuoteResponseWhereUniqueInput
    data: XOR<QuoteResponseUpdateWithoutQuoteRequestInput, QuoteResponseUncheckedUpdateWithoutQuoteRequestInput>
  }

  export type QuoteResponseUpdateManyWithWhereWithoutQuoteRequestInput = {
    where: QuoteResponseScalarWhereInput
    data: XOR<QuoteResponseUpdateManyMutationInput, QuoteResponseUncheckedUpdateManyWithoutQuoteRequestInput>
  }

  export type QuoteResponseUpsertWithoutApprovedForInput = {
    update: XOR<QuoteResponseUpdateWithoutApprovedForInput, QuoteResponseUncheckedUpdateWithoutApprovedForInput>
    create: XOR<QuoteResponseCreateWithoutApprovedForInput, QuoteResponseUncheckedCreateWithoutApprovedForInput>
    where?: QuoteResponseWhereInput
  }

  export type QuoteResponseUpdateToOneWithWhereWithoutApprovedForInput = {
    where?: QuoteResponseWhereInput
    data: XOR<QuoteResponseUpdateWithoutApprovedForInput, QuoteResponseUncheckedUpdateWithoutApprovedForInput>
  }

  export type QuoteResponseUpdateWithoutApprovedForInput = {
    quotedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumQuoteResponseStatusFieldUpdateOperationsInput | $Enums.QuoteResponseStatus
    consentStatus?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    transporterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quoteRequest?: QuoteRequestUpdateOneRequiredWithoutResponsesNestedInput
    vendor?: VendorUpdateOneRequiredWithoutQuoteResponsesNestedInput
    shipment?: ShipmentUpdateOneWithoutTransporterQuoteNestedInput
    consentLogs?: ConsentLogUpdateManyWithoutQuoteResponseNestedInput
  }

  export type QuoteResponseUncheckedUpdateWithoutApprovedForInput = {
    id?: IntFieldUpdateOperationsInput | number
    quoteRequestId?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    quotedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumQuoteResponseStatusFieldUpdateOperationsInput | $Enums.QuoteResponseStatus
    consentStatus?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    transporterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipment?: ShipmentUncheckedUpdateOneWithoutTransporterQuoteNestedInput
    consentLogs?: ConsentLogUncheckedUpdateManyWithoutQuoteResponseNestedInput
  }

  export type ShipmentUpsertWithoutQuoteRequestInput = {
    update: XOR<ShipmentUpdateWithoutQuoteRequestInput, ShipmentUncheckedUpdateWithoutQuoteRequestInput>
    create: XOR<ShipmentCreateWithoutQuoteRequestInput, ShipmentUncheckedCreateWithoutQuoteRequestInput>
    where?: ShipmentWhereInput
  }

  export type ShipmentUpdateToOneWithWhereWithoutQuoteRequestInput = {
    where?: ShipmentWhereInput
    data: XOR<ShipmentUpdateWithoutQuoteRequestInput, ShipmentUncheckedUpdateWithoutQuoteRequestInput>
  }

  export type ShipmentUpdateWithoutQuoteRequestInput = {
    agreementId?: NullableIntFieldUpdateOperationsInput | number | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedDriver?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    driverEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transporterResponseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ewayBillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstInvoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    source?: StringFieldUpdateOperationsInput | string
    podStatus?: StringFieldUpdateOperationsInput | string
    podUrl?: NullableStringFieldUpdateOperationsInput | string | null
    podNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutShipmentsNestedInput
    company?: CompanyUpdateOneWithoutShipmentsNestedInput
    transporterQuote?: QuoteResponseUpdateOneWithoutShipmentNestedInput
    rateCard?: RateCardUpdateOneWithoutShipmentsNestedInput
    vendor?: VendorUpdateOneWithoutShipmentsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedShipmentsNestedInput
    statusHistory?: StatusHistoryUpdateManyWithoutShipmentNestedInput
    complianceDocs?: ComplianceDocumentUpdateManyWithoutShipmentNestedInput
    payments?: PaymentUpdateManyWithoutShipmentNestedInput
    invoice?: InvoiceUpdateOneWithoutShipmentNestedInput
    consentLogs?: ConsentLogUpdateManyWithoutShipmentNestedInput
    transporterInvoices?: TransporterInvoiceUpdateManyWithoutShipmentNestedInput
  }

  export type ShipmentUncheckedUpdateWithoutQuoteRequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    transporterQuoteId?: NullableIntFieldUpdateOperationsInput | number | null
    selectedVendorId?: NullableIntFieldUpdateOperationsInput | number | null
    agreementId?: NullableIntFieldUpdateOperationsInput | number | null
    rateCardId?: NullableIntFieldUpdateOperationsInput | number | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedDriver?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    driverEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transporterResponseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ewayBillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstInvoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    source?: StringFieldUpdateOperationsInput | string
    podStatus?: StringFieldUpdateOperationsInput | string
    podUrl?: NullableStringFieldUpdateOperationsInput | string | null
    podNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusHistory?: StatusHistoryUncheckedUpdateManyWithoutShipmentNestedInput
    complianceDocs?: ComplianceDocumentUncheckedUpdateManyWithoutShipmentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutShipmentNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutShipmentNestedInput
    consentLogs?: ConsentLogUncheckedUpdateManyWithoutShipmentNestedInput
    transporterInvoices?: TransporterInvoiceUncheckedUpdateManyWithoutShipmentNestedInput
  }

  export type QuoteRequestCreateWithoutResponsesInput = {
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.QuoteStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutQuoteRequestInput
    approvedResponse?: QuoteResponseCreateNestedOneWithoutApprovedForInput
    shipment?: ShipmentCreateNestedOneWithoutQuoteRequestInput
  }

  export type QuoteRequestUncheckedCreateWithoutResponsesInput = {
    id?: number
    createdByUserId: number
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.QuoteStatus
    notes?: string | null
    approvedResponseId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shipment?: ShipmentUncheckedCreateNestedOneWithoutQuoteRequestInput
  }

  export type QuoteRequestCreateOrConnectWithoutResponsesInput = {
    where: QuoteRequestWhereUniqueInput
    create: XOR<QuoteRequestCreateWithoutResponsesInput, QuoteRequestUncheckedCreateWithoutResponsesInput>
  }

  export type VendorCreateWithoutQuoteResponsesInput = {
    name: string
    email?: string | null
    phone?: string | null
    baseRate?: number | null
    rating?: number | null
    speed?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutVendorsInput
    profile?: VendorProfileCreateNestedOneWithoutVendorInput
    agreements?: AgreementCreateNestedManyWithoutVendorInput
    rateCards?: RateCardCreateNestedManyWithoutVendorInput
    shipments?: ShipmentCreateNestedManyWithoutVendorInput
    drivers?: DriverCreateNestedManyWithoutVendorInput
    User?: UserCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutQuoteResponsesInput = {
    id?: number
    name: string
    email?: string | null
    phone?: string | null
    baseRate?: number | null
    rating?: number | null
    speed?: number | null
    isActive?: boolean
    companyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: VendorProfileUncheckedCreateNestedOneWithoutVendorInput
    agreements?: AgreementUncheckedCreateNestedManyWithoutVendorInput
    rateCards?: RateCardUncheckedCreateNestedManyWithoutVendorInput
    shipments?: ShipmentUncheckedCreateNestedManyWithoutVendorInput
    drivers?: DriverUncheckedCreateNestedManyWithoutVendorInput
    User?: UserUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutQuoteResponsesInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutQuoteResponsesInput, VendorUncheckedCreateWithoutQuoteResponsesInput>
  }

  export type ShipmentCreateWithoutTransporterQuoteInput = {
    agreementId?: number | null
    trackingNumber?: string | null
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.ShipmentStatus
    bookingStatus?: $Enums.BookingStatus | null
    paymentStatus?: $Enums.PaymentStatus | null
    cost?: number | null
    distance?: number | null
    estimatedDelivery?: Date | string | null
    pickupTime?: Date | string | null
    deliveryTime?: Date | string | null
    assignedDriver?: string | null
    driverPhone?: string | null
    driverEta?: Date | string | null
    transporterResponseNotes?: string | null
    notes?: string | null
    ewayBillNumber?: string | null
    gstInvoiceId?: number | null
    complianceStatus?: $Enums.ComplianceStatus
    source?: string
    podStatus?: string
    podUrl?: string | null
    podNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutShipmentsInput
    company?: CompanyCreateNestedOneWithoutShipmentsInput
    quoteRequest?: QuoteRequestCreateNestedOneWithoutShipmentInput
    rateCard?: RateCardCreateNestedOneWithoutShipmentsInput
    vendor?: VendorCreateNestedOneWithoutShipmentsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedShipmentsInput
    statusHistory?: StatusHistoryCreateNestedManyWithoutShipmentInput
    complianceDocs?: ComplianceDocumentCreateNestedManyWithoutShipmentInput
    payments?: PaymentCreateNestedManyWithoutShipmentInput
    invoice?: InvoiceCreateNestedOneWithoutShipmentInput
    consentLogs?: ConsentLogCreateNestedManyWithoutShipmentInput
    transporterInvoices?: TransporterInvoiceCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentUncheckedCreateWithoutTransporterQuoteInput = {
    id?: number
    userId: number
    companyId?: number | null
    quoteRequestId?: number | null
    selectedVendorId?: number | null
    agreementId?: number | null
    rateCardId?: number | null
    trackingNumber?: string | null
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.ShipmentStatus
    bookingStatus?: $Enums.BookingStatus | null
    paymentStatus?: $Enums.PaymentStatus | null
    cost?: number | null
    distance?: number | null
    estimatedDelivery?: Date | string | null
    pickupTime?: Date | string | null
    deliveryTime?: Date | string | null
    assignedToId?: number | null
    assignedDriver?: string | null
    driverPhone?: string | null
    driverEta?: Date | string | null
    transporterResponseNotes?: string | null
    notes?: string | null
    ewayBillNumber?: string | null
    gstInvoiceId?: number | null
    complianceStatus?: $Enums.ComplianceStatus
    source?: string
    podStatus?: string
    podUrl?: string | null
    podNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    statusHistory?: StatusHistoryUncheckedCreateNestedManyWithoutShipmentInput
    complianceDocs?: ComplianceDocumentUncheckedCreateNestedManyWithoutShipmentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutShipmentInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutShipmentInput
    consentLogs?: ConsentLogUncheckedCreateNestedManyWithoutShipmentInput
    transporterInvoices?: TransporterInvoiceUncheckedCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentCreateOrConnectWithoutTransporterQuoteInput = {
    where: ShipmentWhereUniqueInput
    create: XOR<ShipmentCreateWithoutTransporterQuoteInput, ShipmentUncheckedCreateWithoutTransporterQuoteInput>
  }

  export type QuoteRequestCreateWithoutApprovedResponseInput = {
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.QuoteStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutQuoteRequestInput
    responses?: QuoteResponseCreateNestedManyWithoutQuoteRequestInput
    shipment?: ShipmentCreateNestedOneWithoutQuoteRequestInput
  }

  export type QuoteRequestUncheckedCreateWithoutApprovedResponseInput = {
    id?: number
    createdByUserId: number
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.QuoteStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: QuoteResponseUncheckedCreateNestedManyWithoutQuoteRequestInput
    shipment?: ShipmentUncheckedCreateNestedOneWithoutQuoteRequestInput
  }

  export type QuoteRequestCreateOrConnectWithoutApprovedResponseInput = {
    where: QuoteRequestWhereUniqueInput
    create: XOR<QuoteRequestCreateWithoutApprovedResponseInput, QuoteRequestUncheckedCreateWithoutApprovedResponseInput>
  }

  export type ConsentLogCreateWithoutQuoteResponseInput = {
    statusBefore: $Enums.ConsentStatus
    statusAfter: $Enums.ConsentStatus
    note?: string | null
    recordedAt?: Date | string
    shipment?: ShipmentCreateNestedOneWithoutConsentLogsInput
  }

  export type ConsentLogUncheckedCreateWithoutQuoteResponseInput = {
    id?: number
    shipmentId?: number | null
    statusBefore: $Enums.ConsentStatus
    statusAfter: $Enums.ConsentStatus
    note?: string | null
    recordedAt?: Date | string
  }

  export type ConsentLogCreateOrConnectWithoutQuoteResponseInput = {
    where: ConsentLogWhereUniqueInput
    create: XOR<ConsentLogCreateWithoutQuoteResponseInput, ConsentLogUncheckedCreateWithoutQuoteResponseInput>
  }

  export type ConsentLogCreateManyQuoteResponseInputEnvelope = {
    data: ConsentLogCreateManyQuoteResponseInput | ConsentLogCreateManyQuoteResponseInput[]
    skipDuplicates?: boolean
  }

  export type QuoteRequestUpsertWithoutResponsesInput = {
    update: XOR<QuoteRequestUpdateWithoutResponsesInput, QuoteRequestUncheckedUpdateWithoutResponsesInput>
    create: XOR<QuoteRequestCreateWithoutResponsesInput, QuoteRequestUncheckedCreateWithoutResponsesInput>
    where?: QuoteRequestWhereInput
  }

  export type QuoteRequestUpdateToOneWithWhereWithoutResponsesInput = {
    where?: QuoteRequestWhereInput
    data: XOR<QuoteRequestUpdateWithoutResponsesInput, QuoteRequestUncheckedUpdateWithoutResponsesInput>
  }

  export type QuoteRequestUpdateWithoutResponsesInput = {
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutQuoteRequestNestedInput
    approvedResponse?: QuoteResponseUpdateOneWithoutApprovedForNestedInput
    shipment?: ShipmentUpdateOneWithoutQuoteRequestNestedInput
  }

  export type QuoteRequestUncheckedUpdateWithoutResponsesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdByUserId?: IntFieldUpdateOperationsInput | number
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedResponseId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipment?: ShipmentUncheckedUpdateOneWithoutQuoteRequestNestedInput
  }

  export type VendorUpsertWithoutQuoteResponsesInput = {
    update: XOR<VendorUpdateWithoutQuoteResponsesInput, VendorUncheckedUpdateWithoutQuoteResponsesInput>
    create: XOR<VendorCreateWithoutQuoteResponsesInput, VendorUncheckedCreateWithoutQuoteResponsesInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutQuoteResponsesInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutQuoteResponsesInput, VendorUncheckedUpdateWithoutQuoteResponsesInput>
  }

  export type VendorUpdateWithoutQuoteResponsesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    baseRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutVendorsNestedInput
    profile?: VendorProfileUpdateOneWithoutVendorNestedInput
    agreements?: AgreementUpdateManyWithoutVendorNestedInput
    rateCards?: RateCardUpdateManyWithoutVendorNestedInput
    shipments?: ShipmentUpdateManyWithoutVendorNestedInput
    drivers?: DriverUpdateManyWithoutVendorNestedInput
    User?: UserUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutQuoteResponsesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    baseRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: VendorProfileUncheckedUpdateOneWithoutVendorNestedInput
    agreements?: AgreementUncheckedUpdateManyWithoutVendorNestedInput
    rateCards?: RateCardUncheckedUpdateManyWithoutVendorNestedInput
    shipments?: ShipmentUncheckedUpdateManyWithoutVendorNestedInput
    drivers?: DriverUncheckedUpdateManyWithoutVendorNestedInput
    User?: UserUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type ShipmentUpsertWithoutTransporterQuoteInput = {
    update: XOR<ShipmentUpdateWithoutTransporterQuoteInput, ShipmentUncheckedUpdateWithoutTransporterQuoteInput>
    create: XOR<ShipmentCreateWithoutTransporterQuoteInput, ShipmentUncheckedCreateWithoutTransporterQuoteInput>
    where?: ShipmentWhereInput
  }

  export type ShipmentUpdateToOneWithWhereWithoutTransporterQuoteInput = {
    where?: ShipmentWhereInput
    data: XOR<ShipmentUpdateWithoutTransporterQuoteInput, ShipmentUncheckedUpdateWithoutTransporterQuoteInput>
  }

  export type ShipmentUpdateWithoutTransporterQuoteInput = {
    agreementId?: NullableIntFieldUpdateOperationsInput | number | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedDriver?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    driverEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transporterResponseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ewayBillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstInvoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    source?: StringFieldUpdateOperationsInput | string
    podStatus?: StringFieldUpdateOperationsInput | string
    podUrl?: NullableStringFieldUpdateOperationsInput | string | null
    podNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutShipmentsNestedInput
    company?: CompanyUpdateOneWithoutShipmentsNestedInput
    quoteRequest?: QuoteRequestUpdateOneWithoutShipmentNestedInput
    rateCard?: RateCardUpdateOneWithoutShipmentsNestedInput
    vendor?: VendorUpdateOneWithoutShipmentsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedShipmentsNestedInput
    statusHistory?: StatusHistoryUpdateManyWithoutShipmentNestedInput
    complianceDocs?: ComplianceDocumentUpdateManyWithoutShipmentNestedInput
    payments?: PaymentUpdateManyWithoutShipmentNestedInput
    invoice?: InvoiceUpdateOneWithoutShipmentNestedInput
    consentLogs?: ConsentLogUpdateManyWithoutShipmentNestedInput
    transporterInvoices?: TransporterInvoiceUpdateManyWithoutShipmentNestedInput
  }

  export type ShipmentUncheckedUpdateWithoutTransporterQuoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    quoteRequestId?: NullableIntFieldUpdateOperationsInput | number | null
    selectedVendorId?: NullableIntFieldUpdateOperationsInput | number | null
    agreementId?: NullableIntFieldUpdateOperationsInput | number | null
    rateCardId?: NullableIntFieldUpdateOperationsInput | number | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedDriver?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    driverEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transporterResponseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ewayBillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstInvoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    source?: StringFieldUpdateOperationsInput | string
    podStatus?: StringFieldUpdateOperationsInput | string
    podUrl?: NullableStringFieldUpdateOperationsInput | string | null
    podNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusHistory?: StatusHistoryUncheckedUpdateManyWithoutShipmentNestedInput
    complianceDocs?: ComplianceDocumentUncheckedUpdateManyWithoutShipmentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutShipmentNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutShipmentNestedInput
    consentLogs?: ConsentLogUncheckedUpdateManyWithoutShipmentNestedInput
    transporterInvoices?: TransporterInvoiceUncheckedUpdateManyWithoutShipmentNestedInput
  }

  export type QuoteRequestUpsertWithoutApprovedResponseInput = {
    update: XOR<QuoteRequestUpdateWithoutApprovedResponseInput, QuoteRequestUncheckedUpdateWithoutApprovedResponseInput>
    create: XOR<QuoteRequestCreateWithoutApprovedResponseInput, QuoteRequestUncheckedCreateWithoutApprovedResponseInput>
    where?: QuoteRequestWhereInput
  }

  export type QuoteRequestUpdateToOneWithWhereWithoutApprovedResponseInput = {
    where?: QuoteRequestWhereInput
    data: XOR<QuoteRequestUpdateWithoutApprovedResponseInput, QuoteRequestUncheckedUpdateWithoutApprovedResponseInput>
  }

  export type QuoteRequestUpdateWithoutApprovedResponseInput = {
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutQuoteRequestNestedInput
    responses?: QuoteResponseUpdateManyWithoutQuoteRequestNestedInput
    shipment?: ShipmentUpdateOneWithoutQuoteRequestNestedInput
  }

  export type QuoteRequestUncheckedUpdateWithoutApprovedResponseInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdByUserId?: IntFieldUpdateOperationsInput | number
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: QuoteResponseUncheckedUpdateManyWithoutQuoteRequestNestedInput
    shipment?: ShipmentUncheckedUpdateOneWithoutQuoteRequestNestedInput
  }

  export type ConsentLogUpsertWithWhereUniqueWithoutQuoteResponseInput = {
    where: ConsentLogWhereUniqueInput
    update: XOR<ConsentLogUpdateWithoutQuoteResponseInput, ConsentLogUncheckedUpdateWithoutQuoteResponseInput>
    create: XOR<ConsentLogCreateWithoutQuoteResponseInput, ConsentLogUncheckedCreateWithoutQuoteResponseInput>
  }

  export type ConsentLogUpdateWithWhereUniqueWithoutQuoteResponseInput = {
    where: ConsentLogWhereUniqueInput
    data: XOR<ConsentLogUpdateWithoutQuoteResponseInput, ConsentLogUncheckedUpdateWithoutQuoteResponseInput>
  }

  export type ConsentLogUpdateManyWithWhereWithoutQuoteResponseInput = {
    where: ConsentLogScalarWhereInput
    data: XOR<ConsentLogUpdateManyMutationInput, ConsentLogUncheckedUpdateManyWithoutQuoteResponseInput>
  }

  export type ConsentLogScalarWhereInput = {
    AND?: ConsentLogScalarWhereInput | ConsentLogScalarWhereInput[]
    OR?: ConsentLogScalarWhereInput[]
    NOT?: ConsentLogScalarWhereInput | ConsentLogScalarWhereInput[]
    id?: IntFilter<"ConsentLog"> | number
    quoteResponseId?: IntFilter<"ConsentLog"> | number
    shipmentId?: IntNullableFilter<"ConsentLog"> | number | null
    statusBefore?: EnumConsentStatusFilter<"ConsentLog"> | $Enums.ConsentStatus
    statusAfter?: EnumConsentStatusFilter<"ConsentLog"> | $Enums.ConsentStatus
    note?: StringNullableFilter<"ConsentLog"> | string | null
    recordedAt?: DateTimeFilter<"ConsentLog"> | Date | string
  }

  export type QuoteResponseCreateWithoutConsentLogsInput = {
    quotedPrice?: number | null
    estimatedDelivery?: Date | string | null
    expiresAt?: Date | string | null
    status?: $Enums.QuoteResponseStatus
    consentStatus?: $Enums.ConsentStatus
    notes?: string | null
    transporterNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quoteRequest: QuoteRequestCreateNestedOneWithoutResponsesInput
    vendor: VendorCreateNestedOneWithoutQuoteResponsesInput
    shipment?: ShipmentCreateNestedOneWithoutTransporterQuoteInput
    approvedFor?: QuoteRequestCreateNestedOneWithoutApprovedResponseInput
  }

  export type QuoteResponseUncheckedCreateWithoutConsentLogsInput = {
    id?: number
    quoteRequestId: number
    vendorId: number
    quotedPrice?: number | null
    estimatedDelivery?: Date | string | null
    expiresAt?: Date | string | null
    status?: $Enums.QuoteResponseStatus
    consentStatus?: $Enums.ConsentStatus
    notes?: string | null
    transporterNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shipment?: ShipmentUncheckedCreateNestedOneWithoutTransporterQuoteInput
    approvedFor?: QuoteRequestUncheckedCreateNestedOneWithoutApprovedResponseInput
  }

  export type QuoteResponseCreateOrConnectWithoutConsentLogsInput = {
    where: QuoteResponseWhereUniqueInput
    create: XOR<QuoteResponseCreateWithoutConsentLogsInput, QuoteResponseUncheckedCreateWithoutConsentLogsInput>
  }

  export type ShipmentCreateWithoutConsentLogsInput = {
    agreementId?: number | null
    trackingNumber?: string | null
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.ShipmentStatus
    bookingStatus?: $Enums.BookingStatus | null
    paymentStatus?: $Enums.PaymentStatus | null
    cost?: number | null
    distance?: number | null
    estimatedDelivery?: Date | string | null
    pickupTime?: Date | string | null
    deliveryTime?: Date | string | null
    assignedDriver?: string | null
    driverPhone?: string | null
    driverEta?: Date | string | null
    transporterResponseNotes?: string | null
    notes?: string | null
    ewayBillNumber?: string | null
    gstInvoiceId?: number | null
    complianceStatus?: $Enums.ComplianceStatus
    source?: string
    podStatus?: string
    podUrl?: string | null
    podNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutShipmentsInput
    company?: CompanyCreateNestedOneWithoutShipmentsInput
    quoteRequest?: QuoteRequestCreateNestedOneWithoutShipmentInput
    transporterQuote?: QuoteResponseCreateNestedOneWithoutShipmentInput
    rateCard?: RateCardCreateNestedOneWithoutShipmentsInput
    vendor?: VendorCreateNestedOneWithoutShipmentsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedShipmentsInput
    statusHistory?: StatusHistoryCreateNestedManyWithoutShipmentInput
    complianceDocs?: ComplianceDocumentCreateNestedManyWithoutShipmentInput
    payments?: PaymentCreateNestedManyWithoutShipmentInput
    invoice?: InvoiceCreateNestedOneWithoutShipmentInput
    transporterInvoices?: TransporterInvoiceCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentUncheckedCreateWithoutConsentLogsInput = {
    id?: number
    userId: number
    companyId?: number | null
    quoteRequestId?: number | null
    transporterQuoteId?: number | null
    selectedVendorId?: number | null
    agreementId?: number | null
    rateCardId?: number | null
    trackingNumber?: string | null
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.ShipmentStatus
    bookingStatus?: $Enums.BookingStatus | null
    paymentStatus?: $Enums.PaymentStatus | null
    cost?: number | null
    distance?: number | null
    estimatedDelivery?: Date | string | null
    pickupTime?: Date | string | null
    deliveryTime?: Date | string | null
    assignedToId?: number | null
    assignedDriver?: string | null
    driverPhone?: string | null
    driverEta?: Date | string | null
    transporterResponseNotes?: string | null
    notes?: string | null
    ewayBillNumber?: string | null
    gstInvoiceId?: number | null
    complianceStatus?: $Enums.ComplianceStatus
    source?: string
    podStatus?: string
    podUrl?: string | null
    podNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    statusHistory?: StatusHistoryUncheckedCreateNestedManyWithoutShipmentInput
    complianceDocs?: ComplianceDocumentUncheckedCreateNestedManyWithoutShipmentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutShipmentInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutShipmentInput
    transporterInvoices?: TransporterInvoiceUncheckedCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentCreateOrConnectWithoutConsentLogsInput = {
    where: ShipmentWhereUniqueInput
    create: XOR<ShipmentCreateWithoutConsentLogsInput, ShipmentUncheckedCreateWithoutConsentLogsInput>
  }

  export type QuoteResponseUpsertWithoutConsentLogsInput = {
    update: XOR<QuoteResponseUpdateWithoutConsentLogsInput, QuoteResponseUncheckedUpdateWithoutConsentLogsInput>
    create: XOR<QuoteResponseCreateWithoutConsentLogsInput, QuoteResponseUncheckedCreateWithoutConsentLogsInput>
    where?: QuoteResponseWhereInput
  }

  export type QuoteResponseUpdateToOneWithWhereWithoutConsentLogsInput = {
    where?: QuoteResponseWhereInput
    data: XOR<QuoteResponseUpdateWithoutConsentLogsInput, QuoteResponseUncheckedUpdateWithoutConsentLogsInput>
  }

  export type QuoteResponseUpdateWithoutConsentLogsInput = {
    quotedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumQuoteResponseStatusFieldUpdateOperationsInput | $Enums.QuoteResponseStatus
    consentStatus?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    transporterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quoteRequest?: QuoteRequestUpdateOneRequiredWithoutResponsesNestedInput
    vendor?: VendorUpdateOneRequiredWithoutQuoteResponsesNestedInput
    shipment?: ShipmentUpdateOneWithoutTransporterQuoteNestedInput
    approvedFor?: QuoteRequestUpdateOneWithoutApprovedResponseNestedInput
  }

  export type QuoteResponseUncheckedUpdateWithoutConsentLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    quoteRequestId?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    quotedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumQuoteResponseStatusFieldUpdateOperationsInput | $Enums.QuoteResponseStatus
    consentStatus?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    transporterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipment?: ShipmentUncheckedUpdateOneWithoutTransporterQuoteNestedInput
    approvedFor?: QuoteRequestUncheckedUpdateOneWithoutApprovedResponseNestedInput
  }

  export type ShipmentUpsertWithoutConsentLogsInput = {
    update: XOR<ShipmentUpdateWithoutConsentLogsInput, ShipmentUncheckedUpdateWithoutConsentLogsInput>
    create: XOR<ShipmentCreateWithoutConsentLogsInput, ShipmentUncheckedCreateWithoutConsentLogsInput>
    where?: ShipmentWhereInput
  }

  export type ShipmentUpdateToOneWithWhereWithoutConsentLogsInput = {
    where?: ShipmentWhereInput
    data: XOR<ShipmentUpdateWithoutConsentLogsInput, ShipmentUncheckedUpdateWithoutConsentLogsInput>
  }

  export type ShipmentUpdateWithoutConsentLogsInput = {
    agreementId?: NullableIntFieldUpdateOperationsInput | number | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedDriver?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    driverEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transporterResponseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ewayBillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstInvoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    source?: StringFieldUpdateOperationsInput | string
    podStatus?: StringFieldUpdateOperationsInput | string
    podUrl?: NullableStringFieldUpdateOperationsInput | string | null
    podNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutShipmentsNestedInput
    company?: CompanyUpdateOneWithoutShipmentsNestedInput
    quoteRequest?: QuoteRequestUpdateOneWithoutShipmentNestedInput
    transporterQuote?: QuoteResponseUpdateOneWithoutShipmentNestedInput
    rateCard?: RateCardUpdateOneWithoutShipmentsNestedInput
    vendor?: VendorUpdateOneWithoutShipmentsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedShipmentsNestedInput
    statusHistory?: StatusHistoryUpdateManyWithoutShipmentNestedInput
    complianceDocs?: ComplianceDocumentUpdateManyWithoutShipmentNestedInput
    payments?: PaymentUpdateManyWithoutShipmentNestedInput
    invoice?: InvoiceUpdateOneWithoutShipmentNestedInput
    transporterInvoices?: TransporterInvoiceUpdateManyWithoutShipmentNestedInput
  }

  export type ShipmentUncheckedUpdateWithoutConsentLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    quoteRequestId?: NullableIntFieldUpdateOperationsInput | number | null
    transporterQuoteId?: NullableIntFieldUpdateOperationsInput | number | null
    selectedVendorId?: NullableIntFieldUpdateOperationsInput | number | null
    agreementId?: NullableIntFieldUpdateOperationsInput | number | null
    rateCardId?: NullableIntFieldUpdateOperationsInput | number | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedDriver?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    driverEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transporterResponseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ewayBillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstInvoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    source?: StringFieldUpdateOperationsInput | string
    podStatus?: StringFieldUpdateOperationsInput | string
    podUrl?: NullableStringFieldUpdateOperationsInput | string | null
    podNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusHistory?: StatusHistoryUncheckedUpdateManyWithoutShipmentNestedInput
    complianceDocs?: ComplianceDocumentUncheckedUpdateManyWithoutShipmentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutShipmentNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutShipmentNestedInput
    transporterInvoices?: TransporterInvoiceUncheckedUpdateManyWithoutShipmentNestedInput
  }

  export type UserCreateWithoutShipmentsInput = {
    email: string
    passwordHash: string
    name?: string | null
    phone?: string | null
    role?: $Enums.Role
    approvalStatus?: $Enums.ApprovalStatus
    approvalNote?: string | null
    rejectionReason?: string | null
    reviewedById?: number | null
    reviewedAt?: Date | string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorChannel?: string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutUsersInput
    vendor?: VendorCreateNestedOneWithoutUserInput
    assignedShipments?: ShipmentCreateNestedManyWithoutAssignedToInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    agreementsReviewed?: AgreementCreateNestedManyWithoutReviewedByInput
    transporterInvoices?: TransporterInvoiceCreateNestedManyWithoutApprovedByInput
    QuoteRequest?: QuoteRequestCreateNestedManyWithoutCreatedByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    twoFactorChallenges?: TwoFactorChallengeCreateNestedManyWithoutUserInput
    userConsents?: UserConsentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutShipmentsInput = {
    id?: number
    email: string
    passwordHash: string
    name?: string | null
    phone?: string | null
    role?: $Enums.Role
    approvalStatus?: $Enums.ApprovalStatus
    approvalNote?: string | null
    rejectionReason?: string | null
    reviewedById?: number | null
    reviewedAt?: Date | string | null
    isActive?: boolean
    vendorId?: number | null
    companyId?: number | null
    lastLoginAt?: Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorChannel?: string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedShipments?: ShipmentUncheckedCreateNestedManyWithoutAssignedToInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    agreementsReviewed?: AgreementUncheckedCreateNestedManyWithoutReviewedByInput
    transporterInvoices?: TransporterInvoiceUncheckedCreateNestedManyWithoutApprovedByInput
    QuoteRequest?: QuoteRequestUncheckedCreateNestedManyWithoutCreatedByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    twoFactorChallenges?: TwoFactorChallengeUncheckedCreateNestedManyWithoutUserInput
    userConsents?: UserConsentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutShipmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutShipmentsInput, UserUncheckedCreateWithoutShipmentsInput>
  }

  export type CompanyCreateWithoutShipmentsInput = {
    name: string
    webhookSecret: string
    plan?: string
    subscriptionStatus?: string
    billingEmail?: string | null
    billingCustomerId?: string | null
    trialEndsAt?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    agreements?: AgreementCreateNestedManyWithoutCompanyInput
    transporterInvoices?: TransporterInvoiceCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    profiles?: CompanyProfileCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutShipmentsInput = {
    id?: number
    name: string
    webhookSecret: string
    plan?: string
    subscriptionStatus?: string
    billingEmail?: string | null
    billingCustomerId?: string | null
    trialEndsAt?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    agreements?: AgreementUncheckedCreateNestedManyWithoutCompanyInput
    transporterInvoices?: TransporterInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    profiles?: CompanyProfileUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutShipmentsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutShipmentsInput, CompanyUncheckedCreateWithoutShipmentsInput>
  }

  export type QuoteRequestCreateWithoutShipmentInput = {
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.QuoteStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutQuoteRequestInput
    responses?: QuoteResponseCreateNestedManyWithoutQuoteRequestInput
    approvedResponse?: QuoteResponseCreateNestedOneWithoutApprovedForInput
  }

  export type QuoteRequestUncheckedCreateWithoutShipmentInput = {
    id?: number
    createdByUserId: number
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.QuoteStatus
    notes?: string | null
    approvedResponseId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: QuoteResponseUncheckedCreateNestedManyWithoutQuoteRequestInput
  }

  export type QuoteRequestCreateOrConnectWithoutShipmentInput = {
    where: QuoteRequestWhereUniqueInput
    create: XOR<QuoteRequestCreateWithoutShipmentInput, QuoteRequestUncheckedCreateWithoutShipmentInput>
  }

  export type QuoteResponseCreateWithoutShipmentInput = {
    quotedPrice?: number | null
    estimatedDelivery?: Date | string | null
    expiresAt?: Date | string | null
    status?: $Enums.QuoteResponseStatus
    consentStatus?: $Enums.ConsentStatus
    notes?: string | null
    transporterNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quoteRequest: QuoteRequestCreateNestedOneWithoutResponsesInput
    vendor: VendorCreateNestedOneWithoutQuoteResponsesInput
    approvedFor?: QuoteRequestCreateNestedOneWithoutApprovedResponseInput
    consentLogs?: ConsentLogCreateNestedManyWithoutQuoteResponseInput
  }

  export type QuoteResponseUncheckedCreateWithoutShipmentInput = {
    id?: number
    quoteRequestId: number
    vendorId: number
    quotedPrice?: number | null
    estimatedDelivery?: Date | string | null
    expiresAt?: Date | string | null
    status?: $Enums.QuoteResponseStatus
    consentStatus?: $Enums.ConsentStatus
    notes?: string | null
    transporterNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedFor?: QuoteRequestUncheckedCreateNestedOneWithoutApprovedResponseInput
    consentLogs?: ConsentLogUncheckedCreateNestedManyWithoutQuoteResponseInput
  }

  export type QuoteResponseCreateOrConnectWithoutShipmentInput = {
    where: QuoteResponseWhereUniqueInput
    create: XOR<QuoteResponseCreateWithoutShipmentInput, QuoteResponseUncheckedCreateWithoutShipmentInput>
  }

  export type RateCardCreateWithoutShipmentsInput = {
    routeName: string
    origin: string
    destination: string
    distanceKm?: number | null
    ratePerKm: number
    uom: string
    vehicleType: string
    effectiveFrom?: Date | string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agreement: AgreementCreateNestedOneWithoutRateCardsInput
    Vendor?: VendorCreateNestedOneWithoutRateCardsInput
  }

  export type RateCardUncheckedCreateWithoutShipmentsInput = {
    id?: number
    agreementId: number
    routeName: string
    origin: string
    destination: string
    distanceKm?: number | null
    ratePerKm: number
    uom: string
    vehicleType: string
    effectiveFrom?: Date | string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendorId?: number | null
  }

  export type RateCardCreateOrConnectWithoutShipmentsInput = {
    where: RateCardWhereUniqueInput
    create: XOR<RateCardCreateWithoutShipmentsInput, RateCardUncheckedCreateWithoutShipmentsInput>
  }

  export type VendorCreateWithoutShipmentsInput = {
    name: string
    email?: string | null
    phone?: string | null
    baseRate?: number | null
    rating?: number | null
    speed?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutVendorsInput
    profile?: VendorProfileCreateNestedOneWithoutVendorInput
    agreements?: AgreementCreateNestedManyWithoutVendorInput
    rateCards?: RateCardCreateNestedManyWithoutVendorInput
    quoteResponses?: QuoteResponseCreateNestedManyWithoutVendorInput
    drivers?: DriverCreateNestedManyWithoutVendorInput
    User?: UserCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutShipmentsInput = {
    id?: number
    name: string
    email?: string | null
    phone?: string | null
    baseRate?: number | null
    rating?: number | null
    speed?: number | null
    isActive?: boolean
    companyId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: VendorProfileUncheckedCreateNestedOneWithoutVendorInput
    agreements?: AgreementUncheckedCreateNestedManyWithoutVendorInput
    rateCards?: RateCardUncheckedCreateNestedManyWithoutVendorInput
    quoteResponses?: QuoteResponseUncheckedCreateNestedManyWithoutVendorInput
    drivers?: DriverUncheckedCreateNestedManyWithoutVendorInput
    User?: UserUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutShipmentsInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutShipmentsInput, VendorUncheckedCreateWithoutShipmentsInput>
  }

  export type UserCreateWithoutAssignedShipmentsInput = {
    email: string
    passwordHash: string
    name?: string | null
    phone?: string | null
    role?: $Enums.Role
    approvalStatus?: $Enums.ApprovalStatus
    approvalNote?: string | null
    rejectionReason?: string | null
    reviewedById?: number | null
    reviewedAt?: Date | string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorChannel?: string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutUsersInput
    vendor?: VendorCreateNestedOneWithoutUserInput
    shipments?: ShipmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    agreementsReviewed?: AgreementCreateNestedManyWithoutReviewedByInput
    transporterInvoices?: TransporterInvoiceCreateNestedManyWithoutApprovedByInput
    QuoteRequest?: QuoteRequestCreateNestedManyWithoutCreatedByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    twoFactorChallenges?: TwoFactorChallengeCreateNestedManyWithoutUserInput
    userConsents?: UserConsentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssignedShipmentsInput = {
    id?: number
    email: string
    passwordHash: string
    name?: string | null
    phone?: string | null
    role?: $Enums.Role
    approvalStatus?: $Enums.ApprovalStatus
    approvalNote?: string | null
    rejectionReason?: string | null
    reviewedById?: number | null
    reviewedAt?: Date | string | null
    isActive?: boolean
    vendorId?: number | null
    companyId?: number | null
    lastLoginAt?: Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorChannel?: string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    shipments?: ShipmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    agreementsReviewed?: AgreementUncheckedCreateNestedManyWithoutReviewedByInput
    transporterInvoices?: TransporterInvoiceUncheckedCreateNestedManyWithoutApprovedByInput
    QuoteRequest?: QuoteRequestUncheckedCreateNestedManyWithoutCreatedByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    twoFactorChallenges?: TwoFactorChallengeUncheckedCreateNestedManyWithoutUserInput
    userConsents?: UserConsentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssignedShipmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedShipmentsInput, UserUncheckedCreateWithoutAssignedShipmentsInput>
  }

  export type StatusHistoryCreateWithoutShipmentInput = {
    status: $Enums.ShipmentStatus
    notes?: string | null
    latitude?: number | null
    longitude?: number | null
    location?: string | null
    updatedBy?: number | null
    timestamp?: Date | string
  }

  export type StatusHistoryUncheckedCreateWithoutShipmentInput = {
    id?: number
    status: $Enums.ShipmentStatus
    notes?: string | null
    latitude?: number | null
    longitude?: number | null
    location?: string | null
    updatedBy?: number | null
    timestamp?: Date | string
  }

  export type StatusHistoryCreateOrConnectWithoutShipmentInput = {
    where: StatusHistoryWhereUniqueInput
    create: XOR<StatusHistoryCreateWithoutShipmentInput, StatusHistoryUncheckedCreateWithoutShipmentInput>
  }

  export type StatusHistoryCreateManyShipmentInputEnvelope = {
    data: StatusHistoryCreateManyShipmentInput | StatusHistoryCreateManyShipmentInput[]
    skipDuplicates?: boolean
  }

  export type ComplianceDocumentCreateWithoutShipmentInput = {
    type: $Enums.DocumentType
    status?: $Enums.ComplianceStatus
    issuedAt?: Date | string | null
    fileUrl?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: ComplianceEventCreateNestedManyWithoutDocumentInput
  }

  export type ComplianceDocumentUncheckedCreateWithoutShipmentInput = {
    id?: number
    type: $Enums.DocumentType
    status?: $Enums.ComplianceStatus
    issuedAt?: Date | string | null
    fileUrl?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: ComplianceEventUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type ComplianceDocumentCreateOrConnectWithoutShipmentInput = {
    where: ComplianceDocumentWhereUniqueInput
    create: XOR<ComplianceDocumentCreateWithoutShipmentInput, ComplianceDocumentUncheckedCreateWithoutShipmentInput>
  }

  export type ComplianceDocumentCreateManyShipmentInputEnvelope = {
    data: ComplianceDocumentCreateManyShipmentInput | ComplianceDocumentCreateManyShipmentInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutShipmentInput = {
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    gateway?: string
    transactionRef?: string | null
    authorizedAt?: Date | string | null
    capturedAt?: Date | string | null
    failureReason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tdsAmount?: number | null
    tcsAmount?: number | null
    rcmLiability?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutPaymentsInput
    events?: PaymentEventCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutShipmentInput = {
    id?: number
    invoiceId: number
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    gateway?: string
    transactionRef?: string | null
    authorizedAt?: Date | string | null
    capturedAt?: Date | string | null
    failureReason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tdsAmount?: number | null
    tcsAmount?: number | null
    rcmLiability?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: PaymentEventUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutShipmentInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutShipmentInput, PaymentUncheckedCreateWithoutShipmentInput>
  }

  export type PaymentCreateManyShipmentInputEnvelope = {
    data: PaymentCreateManyShipmentInput | PaymentCreateManyShipmentInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutShipmentInput = {
    invoiceNumber: string
    status?: $Enums.InvoiceStatus
    issuedAt?: Date | string | null
    dueDate?: Date | string | null
    subtotal?: number
    taxTotal?: number
    grandTotal?: number
    lineItems: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    Company?: CompanyCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutShipmentInput = {
    id?: number
    invoiceNumber: string
    status?: $Enums.InvoiceStatus
    issuedAt?: Date | string | null
    dueDate?: Date | string | null
    subtotal?: number
    taxTotal?: number
    grandTotal?: number
    lineItems: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: number | null
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutShipmentInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutShipmentInput, InvoiceUncheckedCreateWithoutShipmentInput>
  }

  export type ConsentLogCreateWithoutShipmentInput = {
    statusBefore: $Enums.ConsentStatus
    statusAfter: $Enums.ConsentStatus
    note?: string | null
    recordedAt?: Date | string
    quoteResponse: QuoteResponseCreateNestedOneWithoutConsentLogsInput
  }

  export type ConsentLogUncheckedCreateWithoutShipmentInput = {
    id?: number
    quoteResponseId: number
    statusBefore: $Enums.ConsentStatus
    statusAfter: $Enums.ConsentStatus
    note?: string | null
    recordedAt?: Date | string
  }

  export type ConsentLogCreateOrConnectWithoutShipmentInput = {
    where: ConsentLogWhereUniqueInput
    create: XOR<ConsentLogCreateWithoutShipmentInput, ConsentLogUncheckedCreateWithoutShipmentInput>
  }

  export type ConsentLogCreateManyShipmentInputEnvelope = {
    data: ConsentLogCreateManyShipmentInput | ConsentLogCreateManyShipmentInput[]
    skipDuplicates?: boolean
  }

  export type TransporterInvoiceCreateWithoutShipmentInput = {
    invoiceNumber: string
    invoiceDate: Date | string
    invoiceAmount: number
    invoiceUrl: string
    approvalStatus?: string
    rejectionNotes?: string | null
    postedToErpAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutTransporterInvoicesInput
    approvedBy?: UserCreateNestedOneWithoutTransporterInvoicesInput
  }

  export type TransporterInvoiceUncheckedCreateWithoutShipmentInput = {
    id?: number
    companyId: number
    invoiceNumber: string
    invoiceDate: Date | string
    invoiceAmount: number
    invoiceUrl: string
    approvalStatus?: string
    rejectionNotes?: string | null
    postedToErpAt?: Date | string | null
    approvedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransporterInvoiceCreateOrConnectWithoutShipmentInput = {
    where: TransporterInvoiceWhereUniqueInput
    create: XOR<TransporterInvoiceCreateWithoutShipmentInput, TransporterInvoiceUncheckedCreateWithoutShipmentInput>
  }

  export type TransporterInvoiceCreateManyShipmentInputEnvelope = {
    data: TransporterInvoiceCreateManyShipmentInput | TransporterInvoiceCreateManyShipmentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutShipmentsInput = {
    update: XOR<UserUpdateWithoutShipmentsInput, UserUncheckedUpdateWithoutShipmentsInput>
    create: XOR<UserCreateWithoutShipmentsInput, UserUncheckedCreateWithoutShipmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutShipmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutShipmentsInput, UserUncheckedUpdateWithoutShipmentsInput>
  }

  export type UserUpdateWithoutShipmentsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorChannel?: NullableStringFieldUpdateOperationsInput | string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutUsersNestedInput
    vendor?: VendorUpdateOneWithoutUserNestedInput
    assignedShipments?: ShipmentUpdateManyWithoutAssignedToNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    agreementsReviewed?: AgreementUpdateManyWithoutReviewedByNestedInput
    transporterInvoices?: TransporterInvoiceUpdateManyWithoutApprovedByNestedInput
    QuoteRequest?: QuoteRequestUpdateManyWithoutCreatedByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    twoFactorChallenges?: TwoFactorChallengeUpdateManyWithoutUserNestedInput
    userConsents?: UserConsentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutShipmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorChannel?: NullableStringFieldUpdateOperationsInput | string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedShipments?: ShipmentUncheckedUpdateManyWithoutAssignedToNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    agreementsReviewed?: AgreementUncheckedUpdateManyWithoutReviewedByNestedInput
    transporterInvoices?: TransporterInvoiceUncheckedUpdateManyWithoutApprovedByNestedInput
    QuoteRequest?: QuoteRequestUncheckedUpdateManyWithoutCreatedByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    twoFactorChallenges?: TwoFactorChallengeUncheckedUpdateManyWithoutUserNestedInput
    userConsents?: UserConsentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CompanyUpsertWithoutShipmentsInput = {
    update: XOR<CompanyUpdateWithoutShipmentsInput, CompanyUncheckedUpdateWithoutShipmentsInput>
    create: XOR<CompanyCreateWithoutShipmentsInput, CompanyUncheckedCreateWithoutShipmentsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutShipmentsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutShipmentsInput, CompanyUncheckedUpdateWithoutShipmentsInput>
  }

  export type CompanyUpdateWithoutShipmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    webhookSecret?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    billingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    billingCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    agreements?: AgreementUpdateManyWithoutCompanyNestedInput
    transporterInvoices?: TransporterInvoiceUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    profiles?: CompanyProfileUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutShipmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    webhookSecret?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    billingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    billingCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    agreements?: AgreementUncheckedUpdateManyWithoutCompanyNestedInput
    transporterInvoices?: TransporterInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    profiles?: CompanyProfileUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type QuoteRequestUpsertWithoutShipmentInput = {
    update: XOR<QuoteRequestUpdateWithoutShipmentInput, QuoteRequestUncheckedUpdateWithoutShipmentInput>
    create: XOR<QuoteRequestCreateWithoutShipmentInput, QuoteRequestUncheckedCreateWithoutShipmentInput>
    where?: QuoteRequestWhereInput
  }

  export type QuoteRequestUpdateToOneWithWhereWithoutShipmentInput = {
    where?: QuoteRequestWhereInput
    data: XOR<QuoteRequestUpdateWithoutShipmentInput, QuoteRequestUncheckedUpdateWithoutShipmentInput>
  }

  export type QuoteRequestUpdateWithoutShipmentInput = {
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutQuoteRequestNestedInput
    responses?: QuoteResponseUpdateManyWithoutQuoteRequestNestedInput
    approvedResponse?: QuoteResponseUpdateOneWithoutApprovedForNestedInput
  }

  export type QuoteRequestUncheckedUpdateWithoutShipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdByUserId?: IntFieldUpdateOperationsInput | number
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedResponseId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: QuoteResponseUncheckedUpdateManyWithoutQuoteRequestNestedInput
  }

  export type QuoteResponseUpsertWithoutShipmentInput = {
    update: XOR<QuoteResponseUpdateWithoutShipmentInput, QuoteResponseUncheckedUpdateWithoutShipmentInput>
    create: XOR<QuoteResponseCreateWithoutShipmentInput, QuoteResponseUncheckedCreateWithoutShipmentInput>
    where?: QuoteResponseWhereInput
  }

  export type QuoteResponseUpdateToOneWithWhereWithoutShipmentInput = {
    where?: QuoteResponseWhereInput
    data: XOR<QuoteResponseUpdateWithoutShipmentInput, QuoteResponseUncheckedUpdateWithoutShipmentInput>
  }

  export type QuoteResponseUpdateWithoutShipmentInput = {
    quotedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumQuoteResponseStatusFieldUpdateOperationsInput | $Enums.QuoteResponseStatus
    consentStatus?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    transporterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quoteRequest?: QuoteRequestUpdateOneRequiredWithoutResponsesNestedInput
    vendor?: VendorUpdateOneRequiredWithoutQuoteResponsesNestedInput
    approvedFor?: QuoteRequestUpdateOneWithoutApprovedResponseNestedInput
    consentLogs?: ConsentLogUpdateManyWithoutQuoteResponseNestedInput
  }

  export type QuoteResponseUncheckedUpdateWithoutShipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    quoteRequestId?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    quotedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumQuoteResponseStatusFieldUpdateOperationsInput | $Enums.QuoteResponseStatus
    consentStatus?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    transporterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedFor?: QuoteRequestUncheckedUpdateOneWithoutApprovedResponseNestedInput
    consentLogs?: ConsentLogUncheckedUpdateManyWithoutQuoteResponseNestedInput
  }

  export type RateCardUpsertWithoutShipmentsInput = {
    update: XOR<RateCardUpdateWithoutShipmentsInput, RateCardUncheckedUpdateWithoutShipmentsInput>
    create: XOR<RateCardCreateWithoutShipmentsInput, RateCardUncheckedCreateWithoutShipmentsInput>
    where?: RateCardWhereInput
  }

  export type RateCardUpdateToOneWithWhereWithoutShipmentsInput = {
    where?: RateCardWhereInput
    data: XOR<RateCardUpdateWithoutShipmentsInput, RateCardUncheckedUpdateWithoutShipmentsInput>
  }

  export type RateCardUpdateWithoutShipmentsInput = {
    routeName?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    distanceKm?: NullableFloatFieldUpdateOperationsInput | number | null
    ratePerKm?: FloatFieldUpdateOperationsInput | number
    uom?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agreement?: AgreementUpdateOneRequiredWithoutRateCardsNestedInput
    Vendor?: VendorUpdateOneWithoutRateCardsNestedInput
  }

  export type RateCardUncheckedUpdateWithoutShipmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    agreementId?: IntFieldUpdateOperationsInput | number
    routeName?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    distanceKm?: NullableFloatFieldUpdateOperationsInput | number | null
    ratePerKm?: FloatFieldUpdateOperationsInput | number
    uom?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VendorUpsertWithoutShipmentsInput = {
    update: XOR<VendorUpdateWithoutShipmentsInput, VendorUncheckedUpdateWithoutShipmentsInput>
    create: XOR<VendorCreateWithoutShipmentsInput, VendorUncheckedCreateWithoutShipmentsInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutShipmentsInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutShipmentsInput, VendorUncheckedUpdateWithoutShipmentsInput>
  }

  export type VendorUpdateWithoutShipmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    baseRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutVendorsNestedInput
    profile?: VendorProfileUpdateOneWithoutVendorNestedInput
    agreements?: AgreementUpdateManyWithoutVendorNestedInput
    rateCards?: RateCardUpdateManyWithoutVendorNestedInput
    quoteResponses?: QuoteResponseUpdateManyWithoutVendorNestedInput
    drivers?: DriverUpdateManyWithoutVendorNestedInput
    User?: UserUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutShipmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    baseRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: VendorProfileUncheckedUpdateOneWithoutVendorNestedInput
    agreements?: AgreementUncheckedUpdateManyWithoutVendorNestedInput
    rateCards?: RateCardUncheckedUpdateManyWithoutVendorNestedInput
    quoteResponses?: QuoteResponseUncheckedUpdateManyWithoutVendorNestedInput
    drivers?: DriverUncheckedUpdateManyWithoutVendorNestedInput
    User?: UserUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type UserUpsertWithoutAssignedShipmentsInput = {
    update: XOR<UserUpdateWithoutAssignedShipmentsInput, UserUncheckedUpdateWithoutAssignedShipmentsInput>
    create: XOR<UserCreateWithoutAssignedShipmentsInput, UserUncheckedCreateWithoutAssignedShipmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedShipmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedShipmentsInput, UserUncheckedUpdateWithoutAssignedShipmentsInput>
  }

  export type UserUpdateWithoutAssignedShipmentsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorChannel?: NullableStringFieldUpdateOperationsInput | string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutUsersNestedInput
    vendor?: VendorUpdateOneWithoutUserNestedInput
    shipments?: ShipmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    agreementsReviewed?: AgreementUpdateManyWithoutReviewedByNestedInput
    transporterInvoices?: TransporterInvoiceUpdateManyWithoutApprovedByNestedInput
    QuoteRequest?: QuoteRequestUpdateManyWithoutCreatedByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    twoFactorChallenges?: TwoFactorChallengeUpdateManyWithoutUserNestedInput
    userConsents?: UserConsentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedShipmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorChannel?: NullableStringFieldUpdateOperationsInput | string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipments?: ShipmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    agreementsReviewed?: AgreementUncheckedUpdateManyWithoutReviewedByNestedInput
    transporterInvoices?: TransporterInvoiceUncheckedUpdateManyWithoutApprovedByNestedInput
    QuoteRequest?: QuoteRequestUncheckedUpdateManyWithoutCreatedByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    twoFactorChallenges?: TwoFactorChallengeUncheckedUpdateManyWithoutUserNestedInput
    userConsents?: UserConsentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StatusHistoryUpsertWithWhereUniqueWithoutShipmentInput = {
    where: StatusHistoryWhereUniqueInput
    update: XOR<StatusHistoryUpdateWithoutShipmentInput, StatusHistoryUncheckedUpdateWithoutShipmentInput>
    create: XOR<StatusHistoryCreateWithoutShipmentInput, StatusHistoryUncheckedCreateWithoutShipmentInput>
  }

  export type StatusHistoryUpdateWithWhereUniqueWithoutShipmentInput = {
    where: StatusHistoryWhereUniqueInput
    data: XOR<StatusHistoryUpdateWithoutShipmentInput, StatusHistoryUncheckedUpdateWithoutShipmentInput>
  }

  export type StatusHistoryUpdateManyWithWhereWithoutShipmentInput = {
    where: StatusHistoryScalarWhereInput
    data: XOR<StatusHistoryUpdateManyMutationInput, StatusHistoryUncheckedUpdateManyWithoutShipmentInput>
  }

  export type StatusHistoryScalarWhereInput = {
    AND?: StatusHistoryScalarWhereInput | StatusHistoryScalarWhereInput[]
    OR?: StatusHistoryScalarWhereInput[]
    NOT?: StatusHistoryScalarWhereInput | StatusHistoryScalarWhereInput[]
    id?: IntFilter<"StatusHistory"> | number
    shipmentId?: IntFilter<"StatusHistory"> | number
    status?: EnumShipmentStatusFilter<"StatusHistory"> | $Enums.ShipmentStatus
    notes?: StringNullableFilter<"StatusHistory"> | string | null
    latitude?: FloatNullableFilter<"StatusHistory"> | number | null
    longitude?: FloatNullableFilter<"StatusHistory"> | number | null
    location?: StringNullableFilter<"StatusHistory"> | string | null
    updatedBy?: IntNullableFilter<"StatusHistory"> | number | null
    timestamp?: DateTimeFilter<"StatusHistory"> | Date | string
  }

  export type ComplianceDocumentUpsertWithWhereUniqueWithoutShipmentInput = {
    where: ComplianceDocumentWhereUniqueInput
    update: XOR<ComplianceDocumentUpdateWithoutShipmentInput, ComplianceDocumentUncheckedUpdateWithoutShipmentInput>
    create: XOR<ComplianceDocumentCreateWithoutShipmentInput, ComplianceDocumentUncheckedCreateWithoutShipmentInput>
  }

  export type ComplianceDocumentUpdateWithWhereUniqueWithoutShipmentInput = {
    where: ComplianceDocumentWhereUniqueInput
    data: XOR<ComplianceDocumentUpdateWithoutShipmentInput, ComplianceDocumentUncheckedUpdateWithoutShipmentInput>
  }

  export type ComplianceDocumentUpdateManyWithWhereWithoutShipmentInput = {
    where: ComplianceDocumentScalarWhereInput
    data: XOR<ComplianceDocumentUpdateManyMutationInput, ComplianceDocumentUncheckedUpdateManyWithoutShipmentInput>
  }

  export type ComplianceDocumentScalarWhereInput = {
    AND?: ComplianceDocumentScalarWhereInput | ComplianceDocumentScalarWhereInput[]
    OR?: ComplianceDocumentScalarWhereInput[]
    NOT?: ComplianceDocumentScalarWhereInput | ComplianceDocumentScalarWhereInput[]
    id?: IntFilter<"ComplianceDocument"> | number
    shipmentId?: IntFilter<"ComplianceDocument"> | number
    type?: EnumDocumentTypeFilter<"ComplianceDocument"> | $Enums.DocumentType
    status?: EnumComplianceStatusFilter<"ComplianceDocument"> | $Enums.ComplianceStatus
    issuedAt?: DateTimeNullableFilter<"ComplianceDocument"> | Date | string | null
    fileUrl?: StringNullableFilter<"ComplianceDocument"> | string | null
    payload?: JsonNullableFilter<"ComplianceDocument">
    metadata?: JsonNullableFilter<"ComplianceDocument">
    remarks?: StringNullableFilter<"ComplianceDocument"> | string | null
    createdAt?: DateTimeFilter<"ComplianceDocument"> | Date | string
    updatedAt?: DateTimeFilter<"ComplianceDocument"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutShipmentInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutShipmentInput, PaymentUncheckedUpdateWithoutShipmentInput>
    create: XOR<PaymentCreateWithoutShipmentInput, PaymentUncheckedCreateWithoutShipmentInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutShipmentInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutShipmentInput, PaymentUncheckedUpdateWithoutShipmentInput>
  }

  export type PaymentUpdateManyWithWhereWithoutShipmentInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutShipmentInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: IntFilter<"Payment"> | number
    shipmentId?: IntFilter<"Payment"> | number
    invoiceId?: IntFilter<"Payment"> | number
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    gateway?: StringFilter<"Payment"> | string
    transactionRef?: StringNullableFilter<"Payment"> | string | null
    authorizedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    capturedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    failureReason?: StringNullableFilter<"Payment"> | string | null
    metadata?: JsonNullableFilter<"Payment">
    tdsAmount?: FloatNullableFilter<"Payment"> | number | null
    tcsAmount?: FloatNullableFilter<"Payment"> | number | null
    rcmLiability?: FloatNullableFilter<"Payment"> | number | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type InvoiceUpsertWithoutShipmentInput = {
    update: XOR<InvoiceUpdateWithoutShipmentInput, InvoiceUncheckedUpdateWithoutShipmentInput>
    create: XOR<InvoiceCreateWithoutShipmentInput, InvoiceUncheckedCreateWithoutShipmentInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutShipmentInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutShipmentInput, InvoiceUncheckedUpdateWithoutShipmentInput>
  }

  export type InvoiceUpdateWithoutShipmentInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxTotal?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    lineItems?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    Company?: CompanyUpdateOneWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutShipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxTotal?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    lineItems?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type ConsentLogUpsertWithWhereUniqueWithoutShipmentInput = {
    where: ConsentLogWhereUniqueInput
    update: XOR<ConsentLogUpdateWithoutShipmentInput, ConsentLogUncheckedUpdateWithoutShipmentInput>
    create: XOR<ConsentLogCreateWithoutShipmentInput, ConsentLogUncheckedCreateWithoutShipmentInput>
  }

  export type ConsentLogUpdateWithWhereUniqueWithoutShipmentInput = {
    where: ConsentLogWhereUniqueInput
    data: XOR<ConsentLogUpdateWithoutShipmentInput, ConsentLogUncheckedUpdateWithoutShipmentInput>
  }

  export type ConsentLogUpdateManyWithWhereWithoutShipmentInput = {
    where: ConsentLogScalarWhereInput
    data: XOR<ConsentLogUpdateManyMutationInput, ConsentLogUncheckedUpdateManyWithoutShipmentInput>
  }

  export type TransporterInvoiceUpsertWithWhereUniqueWithoutShipmentInput = {
    where: TransporterInvoiceWhereUniqueInput
    update: XOR<TransporterInvoiceUpdateWithoutShipmentInput, TransporterInvoiceUncheckedUpdateWithoutShipmentInput>
    create: XOR<TransporterInvoiceCreateWithoutShipmentInput, TransporterInvoiceUncheckedCreateWithoutShipmentInput>
  }

  export type TransporterInvoiceUpdateWithWhereUniqueWithoutShipmentInput = {
    where: TransporterInvoiceWhereUniqueInput
    data: XOR<TransporterInvoiceUpdateWithoutShipmentInput, TransporterInvoiceUncheckedUpdateWithoutShipmentInput>
  }

  export type TransporterInvoiceUpdateManyWithWhereWithoutShipmentInput = {
    where: TransporterInvoiceScalarWhereInput
    data: XOR<TransporterInvoiceUpdateManyMutationInput, TransporterInvoiceUncheckedUpdateManyWithoutShipmentInput>
  }

  export type ShipmentCreateWithoutStatusHistoryInput = {
    agreementId?: number | null
    trackingNumber?: string | null
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.ShipmentStatus
    bookingStatus?: $Enums.BookingStatus | null
    paymentStatus?: $Enums.PaymentStatus | null
    cost?: number | null
    distance?: number | null
    estimatedDelivery?: Date | string | null
    pickupTime?: Date | string | null
    deliveryTime?: Date | string | null
    assignedDriver?: string | null
    driverPhone?: string | null
    driverEta?: Date | string | null
    transporterResponseNotes?: string | null
    notes?: string | null
    ewayBillNumber?: string | null
    gstInvoiceId?: number | null
    complianceStatus?: $Enums.ComplianceStatus
    source?: string
    podStatus?: string
    podUrl?: string | null
    podNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutShipmentsInput
    company?: CompanyCreateNestedOneWithoutShipmentsInput
    quoteRequest?: QuoteRequestCreateNestedOneWithoutShipmentInput
    transporterQuote?: QuoteResponseCreateNestedOneWithoutShipmentInput
    rateCard?: RateCardCreateNestedOneWithoutShipmentsInput
    vendor?: VendorCreateNestedOneWithoutShipmentsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedShipmentsInput
    complianceDocs?: ComplianceDocumentCreateNestedManyWithoutShipmentInput
    payments?: PaymentCreateNestedManyWithoutShipmentInput
    invoice?: InvoiceCreateNestedOneWithoutShipmentInput
    consentLogs?: ConsentLogCreateNestedManyWithoutShipmentInput
    transporterInvoices?: TransporterInvoiceCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentUncheckedCreateWithoutStatusHistoryInput = {
    id?: number
    userId: number
    companyId?: number | null
    quoteRequestId?: number | null
    transporterQuoteId?: number | null
    selectedVendorId?: number | null
    agreementId?: number | null
    rateCardId?: number | null
    trackingNumber?: string | null
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.ShipmentStatus
    bookingStatus?: $Enums.BookingStatus | null
    paymentStatus?: $Enums.PaymentStatus | null
    cost?: number | null
    distance?: number | null
    estimatedDelivery?: Date | string | null
    pickupTime?: Date | string | null
    deliveryTime?: Date | string | null
    assignedToId?: number | null
    assignedDriver?: string | null
    driverPhone?: string | null
    driverEta?: Date | string | null
    transporterResponseNotes?: string | null
    notes?: string | null
    ewayBillNumber?: string | null
    gstInvoiceId?: number | null
    complianceStatus?: $Enums.ComplianceStatus
    source?: string
    podStatus?: string
    podUrl?: string | null
    podNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    complianceDocs?: ComplianceDocumentUncheckedCreateNestedManyWithoutShipmentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutShipmentInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutShipmentInput
    consentLogs?: ConsentLogUncheckedCreateNestedManyWithoutShipmentInput
    transporterInvoices?: TransporterInvoiceUncheckedCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentCreateOrConnectWithoutStatusHistoryInput = {
    where: ShipmentWhereUniqueInput
    create: XOR<ShipmentCreateWithoutStatusHistoryInput, ShipmentUncheckedCreateWithoutStatusHistoryInput>
  }

  export type ShipmentUpsertWithoutStatusHistoryInput = {
    update: XOR<ShipmentUpdateWithoutStatusHistoryInput, ShipmentUncheckedUpdateWithoutStatusHistoryInput>
    create: XOR<ShipmentCreateWithoutStatusHistoryInput, ShipmentUncheckedCreateWithoutStatusHistoryInput>
    where?: ShipmentWhereInput
  }

  export type ShipmentUpdateToOneWithWhereWithoutStatusHistoryInput = {
    where?: ShipmentWhereInput
    data: XOR<ShipmentUpdateWithoutStatusHistoryInput, ShipmentUncheckedUpdateWithoutStatusHistoryInput>
  }

  export type ShipmentUpdateWithoutStatusHistoryInput = {
    agreementId?: NullableIntFieldUpdateOperationsInput | number | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedDriver?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    driverEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transporterResponseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ewayBillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstInvoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    source?: StringFieldUpdateOperationsInput | string
    podStatus?: StringFieldUpdateOperationsInput | string
    podUrl?: NullableStringFieldUpdateOperationsInput | string | null
    podNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutShipmentsNestedInput
    company?: CompanyUpdateOneWithoutShipmentsNestedInput
    quoteRequest?: QuoteRequestUpdateOneWithoutShipmentNestedInput
    transporterQuote?: QuoteResponseUpdateOneWithoutShipmentNestedInput
    rateCard?: RateCardUpdateOneWithoutShipmentsNestedInput
    vendor?: VendorUpdateOneWithoutShipmentsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedShipmentsNestedInput
    complianceDocs?: ComplianceDocumentUpdateManyWithoutShipmentNestedInput
    payments?: PaymentUpdateManyWithoutShipmentNestedInput
    invoice?: InvoiceUpdateOneWithoutShipmentNestedInput
    consentLogs?: ConsentLogUpdateManyWithoutShipmentNestedInput
    transporterInvoices?: TransporterInvoiceUpdateManyWithoutShipmentNestedInput
  }

  export type ShipmentUncheckedUpdateWithoutStatusHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    quoteRequestId?: NullableIntFieldUpdateOperationsInput | number | null
    transporterQuoteId?: NullableIntFieldUpdateOperationsInput | number | null
    selectedVendorId?: NullableIntFieldUpdateOperationsInput | number | null
    agreementId?: NullableIntFieldUpdateOperationsInput | number | null
    rateCardId?: NullableIntFieldUpdateOperationsInput | number | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedDriver?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    driverEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transporterResponseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ewayBillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstInvoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    source?: StringFieldUpdateOperationsInput | string
    podStatus?: StringFieldUpdateOperationsInput | string
    podUrl?: NullableStringFieldUpdateOperationsInput | string | null
    podNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    complianceDocs?: ComplianceDocumentUncheckedUpdateManyWithoutShipmentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutShipmentNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutShipmentNestedInput
    consentLogs?: ConsentLogUncheckedUpdateManyWithoutShipmentNestedInput
    transporterInvoices?: TransporterInvoiceUncheckedUpdateManyWithoutShipmentNestedInput
  }

  export type ShipmentCreateWithoutInvoiceInput = {
    agreementId?: number | null
    trackingNumber?: string | null
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.ShipmentStatus
    bookingStatus?: $Enums.BookingStatus | null
    paymentStatus?: $Enums.PaymentStatus | null
    cost?: number | null
    distance?: number | null
    estimatedDelivery?: Date | string | null
    pickupTime?: Date | string | null
    deliveryTime?: Date | string | null
    assignedDriver?: string | null
    driverPhone?: string | null
    driverEta?: Date | string | null
    transporterResponseNotes?: string | null
    notes?: string | null
    ewayBillNumber?: string | null
    gstInvoiceId?: number | null
    complianceStatus?: $Enums.ComplianceStatus
    source?: string
    podStatus?: string
    podUrl?: string | null
    podNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutShipmentsInput
    company?: CompanyCreateNestedOneWithoutShipmentsInput
    quoteRequest?: QuoteRequestCreateNestedOneWithoutShipmentInput
    transporterQuote?: QuoteResponseCreateNestedOneWithoutShipmentInput
    rateCard?: RateCardCreateNestedOneWithoutShipmentsInput
    vendor?: VendorCreateNestedOneWithoutShipmentsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedShipmentsInput
    statusHistory?: StatusHistoryCreateNestedManyWithoutShipmentInput
    complianceDocs?: ComplianceDocumentCreateNestedManyWithoutShipmentInput
    payments?: PaymentCreateNestedManyWithoutShipmentInput
    consentLogs?: ConsentLogCreateNestedManyWithoutShipmentInput
    transporterInvoices?: TransporterInvoiceCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentUncheckedCreateWithoutInvoiceInput = {
    id?: number
    userId: number
    companyId?: number | null
    quoteRequestId?: number | null
    transporterQuoteId?: number | null
    selectedVendorId?: number | null
    agreementId?: number | null
    rateCardId?: number | null
    trackingNumber?: string | null
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.ShipmentStatus
    bookingStatus?: $Enums.BookingStatus | null
    paymentStatus?: $Enums.PaymentStatus | null
    cost?: number | null
    distance?: number | null
    estimatedDelivery?: Date | string | null
    pickupTime?: Date | string | null
    deliveryTime?: Date | string | null
    assignedToId?: number | null
    assignedDriver?: string | null
    driverPhone?: string | null
    driverEta?: Date | string | null
    transporterResponseNotes?: string | null
    notes?: string | null
    ewayBillNumber?: string | null
    gstInvoiceId?: number | null
    complianceStatus?: $Enums.ComplianceStatus
    source?: string
    podStatus?: string
    podUrl?: string | null
    podNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    statusHistory?: StatusHistoryUncheckedCreateNestedManyWithoutShipmentInput
    complianceDocs?: ComplianceDocumentUncheckedCreateNestedManyWithoutShipmentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutShipmentInput
    consentLogs?: ConsentLogUncheckedCreateNestedManyWithoutShipmentInput
    transporterInvoices?: TransporterInvoiceUncheckedCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentCreateOrConnectWithoutInvoiceInput = {
    where: ShipmentWhereUniqueInput
    create: XOR<ShipmentCreateWithoutInvoiceInput, ShipmentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentCreateWithoutInvoiceInput = {
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    gateway?: string
    transactionRef?: string | null
    authorizedAt?: Date | string | null
    capturedAt?: Date | string | null
    failureReason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tdsAmount?: number | null
    tcsAmount?: number | null
    rcmLiability?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shipment: ShipmentCreateNestedOneWithoutPaymentsInput
    events?: PaymentEventCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutInvoiceInput = {
    id?: number
    shipmentId: number
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    gateway?: string
    transactionRef?: string | null
    authorizedAt?: Date | string | null
    capturedAt?: Date | string | null
    failureReason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tdsAmount?: number | null
    tcsAmount?: number | null
    rcmLiability?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: PaymentEventUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentCreateManyInvoiceInputEnvelope = {
    data: PaymentCreateManyInvoiceInput | PaymentCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutInvoicesInput = {
    name: string
    webhookSecret: string
    plan?: string
    subscriptionStatus?: string
    billingEmail?: string | null
    billingCustomerId?: string | null
    trialEndsAt?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    shipments?: ShipmentCreateNestedManyWithoutCompanyInput
    agreements?: AgreementCreateNestedManyWithoutCompanyInput
    transporterInvoices?: TransporterInvoiceCreateNestedManyWithoutCompanyInput
    profiles?: CompanyProfileCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutInvoicesInput = {
    id?: number
    name: string
    webhookSecret: string
    plan?: string
    subscriptionStatus?: string
    billingEmail?: string | null
    billingCustomerId?: string | null
    trialEndsAt?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    shipments?: ShipmentUncheckedCreateNestedManyWithoutCompanyInput
    agreements?: AgreementUncheckedCreateNestedManyWithoutCompanyInput
    transporterInvoices?: TransporterInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    profiles?: CompanyProfileUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutInvoicesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutInvoicesInput, CompanyUncheckedCreateWithoutInvoicesInput>
  }

  export type ShipmentUpsertWithoutInvoiceInput = {
    update: XOR<ShipmentUpdateWithoutInvoiceInput, ShipmentUncheckedUpdateWithoutInvoiceInput>
    create: XOR<ShipmentCreateWithoutInvoiceInput, ShipmentUncheckedCreateWithoutInvoiceInput>
    where?: ShipmentWhereInput
  }

  export type ShipmentUpdateToOneWithWhereWithoutInvoiceInput = {
    where?: ShipmentWhereInput
    data: XOR<ShipmentUpdateWithoutInvoiceInput, ShipmentUncheckedUpdateWithoutInvoiceInput>
  }

  export type ShipmentUpdateWithoutInvoiceInput = {
    agreementId?: NullableIntFieldUpdateOperationsInput | number | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedDriver?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    driverEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transporterResponseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ewayBillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstInvoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    source?: StringFieldUpdateOperationsInput | string
    podStatus?: StringFieldUpdateOperationsInput | string
    podUrl?: NullableStringFieldUpdateOperationsInput | string | null
    podNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutShipmentsNestedInput
    company?: CompanyUpdateOneWithoutShipmentsNestedInput
    quoteRequest?: QuoteRequestUpdateOneWithoutShipmentNestedInput
    transporterQuote?: QuoteResponseUpdateOneWithoutShipmentNestedInput
    rateCard?: RateCardUpdateOneWithoutShipmentsNestedInput
    vendor?: VendorUpdateOneWithoutShipmentsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedShipmentsNestedInput
    statusHistory?: StatusHistoryUpdateManyWithoutShipmentNestedInput
    complianceDocs?: ComplianceDocumentUpdateManyWithoutShipmentNestedInput
    payments?: PaymentUpdateManyWithoutShipmentNestedInput
    consentLogs?: ConsentLogUpdateManyWithoutShipmentNestedInput
    transporterInvoices?: TransporterInvoiceUpdateManyWithoutShipmentNestedInput
  }

  export type ShipmentUncheckedUpdateWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    quoteRequestId?: NullableIntFieldUpdateOperationsInput | number | null
    transporterQuoteId?: NullableIntFieldUpdateOperationsInput | number | null
    selectedVendorId?: NullableIntFieldUpdateOperationsInput | number | null
    agreementId?: NullableIntFieldUpdateOperationsInput | number | null
    rateCardId?: NullableIntFieldUpdateOperationsInput | number | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedDriver?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    driverEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transporterResponseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ewayBillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstInvoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    source?: StringFieldUpdateOperationsInput | string
    podStatus?: StringFieldUpdateOperationsInput | string
    podUrl?: NullableStringFieldUpdateOperationsInput | string | null
    podNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusHistory?: StatusHistoryUncheckedUpdateManyWithoutShipmentNestedInput
    complianceDocs?: ComplianceDocumentUncheckedUpdateManyWithoutShipmentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutShipmentNestedInput
    consentLogs?: ConsentLogUncheckedUpdateManyWithoutShipmentNestedInput
    transporterInvoices?: TransporterInvoiceUncheckedUpdateManyWithoutShipmentNestedInput
  }

  export type PaymentUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
  }

  export type PaymentUpdateManyWithWhereWithoutInvoiceInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type CompanyUpsertWithoutInvoicesInput = {
    update: XOR<CompanyUpdateWithoutInvoicesInput, CompanyUncheckedUpdateWithoutInvoicesInput>
    create: XOR<CompanyCreateWithoutInvoicesInput, CompanyUncheckedCreateWithoutInvoicesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutInvoicesInput, CompanyUncheckedUpdateWithoutInvoicesInput>
  }

  export type CompanyUpdateWithoutInvoicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    webhookSecret?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    billingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    billingCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    shipments?: ShipmentUpdateManyWithoutCompanyNestedInput
    agreements?: AgreementUpdateManyWithoutCompanyNestedInput
    transporterInvoices?: TransporterInvoiceUpdateManyWithoutCompanyNestedInput
    profiles?: CompanyProfileUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    webhookSecret?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    billingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    billingCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    shipments?: ShipmentUncheckedUpdateManyWithoutCompanyNestedInput
    agreements?: AgreementUncheckedUpdateManyWithoutCompanyNestedInput
    transporterInvoices?: TransporterInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    profiles?: CompanyProfileUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ShipmentCreateWithoutPaymentsInput = {
    agreementId?: number | null
    trackingNumber?: string | null
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.ShipmentStatus
    bookingStatus?: $Enums.BookingStatus | null
    paymentStatus?: $Enums.PaymentStatus | null
    cost?: number | null
    distance?: number | null
    estimatedDelivery?: Date | string | null
    pickupTime?: Date | string | null
    deliveryTime?: Date | string | null
    assignedDriver?: string | null
    driverPhone?: string | null
    driverEta?: Date | string | null
    transporterResponseNotes?: string | null
    notes?: string | null
    ewayBillNumber?: string | null
    gstInvoiceId?: number | null
    complianceStatus?: $Enums.ComplianceStatus
    source?: string
    podStatus?: string
    podUrl?: string | null
    podNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutShipmentsInput
    company?: CompanyCreateNestedOneWithoutShipmentsInput
    quoteRequest?: QuoteRequestCreateNestedOneWithoutShipmentInput
    transporterQuote?: QuoteResponseCreateNestedOneWithoutShipmentInput
    rateCard?: RateCardCreateNestedOneWithoutShipmentsInput
    vendor?: VendorCreateNestedOneWithoutShipmentsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedShipmentsInput
    statusHistory?: StatusHistoryCreateNestedManyWithoutShipmentInput
    complianceDocs?: ComplianceDocumentCreateNestedManyWithoutShipmentInput
    invoice?: InvoiceCreateNestedOneWithoutShipmentInput
    consentLogs?: ConsentLogCreateNestedManyWithoutShipmentInput
    transporterInvoices?: TransporterInvoiceCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentUncheckedCreateWithoutPaymentsInput = {
    id?: number
    userId: number
    companyId?: number | null
    quoteRequestId?: number | null
    transporterQuoteId?: number | null
    selectedVendorId?: number | null
    agreementId?: number | null
    rateCardId?: number | null
    trackingNumber?: string | null
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.ShipmentStatus
    bookingStatus?: $Enums.BookingStatus | null
    paymentStatus?: $Enums.PaymentStatus | null
    cost?: number | null
    distance?: number | null
    estimatedDelivery?: Date | string | null
    pickupTime?: Date | string | null
    deliveryTime?: Date | string | null
    assignedToId?: number | null
    assignedDriver?: string | null
    driverPhone?: string | null
    driverEta?: Date | string | null
    transporterResponseNotes?: string | null
    notes?: string | null
    ewayBillNumber?: string | null
    gstInvoiceId?: number | null
    complianceStatus?: $Enums.ComplianceStatus
    source?: string
    podStatus?: string
    podUrl?: string | null
    podNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    statusHistory?: StatusHistoryUncheckedCreateNestedManyWithoutShipmentInput
    complianceDocs?: ComplianceDocumentUncheckedCreateNestedManyWithoutShipmentInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutShipmentInput
    consentLogs?: ConsentLogUncheckedCreateNestedManyWithoutShipmentInput
    transporterInvoices?: TransporterInvoiceUncheckedCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentCreateOrConnectWithoutPaymentsInput = {
    where: ShipmentWhereUniqueInput
    create: XOR<ShipmentCreateWithoutPaymentsInput, ShipmentUncheckedCreateWithoutPaymentsInput>
  }

  export type InvoiceCreateWithoutPaymentsInput = {
    invoiceNumber: string
    status?: $Enums.InvoiceStatus
    issuedAt?: Date | string | null
    dueDate?: Date | string | null
    subtotal?: number
    taxTotal?: number
    grandTotal?: number
    lineItems: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    shipment: ShipmentCreateNestedOneWithoutInvoiceInput
    Company?: CompanyCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutPaymentsInput = {
    id?: number
    shipmentId: number
    invoiceNumber: string
    status?: $Enums.InvoiceStatus
    issuedAt?: Date | string | null
    dueDate?: Date | string | null
    subtotal?: number
    taxTotal?: number
    grandTotal?: number
    lineItems: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: number | null
  }

  export type InvoiceCreateOrConnectWithoutPaymentsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
  }

  export type PaymentEventCreateWithoutPaymentInput = {
    eventType: string
    details?: NullableJsonNullValueInput | InputJsonValue
    recordedAt?: Date | string
  }

  export type PaymentEventUncheckedCreateWithoutPaymentInput = {
    id?: number
    eventType: string
    details?: NullableJsonNullValueInput | InputJsonValue
    recordedAt?: Date | string
  }

  export type PaymentEventCreateOrConnectWithoutPaymentInput = {
    where: PaymentEventWhereUniqueInput
    create: XOR<PaymentEventCreateWithoutPaymentInput, PaymentEventUncheckedCreateWithoutPaymentInput>
  }

  export type PaymentEventCreateManyPaymentInputEnvelope = {
    data: PaymentEventCreateManyPaymentInput | PaymentEventCreateManyPaymentInput[]
    skipDuplicates?: boolean
  }

  export type ShipmentUpsertWithoutPaymentsInput = {
    update: XOR<ShipmentUpdateWithoutPaymentsInput, ShipmentUncheckedUpdateWithoutPaymentsInput>
    create: XOR<ShipmentCreateWithoutPaymentsInput, ShipmentUncheckedCreateWithoutPaymentsInput>
    where?: ShipmentWhereInput
  }

  export type ShipmentUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: ShipmentWhereInput
    data: XOR<ShipmentUpdateWithoutPaymentsInput, ShipmentUncheckedUpdateWithoutPaymentsInput>
  }

  export type ShipmentUpdateWithoutPaymentsInput = {
    agreementId?: NullableIntFieldUpdateOperationsInput | number | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedDriver?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    driverEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transporterResponseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ewayBillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstInvoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    source?: StringFieldUpdateOperationsInput | string
    podStatus?: StringFieldUpdateOperationsInput | string
    podUrl?: NullableStringFieldUpdateOperationsInput | string | null
    podNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutShipmentsNestedInput
    company?: CompanyUpdateOneWithoutShipmentsNestedInput
    quoteRequest?: QuoteRequestUpdateOneWithoutShipmentNestedInput
    transporterQuote?: QuoteResponseUpdateOneWithoutShipmentNestedInput
    rateCard?: RateCardUpdateOneWithoutShipmentsNestedInput
    vendor?: VendorUpdateOneWithoutShipmentsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedShipmentsNestedInput
    statusHistory?: StatusHistoryUpdateManyWithoutShipmentNestedInput
    complianceDocs?: ComplianceDocumentUpdateManyWithoutShipmentNestedInput
    invoice?: InvoiceUpdateOneWithoutShipmentNestedInput
    consentLogs?: ConsentLogUpdateManyWithoutShipmentNestedInput
    transporterInvoices?: TransporterInvoiceUpdateManyWithoutShipmentNestedInput
  }

  export type ShipmentUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    quoteRequestId?: NullableIntFieldUpdateOperationsInput | number | null
    transporterQuoteId?: NullableIntFieldUpdateOperationsInput | number | null
    selectedVendorId?: NullableIntFieldUpdateOperationsInput | number | null
    agreementId?: NullableIntFieldUpdateOperationsInput | number | null
    rateCardId?: NullableIntFieldUpdateOperationsInput | number | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedDriver?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    driverEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transporterResponseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ewayBillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstInvoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    source?: StringFieldUpdateOperationsInput | string
    podStatus?: StringFieldUpdateOperationsInput | string
    podUrl?: NullableStringFieldUpdateOperationsInput | string | null
    podNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusHistory?: StatusHistoryUncheckedUpdateManyWithoutShipmentNestedInput
    complianceDocs?: ComplianceDocumentUncheckedUpdateManyWithoutShipmentNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutShipmentNestedInput
    consentLogs?: ConsentLogUncheckedUpdateManyWithoutShipmentNestedInput
    transporterInvoices?: TransporterInvoiceUncheckedUpdateManyWithoutShipmentNestedInput
  }

  export type InvoiceUpsertWithoutPaymentsInput = {
    update: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type InvoiceUpdateWithoutPaymentsInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxTotal?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    lineItems?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipment?: ShipmentUpdateOneRequiredWithoutInvoiceNestedInput
    Company?: CompanyUpdateOneWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipmentId?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxTotal?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    lineItems?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PaymentEventUpsertWithWhereUniqueWithoutPaymentInput = {
    where: PaymentEventWhereUniqueInput
    update: XOR<PaymentEventUpdateWithoutPaymentInput, PaymentEventUncheckedUpdateWithoutPaymentInput>
    create: XOR<PaymentEventCreateWithoutPaymentInput, PaymentEventUncheckedCreateWithoutPaymentInput>
  }

  export type PaymentEventUpdateWithWhereUniqueWithoutPaymentInput = {
    where: PaymentEventWhereUniqueInput
    data: XOR<PaymentEventUpdateWithoutPaymentInput, PaymentEventUncheckedUpdateWithoutPaymentInput>
  }

  export type PaymentEventUpdateManyWithWhereWithoutPaymentInput = {
    where: PaymentEventScalarWhereInput
    data: XOR<PaymentEventUpdateManyMutationInput, PaymentEventUncheckedUpdateManyWithoutPaymentInput>
  }

  export type PaymentEventScalarWhereInput = {
    AND?: PaymentEventScalarWhereInput | PaymentEventScalarWhereInput[]
    OR?: PaymentEventScalarWhereInput[]
    NOT?: PaymentEventScalarWhereInput | PaymentEventScalarWhereInput[]
    id?: IntFilter<"PaymentEvent"> | number
    paymentId?: IntFilter<"PaymentEvent"> | number
    eventType?: StringFilter<"PaymentEvent"> | string
    details?: JsonNullableFilter<"PaymentEvent">
    recordedAt?: DateTimeFilter<"PaymentEvent"> | Date | string
  }

  export type PaymentCreateWithoutEventsInput = {
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    gateway?: string
    transactionRef?: string | null
    authorizedAt?: Date | string | null
    capturedAt?: Date | string | null
    failureReason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tdsAmount?: number | null
    tcsAmount?: number | null
    rcmLiability?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shipment: ShipmentCreateNestedOneWithoutPaymentsInput
    invoice: InvoiceCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutEventsInput = {
    id?: number
    shipmentId: number
    invoiceId: number
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    gateway?: string
    transactionRef?: string | null
    authorizedAt?: Date | string | null
    capturedAt?: Date | string | null
    failureReason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tdsAmount?: number | null
    tcsAmount?: number | null
    rcmLiability?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutEventsInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutEventsInput, PaymentUncheckedCreateWithoutEventsInput>
  }

  export type PaymentUpsertWithoutEventsInput = {
    update: XOR<PaymentUpdateWithoutEventsInput, PaymentUncheckedUpdateWithoutEventsInput>
    create: XOR<PaymentCreateWithoutEventsInput, PaymentUncheckedCreateWithoutEventsInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutEventsInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutEventsInput, PaymentUncheckedUpdateWithoutEventsInput>
  }

  export type PaymentUpdateWithoutEventsInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gateway?: StringFieldUpdateOperationsInput | string
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    authorizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tdsAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    tcsAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    rcmLiability?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipment?: ShipmentUpdateOneRequiredWithoutPaymentsNestedInput
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipmentId?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gateway?: StringFieldUpdateOperationsInput | string
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    authorizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tdsAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    tcsAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    rcmLiability?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateWithoutTransporterInvoicesInput = {
    name: string
    webhookSecret: string
    plan?: string
    subscriptionStatus?: string
    billingEmail?: string | null
    billingCustomerId?: string | null
    trialEndsAt?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    shipments?: ShipmentCreateNestedManyWithoutCompanyInput
    agreements?: AgreementCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceCreateNestedManyWithoutCompanyInput
    profiles?: CompanyProfileCreateNestedManyWithoutCompanyInput
    vendors?: VendorCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutTransporterInvoicesInput = {
    id?: number
    name: string
    webhookSecret: string
    plan?: string
    subscriptionStatus?: string
    billingEmail?: string | null
    billingCustomerId?: string | null
    trialEndsAt?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    shipments?: ShipmentUncheckedCreateNestedManyWithoutCompanyInput
    agreements?: AgreementUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCompanyInput
    profiles?: CompanyProfileUncheckedCreateNestedManyWithoutCompanyInput
    vendors?: VendorUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutTransporterInvoicesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutTransporterInvoicesInput, CompanyUncheckedCreateWithoutTransporterInvoicesInput>
  }

  export type ShipmentCreateWithoutTransporterInvoicesInput = {
    agreementId?: number | null
    trackingNumber?: string | null
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.ShipmentStatus
    bookingStatus?: $Enums.BookingStatus | null
    paymentStatus?: $Enums.PaymentStatus | null
    cost?: number | null
    distance?: number | null
    estimatedDelivery?: Date | string | null
    pickupTime?: Date | string | null
    deliveryTime?: Date | string | null
    assignedDriver?: string | null
    driverPhone?: string | null
    driverEta?: Date | string | null
    transporterResponseNotes?: string | null
    notes?: string | null
    ewayBillNumber?: string | null
    gstInvoiceId?: number | null
    complianceStatus?: $Enums.ComplianceStatus
    source?: string
    podStatus?: string
    podUrl?: string | null
    podNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutShipmentsInput
    company?: CompanyCreateNestedOneWithoutShipmentsInput
    quoteRequest?: QuoteRequestCreateNestedOneWithoutShipmentInput
    transporterQuote?: QuoteResponseCreateNestedOneWithoutShipmentInput
    rateCard?: RateCardCreateNestedOneWithoutShipmentsInput
    vendor?: VendorCreateNestedOneWithoutShipmentsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedShipmentsInput
    statusHistory?: StatusHistoryCreateNestedManyWithoutShipmentInput
    complianceDocs?: ComplianceDocumentCreateNestedManyWithoutShipmentInput
    payments?: PaymentCreateNestedManyWithoutShipmentInput
    invoice?: InvoiceCreateNestedOneWithoutShipmentInput
    consentLogs?: ConsentLogCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentUncheckedCreateWithoutTransporterInvoicesInput = {
    id?: number
    userId: number
    companyId?: number | null
    quoteRequestId?: number | null
    transporterQuoteId?: number | null
    selectedVendorId?: number | null
    agreementId?: number | null
    rateCardId?: number | null
    trackingNumber?: string | null
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.ShipmentStatus
    bookingStatus?: $Enums.BookingStatus | null
    paymentStatus?: $Enums.PaymentStatus | null
    cost?: number | null
    distance?: number | null
    estimatedDelivery?: Date | string | null
    pickupTime?: Date | string | null
    deliveryTime?: Date | string | null
    assignedToId?: number | null
    assignedDriver?: string | null
    driverPhone?: string | null
    driverEta?: Date | string | null
    transporterResponseNotes?: string | null
    notes?: string | null
    ewayBillNumber?: string | null
    gstInvoiceId?: number | null
    complianceStatus?: $Enums.ComplianceStatus
    source?: string
    podStatus?: string
    podUrl?: string | null
    podNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    statusHistory?: StatusHistoryUncheckedCreateNestedManyWithoutShipmentInput
    complianceDocs?: ComplianceDocumentUncheckedCreateNestedManyWithoutShipmentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutShipmentInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutShipmentInput
    consentLogs?: ConsentLogUncheckedCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentCreateOrConnectWithoutTransporterInvoicesInput = {
    where: ShipmentWhereUniqueInput
    create: XOR<ShipmentCreateWithoutTransporterInvoicesInput, ShipmentUncheckedCreateWithoutTransporterInvoicesInput>
  }

  export type UserCreateWithoutTransporterInvoicesInput = {
    email: string
    passwordHash: string
    name?: string | null
    phone?: string | null
    role?: $Enums.Role
    approvalStatus?: $Enums.ApprovalStatus
    approvalNote?: string | null
    rejectionReason?: string | null
    reviewedById?: number | null
    reviewedAt?: Date | string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorChannel?: string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutUsersInput
    vendor?: VendorCreateNestedOneWithoutUserInput
    shipments?: ShipmentCreateNestedManyWithoutUserInput
    assignedShipments?: ShipmentCreateNestedManyWithoutAssignedToInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    agreementsReviewed?: AgreementCreateNestedManyWithoutReviewedByInput
    QuoteRequest?: QuoteRequestCreateNestedManyWithoutCreatedByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    twoFactorChallenges?: TwoFactorChallengeCreateNestedManyWithoutUserInput
    userConsents?: UserConsentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTransporterInvoicesInput = {
    id?: number
    email: string
    passwordHash: string
    name?: string | null
    phone?: string | null
    role?: $Enums.Role
    approvalStatus?: $Enums.ApprovalStatus
    approvalNote?: string | null
    rejectionReason?: string | null
    reviewedById?: number | null
    reviewedAt?: Date | string | null
    isActive?: boolean
    vendorId?: number | null
    companyId?: number | null
    lastLoginAt?: Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorChannel?: string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    shipments?: ShipmentUncheckedCreateNestedManyWithoutUserInput
    assignedShipments?: ShipmentUncheckedCreateNestedManyWithoutAssignedToInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    agreementsReviewed?: AgreementUncheckedCreateNestedManyWithoutReviewedByInput
    QuoteRequest?: QuoteRequestUncheckedCreateNestedManyWithoutCreatedByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    twoFactorChallenges?: TwoFactorChallengeUncheckedCreateNestedManyWithoutUserInput
    userConsents?: UserConsentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTransporterInvoicesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransporterInvoicesInput, UserUncheckedCreateWithoutTransporterInvoicesInput>
  }

  export type CompanyUpsertWithoutTransporterInvoicesInput = {
    update: XOR<CompanyUpdateWithoutTransporterInvoicesInput, CompanyUncheckedUpdateWithoutTransporterInvoicesInput>
    create: XOR<CompanyCreateWithoutTransporterInvoicesInput, CompanyUncheckedCreateWithoutTransporterInvoicesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutTransporterInvoicesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutTransporterInvoicesInput, CompanyUncheckedUpdateWithoutTransporterInvoicesInput>
  }

  export type CompanyUpdateWithoutTransporterInvoicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    webhookSecret?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    billingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    billingCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    shipments?: ShipmentUpdateManyWithoutCompanyNestedInput
    agreements?: AgreementUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUpdateManyWithoutCompanyNestedInput
    profiles?: CompanyProfileUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutTransporterInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    webhookSecret?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    billingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    billingCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    shipments?: ShipmentUncheckedUpdateManyWithoutCompanyNestedInput
    agreements?: AgreementUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    profiles?: CompanyProfileUncheckedUpdateManyWithoutCompanyNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ShipmentUpsertWithoutTransporterInvoicesInput = {
    update: XOR<ShipmentUpdateWithoutTransporterInvoicesInput, ShipmentUncheckedUpdateWithoutTransporterInvoicesInput>
    create: XOR<ShipmentCreateWithoutTransporterInvoicesInput, ShipmentUncheckedCreateWithoutTransporterInvoicesInput>
    where?: ShipmentWhereInput
  }

  export type ShipmentUpdateToOneWithWhereWithoutTransporterInvoicesInput = {
    where?: ShipmentWhereInput
    data: XOR<ShipmentUpdateWithoutTransporterInvoicesInput, ShipmentUncheckedUpdateWithoutTransporterInvoicesInput>
  }

  export type ShipmentUpdateWithoutTransporterInvoicesInput = {
    agreementId?: NullableIntFieldUpdateOperationsInput | number | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedDriver?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    driverEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transporterResponseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ewayBillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstInvoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    source?: StringFieldUpdateOperationsInput | string
    podStatus?: StringFieldUpdateOperationsInput | string
    podUrl?: NullableStringFieldUpdateOperationsInput | string | null
    podNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutShipmentsNestedInput
    company?: CompanyUpdateOneWithoutShipmentsNestedInput
    quoteRequest?: QuoteRequestUpdateOneWithoutShipmentNestedInput
    transporterQuote?: QuoteResponseUpdateOneWithoutShipmentNestedInput
    rateCard?: RateCardUpdateOneWithoutShipmentsNestedInput
    vendor?: VendorUpdateOneWithoutShipmentsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedShipmentsNestedInput
    statusHistory?: StatusHistoryUpdateManyWithoutShipmentNestedInput
    complianceDocs?: ComplianceDocumentUpdateManyWithoutShipmentNestedInput
    payments?: PaymentUpdateManyWithoutShipmentNestedInput
    invoice?: InvoiceUpdateOneWithoutShipmentNestedInput
    consentLogs?: ConsentLogUpdateManyWithoutShipmentNestedInput
  }

  export type ShipmentUncheckedUpdateWithoutTransporterInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    quoteRequestId?: NullableIntFieldUpdateOperationsInput | number | null
    transporterQuoteId?: NullableIntFieldUpdateOperationsInput | number | null
    selectedVendorId?: NullableIntFieldUpdateOperationsInput | number | null
    agreementId?: NullableIntFieldUpdateOperationsInput | number | null
    rateCardId?: NullableIntFieldUpdateOperationsInput | number | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedDriver?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    driverEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transporterResponseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ewayBillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstInvoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    source?: StringFieldUpdateOperationsInput | string
    podStatus?: StringFieldUpdateOperationsInput | string
    podUrl?: NullableStringFieldUpdateOperationsInput | string | null
    podNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusHistory?: StatusHistoryUncheckedUpdateManyWithoutShipmentNestedInput
    complianceDocs?: ComplianceDocumentUncheckedUpdateManyWithoutShipmentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutShipmentNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutShipmentNestedInput
    consentLogs?: ConsentLogUncheckedUpdateManyWithoutShipmentNestedInput
  }

  export type UserUpsertWithoutTransporterInvoicesInput = {
    update: XOR<UserUpdateWithoutTransporterInvoicesInput, UserUncheckedUpdateWithoutTransporterInvoicesInput>
    create: XOR<UserCreateWithoutTransporterInvoicesInput, UserUncheckedCreateWithoutTransporterInvoicesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransporterInvoicesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransporterInvoicesInput, UserUncheckedUpdateWithoutTransporterInvoicesInput>
  }

  export type UserUpdateWithoutTransporterInvoicesInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorChannel?: NullableStringFieldUpdateOperationsInput | string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutUsersNestedInput
    vendor?: VendorUpdateOneWithoutUserNestedInput
    shipments?: ShipmentUpdateManyWithoutUserNestedInput
    assignedShipments?: ShipmentUpdateManyWithoutAssignedToNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    agreementsReviewed?: AgreementUpdateManyWithoutReviewedByNestedInput
    QuoteRequest?: QuoteRequestUpdateManyWithoutCreatedByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    twoFactorChallenges?: TwoFactorChallengeUpdateManyWithoutUserNestedInput
    userConsents?: UserConsentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTransporterInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorChannel?: NullableStringFieldUpdateOperationsInput | string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipments?: ShipmentUncheckedUpdateManyWithoutUserNestedInput
    assignedShipments?: ShipmentUncheckedUpdateManyWithoutAssignedToNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    agreementsReviewed?: AgreementUncheckedUpdateManyWithoutReviewedByNestedInput
    QuoteRequest?: QuoteRequestUncheckedUpdateManyWithoutCreatedByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    twoFactorChallenges?: TwoFactorChallengeUncheckedUpdateManyWithoutUserNestedInput
    userConsents?: UserConsentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    email: string
    passwordHash: string
    name?: string | null
    phone?: string | null
    role?: $Enums.Role
    approvalStatus?: $Enums.ApprovalStatus
    approvalNote?: string | null
    rejectionReason?: string | null
    reviewedById?: number | null
    reviewedAt?: Date | string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorChannel?: string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutUsersInput
    vendor?: VendorCreateNestedOneWithoutUserInput
    shipments?: ShipmentCreateNestedManyWithoutUserInput
    assignedShipments?: ShipmentCreateNestedManyWithoutAssignedToInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    agreementsReviewed?: AgreementCreateNestedManyWithoutReviewedByInput
    transporterInvoices?: TransporterInvoiceCreateNestedManyWithoutApprovedByInput
    QuoteRequest?: QuoteRequestCreateNestedManyWithoutCreatedByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    twoFactorChallenges?: TwoFactorChallengeCreateNestedManyWithoutUserInput
    userConsents?: UserConsentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: number
    email: string
    passwordHash: string
    name?: string | null
    phone?: string | null
    role?: $Enums.Role
    approvalStatus?: $Enums.ApprovalStatus
    approvalNote?: string | null
    rejectionReason?: string | null
    reviewedById?: number | null
    reviewedAt?: Date | string | null
    isActive?: boolean
    vendorId?: number | null
    companyId?: number | null
    lastLoginAt?: Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorChannel?: string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    shipments?: ShipmentUncheckedCreateNestedManyWithoutUserInput
    assignedShipments?: ShipmentUncheckedCreateNestedManyWithoutAssignedToInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    agreementsReviewed?: AgreementUncheckedCreateNestedManyWithoutReviewedByInput
    transporterInvoices?: TransporterInvoiceUncheckedCreateNestedManyWithoutApprovedByInput
    QuoteRequest?: QuoteRequestUncheckedCreateNestedManyWithoutCreatedByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    twoFactorChallenges?: TwoFactorChallengeUncheckedCreateNestedManyWithoutUserInput
    userConsents?: UserConsentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorChannel?: NullableStringFieldUpdateOperationsInput | string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutUsersNestedInput
    vendor?: VendorUpdateOneWithoutUserNestedInput
    shipments?: ShipmentUpdateManyWithoutUserNestedInput
    assignedShipments?: ShipmentUpdateManyWithoutAssignedToNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    agreementsReviewed?: AgreementUpdateManyWithoutReviewedByNestedInput
    transporterInvoices?: TransporterInvoiceUpdateManyWithoutApprovedByNestedInput
    QuoteRequest?: QuoteRequestUpdateManyWithoutCreatedByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    twoFactorChallenges?: TwoFactorChallengeUpdateManyWithoutUserNestedInput
    userConsents?: UserConsentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorChannel?: NullableStringFieldUpdateOperationsInput | string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipments?: ShipmentUncheckedUpdateManyWithoutUserNestedInput
    assignedShipments?: ShipmentUncheckedUpdateManyWithoutAssignedToNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    agreementsReviewed?: AgreementUncheckedUpdateManyWithoutReviewedByNestedInput
    transporterInvoices?: TransporterInvoiceUncheckedUpdateManyWithoutApprovedByNestedInput
    QuoteRequest?: QuoteRequestUncheckedUpdateManyWithoutCreatedByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    twoFactorChallenges?: TwoFactorChallengeUncheckedUpdateManyWithoutUserNestedInput
    userConsents?: UserConsentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    email: string
    passwordHash: string
    name?: string | null
    phone?: string | null
    role?: $Enums.Role
    approvalStatus?: $Enums.ApprovalStatus
    approvalNote?: string | null
    rejectionReason?: string | null
    reviewedById?: number | null
    reviewedAt?: Date | string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorChannel?: string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutUsersInput
    vendor?: VendorCreateNestedOneWithoutUserInput
    shipments?: ShipmentCreateNestedManyWithoutUserInput
    assignedShipments?: ShipmentCreateNestedManyWithoutAssignedToInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    agreementsReviewed?: AgreementCreateNestedManyWithoutReviewedByInput
    transporterInvoices?: TransporterInvoiceCreateNestedManyWithoutApprovedByInput
    QuoteRequest?: QuoteRequestCreateNestedManyWithoutCreatedByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    twoFactorChallenges?: TwoFactorChallengeCreateNestedManyWithoutUserInput
    userConsents?: UserConsentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: number
    email: string
    passwordHash: string
    name?: string | null
    phone?: string | null
    role?: $Enums.Role
    approvalStatus?: $Enums.ApprovalStatus
    approvalNote?: string | null
    rejectionReason?: string | null
    reviewedById?: number | null
    reviewedAt?: Date | string | null
    isActive?: boolean
    vendorId?: number | null
    companyId?: number | null
    lastLoginAt?: Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorChannel?: string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    shipments?: ShipmentUncheckedCreateNestedManyWithoutUserInput
    assignedShipments?: ShipmentUncheckedCreateNestedManyWithoutAssignedToInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    agreementsReviewed?: AgreementUncheckedCreateNestedManyWithoutReviewedByInput
    transporterInvoices?: TransporterInvoiceUncheckedCreateNestedManyWithoutApprovedByInput
    QuoteRequest?: QuoteRequestUncheckedCreateNestedManyWithoutCreatedByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    twoFactorChallenges?: TwoFactorChallengeUncheckedCreateNestedManyWithoutUserInput
    userConsents?: UserConsentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorChannel?: NullableStringFieldUpdateOperationsInput | string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutUsersNestedInput
    vendor?: VendorUpdateOneWithoutUserNestedInput
    shipments?: ShipmentUpdateManyWithoutUserNestedInput
    assignedShipments?: ShipmentUpdateManyWithoutAssignedToNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    agreementsReviewed?: AgreementUpdateManyWithoutReviewedByNestedInput
    transporterInvoices?: TransporterInvoiceUpdateManyWithoutApprovedByNestedInput
    QuoteRequest?: QuoteRequestUpdateManyWithoutCreatedByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    twoFactorChallenges?: TwoFactorChallengeUpdateManyWithoutUserNestedInput
    userConsents?: UserConsentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorChannel?: NullableStringFieldUpdateOperationsInput | string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipments?: ShipmentUncheckedUpdateManyWithoutUserNestedInput
    assignedShipments?: ShipmentUncheckedUpdateManyWithoutAssignedToNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    agreementsReviewed?: AgreementUncheckedUpdateManyWithoutReviewedByNestedInput
    transporterInvoices?: TransporterInvoiceUncheckedUpdateManyWithoutApprovedByNestedInput
    QuoteRequest?: QuoteRequestUncheckedUpdateManyWithoutCreatedByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    twoFactorChallenges?: TwoFactorChallengeUncheckedUpdateManyWithoutUserNestedInput
    userConsents?: UserConsentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ShipmentCreateWithoutComplianceDocsInput = {
    agreementId?: number | null
    trackingNumber?: string | null
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.ShipmentStatus
    bookingStatus?: $Enums.BookingStatus | null
    paymentStatus?: $Enums.PaymentStatus | null
    cost?: number | null
    distance?: number | null
    estimatedDelivery?: Date | string | null
    pickupTime?: Date | string | null
    deliveryTime?: Date | string | null
    assignedDriver?: string | null
    driverPhone?: string | null
    driverEta?: Date | string | null
    transporterResponseNotes?: string | null
    notes?: string | null
    ewayBillNumber?: string | null
    gstInvoiceId?: number | null
    complianceStatus?: $Enums.ComplianceStatus
    source?: string
    podStatus?: string
    podUrl?: string | null
    podNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutShipmentsInput
    company?: CompanyCreateNestedOneWithoutShipmentsInput
    quoteRequest?: QuoteRequestCreateNestedOneWithoutShipmentInput
    transporterQuote?: QuoteResponseCreateNestedOneWithoutShipmentInput
    rateCard?: RateCardCreateNestedOneWithoutShipmentsInput
    vendor?: VendorCreateNestedOneWithoutShipmentsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedShipmentsInput
    statusHistory?: StatusHistoryCreateNestedManyWithoutShipmentInput
    payments?: PaymentCreateNestedManyWithoutShipmentInput
    invoice?: InvoiceCreateNestedOneWithoutShipmentInput
    consentLogs?: ConsentLogCreateNestedManyWithoutShipmentInput
    transporterInvoices?: TransporterInvoiceCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentUncheckedCreateWithoutComplianceDocsInput = {
    id?: number
    userId: number
    companyId?: number | null
    quoteRequestId?: number | null
    transporterQuoteId?: number | null
    selectedVendorId?: number | null
    agreementId?: number | null
    rateCardId?: number | null
    trackingNumber?: string | null
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.ShipmentStatus
    bookingStatus?: $Enums.BookingStatus | null
    paymentStatus?: $Enums.PaymentStatus | null
    cost?: number | null
    distance?: number | null
    estimatedDelivery?: Date | string | null
    pickupTime?: Date | string | null
    deliveryTime?: Date | string | null
    assignedToId?: number | null
    assignedDriver?: string | null
    driverPhone?: string | null
    driverEta?: Date | string | null
    transporterResponseNotes?: string | null
    notes?: string | null
    ewayBillNumber?: string | null
    gstInvoiceId?: number | null
    complianceStatus?: $Enums.ComplianceStatus
    source?: string
    podStatus?: string
    podUrl?: string | null
    podNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    statusHistory?: StatusHistoryUncheckedCreateNestedManyWithoutShipmentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutShipmentInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutShipmentInput
    consentLogs?: ConsentLogUncheckedCreateNestedManyWithoutShipmentInput
    transporterInvoices?: TransporterInvoiceUncheckedCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentCreateOrConnectWithoutComplianceDocsInput = {
    where: ShipmentWhereUniqueInput
    create: XOR<ShipmentCreateWithoutComplianceDocsInput, ShipmentUncheckedCreateWithoutComplianceDocsInput>
  }

  export type ComplianceEventCreateWithoutDocumentInput = {
    eventType: string
    details?: NullableJsonNullValueInput | InputJsonValue
    recordedAt?: Date | string
  }

  export type ComplianceEventUncheckedCreateWithoutDocumentInput = {
    id?: number
    eventType: string
    details?: NullableJsonNullValueInput | InputJsonValue
    recordedAt?: Date | string
  }

  export type ComplianceEventCreateOrConnectWithoutDocumentInput = {
    where: ComplianceEventWhereUniqueInput
    create: XOR<ComplianceEventCreateWithoutDocumentInput, ComplianceEventUncheckedCreateWithoutDocumentInput>
  }

  export type ComplianceEventCreateManyDocumentInputEnvelope = {
    data: ComplianceEventCreateManyDocumentInput | ComplianceEventCreateManyDocumentInput[]
    skipDuplicates?: boolean
  }

  export type ShipmentUpsertWithoutComplianceDocsInput = {
    update: XOR<ShipmentUpdateWithoutComplianceDocsInput, ShipmentUncheckedUpdateWithoutComplianceDocsInput>
    create: XOR<ShipmentCreateWithoutComplianceDocsInput, ShipmentUncheckedCreateWithoutComplianceDocsInput>
    where?: ShipmentWhereInput
  }

  export type ShipmentUpdateToOneWithWhereWithoutComplianceDocsInput = {
    where?: ShipmentWhereInput
    data: XOR<ShipmentUpdateWithoutComplianceDocsInput, ShipmentUncheckedUpdateWithoutComplianceDocsInput>
  }

  export type ShipmentUpdateWithoutComplianceDocsInput = {
    agreementId?: NullableIntFieldUpdateOperationsInput | number | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedDriver?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    driverEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transporterResponseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ewayBillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstInvoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    source?: StringFieldUpdateOperationsInput | string
    podStatus?: StringFieldUpdateOperationsInput | string
    podUrl?: NullableStringFieldUpdateOperationsInput | string | null
    podNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutShipmentsNestedInput
    company?: CompanyUpdateOneWithoutShipmentsNestedInput
    quoteRequest?: QuoteRequestUpdateOneWithoutShipmentNestedInput
    transporterQuote?: QuoteResponseUpdateOneWithoutShipmentNestedInput
    rateCard?: RateCardUpdateOneWithoutShipmentsNestedInput
    vendor?: VendorUpdateOneWithoutShipmentsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedShipmentsNestedInput
    statusHistory?: StatusHistoryUpdateManyWithoutShipmentNestedInput
    payments?: PaymentUpdateManyWithoutShipmentNestedInput
    invoice?: InvoiceUpdateOneWithoutShipmentNestedInput
    consentLogs?: ConsentLogUpdateManyWithoutShipmentNestedInput
    transporterInvoices?: TransporterInvoiceUpdateManyWithoutShipmentNestedInput
  }

  export type ShipmentUncheckedUpdateWithoutComplianceDocsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    quoteRequestId?: NullableIntFieldUpdateOperationsInput | number | null
    transporterQuoteId?: NullableIntFieldUpdateOperationsInput | number | null
    selectedVendorId?: NullableIntFieldUpdateOperationsInput | number | null
    agreementId?: NullableIntFieldUpdateOperationsInput | number | null
    rateCardId?: NullableIntFieldUpdateOperationsInput | number | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedDriver?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    driverEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transporterResponseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ewayBillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstInvoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    source?: StringFieldUpdateOperationsInput | string
    podStatus?: StringFieldUpdateOperationsInput | string
    podUrl?: NullableStringFieldUpdateOperationsInput | string | null
    podNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusHistory?: StatusHistoryUncheckedUpdateManyWithoutShipmentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutShipmentNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutShipmentNestedInput
    consentLogs?: ConsentLogUncheckedUpdateManyWithoutShipmentNestedInput
    transporterInvoices?: TransporterInvoiceUncheckedUpdateManyWithoutShipmentNestedInput
  }

  export type ComplianceEventUpsertWithWhereUniqueWithoutDocumentInput = {
    where: ComplianceEventWhereUniqueInput
    update: XOR<ComplianceEventUpdateWithoutDocumentInput, ComplianceEventUncheckedUpdateWithoutDocumentInput>
    create: XOR<ComplianceEventCreateWithoutDocumentInput, ComplianceEventUncheckedCreateWithoutDocumentInput>
  }

  export type ComplianceEventUpdateWithWhereUniqueWithoutDocumentInput = {
    where: ComplianceEventWhereUniqueInput
    data: XOR<ComplianceEventUpdateWithoutDocumentInput, ComplianceEventUncheckedUpdateWithoutDocumentInput>
  }

  export type ComplianceEventUpdateManyWithWhereWithoutDocumentInput = {
    where: ComplianceEventScalarWhereInput
    data: XOR<ComplianceEventUpdateManyMutationInput, ComplianceEventUncheckedUpdateManyWithoutDocumentInput>
  }

  export type ComplianceEventScalarWhereInput = {
    AND?: ComplianceEventScalarWhereInput | ComplianceEventScalarWhereInput[]
    OR?: ComplianceEventScalarWhereInput[]
    NOT?: ComplianceEventScalarWhereInput | ComplianceEventScalarWhereInput[]
    id?: IntFilter<"ComplianceEvent"> | number
    documentId?: IntFilter<"ComplianceEvent"> | number
    eventType?: StringFilter<"ComplianceEvent"> | string
    details?: JsonNullableFilter<"ComplianceEvent">
    recordedAt?: DateTimeFilter<"ComplianceEvent"> | Date | string
  }

  export type ComplianceDocumentCreateWithoutEventsInput = {
    type: $Enums.DocumentType
    status?: $Enums.ComplianceStatus
    issuedAt?: Date | string | null
    fileUrl?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shipment: ShipmentCreateNestedOneWithoutComplianceDocsInput
  }

  export type ComplianceDocumentUncheckedCreateWithoutEventsInput = {
    id?: number
    shipmentId: number
    type: $Enums.DocumentType
    status?: $Enums.ComplianceStatus
    issuedAt?: Date | string | null
    fileUrl?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplianceDocumentCreateOrConnectWithoutEventsInput = {
    where: ComplianceDocumentWhereUniqueInput
    create: XOR<ComplianceDocumentCreateWithoutEventsInput, ComplianceDocumentUncheckedCreateWithoutEventsInput>
  }

  export type ComplianceDocumentUpsertWithoutEventsInput = {
    update: XOR<ComplianceDocumentUpdateWithoutEventsInput, ComplianceDocumentUncheckedUpdateWithoutEventsInput>
    create: XOR<ComplianceDocumentCreateWithoutEventsInput, ComplianceDocumentUncheckedCreateWithoutEventsInput>
    where?: ComplianceDocumentWhereInput
  }

  export type ComplianceDocumentUpdateToOneWithWhereWithoutEventsInput = {
    where?: ComplianceDocumentWhereInput
    data: XOR<ComplianceDocumentUpdateWithoutEventsInput, ComplianceDocumentUncheckedUpdateWithoutEventsInput>
  }

  export type ComplianceDocumentUpdateWithoutEventsInput = {
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipment?: ShipmentUpdateOneRequiredWithoutComplianceDocsNestedInput
  }

  export type ComplianceDocumentUncheckedUpdateWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipmentId?: IntFieldUpdateOperationsInput | number
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyCompanyInput = {
    id?: number
    email: string
    passwordHash: string
    name?: string | null
    phone?: string | null
    role?: $Enums.Role
    approvalStatus?: $Enums.ApprovalStatus
    approvalNote?: string | null
    rejectionReason?: string | null
    reviewedById?: number | null
    reviewedAt?: Date | string | null
    isActive?: boolean
    vendorId?: number | null
    lastLoginAt?: Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorChannel?: string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShipmentCreateManyCompanyInput = {
    id?: number
    userId: number
    quoteRequestId?: number | null
    transporterQuoteId?: number | null
    selectedVendorId?: number | null
    agreementId?: number | null
    rateCardId?: number | null
    trackingNumber?: string | null
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.ShipmentStatus
    bookingStatus?: $Enums.BookingStatus | null
    paymentStatus?: $Enums.PaymentStatus | null
    cost?: number | null
    distance?: number | null
    estimatedDelivery?: Date | string | null
    pickupTime?: Date | string | null
    deliveryTime?: Date | string | null
    assignedToId?: number | null
    assignedDriver?: string | null
    driverPhone?: string | null
    driverEta?: Date | string | null
    transporterResponseNotes?: string | null
    notes?: string | null
    ewayBillNumber?: string | null
    gstInvoiceId?: number | null
    complianceStatus?: $Enums.ComplianceStatus
    source?: string
    podStatus?: string
    podUrl?: string | null
    podNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgreementCreateManyCompanyInput = {
    id?: number
    vendorId: number
    title: string
    referenceCode: string
    status?: string
    effectiveFrom?: Date | string | null
    effectiveTo?: Date | string | null
    notes?: string | null
    reviewedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransporterInvoiceCreateManyCompanyInput = {
    id?: number
    shipmentId: number
    invoiceNumber: string
    invoiceDate: Date | string
    invoiceAmount: number
    invoiceUrl: string
    approvalStatus?: string
    rejectionNotes?: string | null
    postedToErpAt?: Date | string | null
    approvedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyCompanyInput = {
    id?: number
    shipmentId: number
    invoiceNumber: string
    status?: $Enums.InvoiceStatus
    issuedAt?: Date | string | null
    dueDate?: Date | string | null
    subtotal?: number
    taxTotal?: number
    grandTotal?: number
    lineItems: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyProfileCreateManyCompanyInput = {
    id?: number
    legalName?: string | null
    gstin?: string | null
    pan?: string | null
    tan?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorCreateManyCompanyInput = {
    id?: number
    name: string
    email?: string | null
    phone?: string | null
    baseRate?: number | null
    rating?: number | null
    speed?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutCompanyInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorChannel?: NullableStringFieldUpdateOperationsInput | string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneWithoutUserNestedInput
    shipments?: ShipmentUpdateManyWithoutUserNestedInput
    assignedShipments?: ShipmentUpdateManyWithoutAssignedToNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    agreementsReviewed?: AgreementUpdateManyWithoutReviewedByNestedInput
    transporterInvoices?: TransporterInvoiceUpdateManyWithoutApprovedByNestedInput
    QuoteRequest?: QuoteRequestUpdateManyWithoutCreatedByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    twoFactorChallenges?: TwoFactorChallengeUpdateManyWithoutUserNestedInput
    userConsents?: UserConsentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorChannel?: NullableStringFieldUpdateOperationsInput | string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipments?: ShipmentUncheckedUpdateManyWithoutUserNestedInput
    assignedShipments?: ShipmentUncheckedUpdateManyWithoutAssignedToNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    agreementsReviewed?: AgreementUncheckedUpdateManyWithoutReviewedByNestedInput
    transporterInvoices?: TransporterInvoiceUncheckedUpdateManyWithoutApprovedByNestedInput
    QuoteRequest?: QuoteRequestUncheckedUpdateManyWithoutCreatedByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    twoFactorChallenges?: TwoFactorChallengeUncheckedUpdateManyWithoutUserNestedInput
    userConsents?: UserConsentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorChannel?: NullableStringFieldUpdateOperationsInput | string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShipmentUpdateWithoutCompanyInput = {
    agreementId?: NullableIntFieldUpdateOperationsInput | number | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedDriver?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    driverEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transporterResponseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ewayBillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstInvoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    source?: StringFieldUpdateOperationsInput | string
    podStatus?: StringFieldUpdateOperationsInput | string
    podUrl?: NullableStringFieldUpdateOperationsInput | string | null
    podNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutShipmentsNestedInput
    quoteRequest?: QuoteRequestUpdateOneWithoutShipmentNestedInput
    transporterQuote?: QuoteResponseUpdateOneWithoutShipmentNestedInput
    rateCard?: RateCardUpdateOneWithoutShipmentsNestedInput
    vendor?: VendorUpdateOneWithoutShipmentsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedShipmentsNestedInput
    statusHistory?: StatusHistoryUpdateManyWithoutShipmentNestedInput
    complianceDocs?: ComplianceDocumentUpdateManyWithoutShipmentNestedInput
    payments?: PaymentUpdateManyWithoutShipmentNestedInput
    invoice?: InvoiceUpdateOneWithoutShipmentNestedInput
    consentLogs?: ConsentLogUpdateManyWithoutShipmentNestedInput
    transporterInvoices?: TransporterInvoiceUpdateManyWithoutShipmentNestedInput
  }

  export type ShipmentUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    quoteRequestId?: NullableIntFieldUpdateOperationsInput | number | null
    transporterQuoteId?: NullableIntFieldUpdateOperationsInput | number | null
    selectedVendorId?: NullableIntFieldUpdateOperationsInput | number | null
    agreementId?: NullableIntFieldUpdateOperationsInput | number | null
    rateCardId?: NullableIntFieldUpdateOperationsInput | number | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedDriver?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    driverEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transporterResponseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ewayBillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstInvoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    source?: StringFieldUpdateOperationsInput | string
    podStatus?: StringFieldUpdateOperationsInput | string
    podUrl?: NullableStringFieldUpdateOperationsInput | string | null
    podNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusHistory?: StatusHistoryUncheckedUpdateManyWithoutShipmentNestedInput
    complianceDocs?: ComplianceDocumentUncheckedUpdateManyWithoutShipmentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutShipmentNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutShipmentNestedInput
    consentLogs?: ConsentLogUncheckedUpdateManyWithoutShipmentNestedInput
    transporterInvoices?: TransporterInvoiceUncheckedUpdateManyWithoutShipmentNestedInput
  }

  export type ShipmentUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    quoteRequestId?: NullableIntFieldUpdateOperationsInput | number | null
    transporterQuoteId?: NullableIntFieldUpdateOperationsInput | number | null
    selectedVendorId?: NullableIntFieldUpdateOperationsInput | number | null
    agreementId?: NullableIntFieldUpdateOperationsInput | number | null
    rateCardId?: NullableIntFieldUpdateOperationsInput | number | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedDriver?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    driverEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transporterResponseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ewayBillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstInvoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    source?: StringFieldUpdateOperationsInput | string
    podStatus?: StringFieldUpdateOperationsInput | string
    podUrl?: NullableStringFieldUpdateOperationsInput | string | null
    podNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgreementUpdateWithoutCompanyInput = {
    title?: StringFieldUpdateOperationsInput | string
    referenceCode?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutAgreementsNestedInput
    reviewedBy?: UserUpdateOneWithoutAgreementsReviewedNestedInput
    rateCards?: RateCardUpdateManyWithoutAgreementNestedInput
  }

  export type AgreementUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    referenceCode?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rateCards?: RateCardUncheckedUpdateManyWithoutAgreementNestedInput
  }

  export type AgreementUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    referenceCode?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransporterInvoiceUpdateWithoutCompanyInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceAmount?: FloatFieldUpdateOperationsInput | number
    invoiceUrl?: StringFieldUpdateOperationsInput | string
    approvalStatus?: StringFieldUpdateOperationsInput | string
    rejectionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    postedToErpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipment?: ShipmentUpdateOneRequiredWithoutTransporterInvoicesNestedInput
    approvedBy?: UserUpdateOneWithoutTransporterInvoicesNestedInput
  }

  export type TransporterInvoiceUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipmentId?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceAmount?: FloatFieldUpdateOperationsInput | number
    invoiceUrl?: StringFieldUpdateOperationsInput | string
    approvalStatus?: StringFieldUpdateOperationsInput | string
    rejectionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    postedToErpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransporterInvoiceUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipmentId?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceAmount?: FloatFieldUpdateOperationsInput | number
    invoiceUrl?: StringFieldUpdateOperationsInput | string
    approvalStatus?: StringFieldUpdateOperationsInput | string
    rejectionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    postedToErpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutCompanyInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxTotal?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    lineItems?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipment?: ShipmentUpdateOneRequiredWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipmentId?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxTotal?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    lineItems?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipmentId?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxTotal?: FloatFieldUpdateOperationsInput | number
    grandTotal?: FloatFieldUpdateOperationsInput | number
    lineItems?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyProfileUpdateWithoutCompanyInput = {
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    tan?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyProfileUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    tan?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyProfileUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    tan?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUpdateWithoutCompanyInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    baseRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: VendorProfileUpdateOneWithoutVendorNestedInput
    agreements?: AgreementUpdateManyWithoutVendorNestedInput
    rateCards?: RateCardUpdateManyWithoutVendorNestedInput
    quoteResponses?: QuoteResponseUpdateManyWithoutVendorNestedInput
    shipments?: ShipmentUpdateManyWithoutVendorNestedInput
    drivers?: DriverUpdateManyWithoutVendorNestedInput
    User?: UserUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    baseRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: VendorProfileUncheckedUpdateOneWithoutVendorNestedInput
    agreements?: AgreementUncheckedUpdateManyWithoutVendorNestedInput
    rateCards?: RateCardUncheckedUpdateManyWithoutVendorNestedInput
    quoteResponses?: QuoteResponseUncheckedUpdateManyWithoutVendorNestedInput
    shipments?: ShipmentUncheckedUpdateManyWithoutVendorNestedInput
    drivers?: DriverUncheckedUpdateManyWithoutVendorNestedInput
    User?: UserUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    baseRate?: NullableFloatFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShipmentCreateManyUserInput = {
    id?: number
    companyId?: number | null
    quoteRequestId?: number | null
    transporterQuoteId?: number | null
    selectedVendorId?: number | null
    agreementId?: number | null
    rateCardId?: number | null
    trackingNumber?: string | null
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.ShipmentStatus
    bookingStatus?: $Enums.BookingStatus | null
    paymentStatus?: $Enums.PaymentStatus | null
    cost?: number | null
    distance?: number | null
    estimatedDelivery?: Date | string | null
    pickupTime?: Date | string | null
    deliveryTime?: Date | string | null
    assignedToId?: number | null
    assignedDriver?: string | null
    driverPhone?: string | null
    driverEta?: Date | string | null
    transporterResponseNotes?: string | null
    notes?: string | null
    ewayBillNumber?: string | null
    gstInvoiceId?: number | null
    complianceStatus?: $Enums.ComplianceStatus
    source?: string
    podStatus?: string
    podUrl?: string | null
    podNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShipmentCreateManyAssignedToInput = {
    id?: number
    userId: number
    companyId?: number | null
    quoteRequestId?: number | null
    transporterQuoteId?: number | null
    selectedVendorId?: number | null
    agreementId?: number | null
    rateCardId?: number | null
    trackingNumber?: string | null
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.ShipmentStatus
    bookingStatus?: $Enums.BookingStatus | null
    paymentStatus?: $Enums.PaymentStatus | null
    cost?: number | null
    distance?: number | null
    estimatedDelivery?: Date | string | null
    pickupTime?: Date | string | null
    deliveryTime?: Date | string | null
    assignedDriver?: string | null
    driverPhone?: string | null
    driverEta?: Date | string | null
    transporterResponseNotes?: string | null
    notes?: string | null
    ewayBillNumber?: string | null
    gstInvoiceId?: number | null
    complianceStatus?: $Enums.ComplianceStatus
    source?: string
    podStatus?: string
    podUrl?: string | null
    podNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: number
    title: string
    message: string
    type: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRead?: boolean
    createdAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: number
    action: string
    entityType: string
    entityId?: number | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AgreementCreateManyReviewedByInput = {
    id?: number
    vendorId: number
    title: string
    referenceCode: string
    status?: string
    effectiveFrom?: Date | string | null
    effectiveTo?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: number | null
  }

  export type TransporterInvoiceCreateManyApprovedByInput = {
    id?: number
    companyId: number
    shipmentId: number
    invoiceNumber: string
    invoiceDate: Date | string
    invoiceAmount: number
    invoiceUrl: string
    approvalStatus?: string
    rejectionNotes?: string | null
    postedToErpAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuoteRequestCreateManyCreatedByInput = {
    id?: number
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.QuoteStatus
    notes?: string | null
    approvedResponseId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasswordResetTokenCreateManyUserInput = {
    id?: number
    tokenHash: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
  }

  export type TwoFactorChallengeCreateManyUserInput = {
    id?: number
    codeHash: string
    expiresAt: Date | string
    consumed?: boolean
    createdAt?: Date | string
  }

  export type UserConsentCreateManyUserInput = {
    id?: number
    consentType: string
    status?: $Enums.ConsentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    recordedAt?: Date | string
  }

  export type ShipmentUpdateWithoutUserInput = {
    agreementId?: NullableIntFieldUpdateOperationsInput | number | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedDriver?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    driverEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transporterResponseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ewayBillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstInvoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    source?: StringFieldUpdateOperationsInput | string
    podStatus?: StringFieldUpdateOperationsInput | string
    podUrl?: NullableStringFieldUpdateOperationsInput | string | null
    podNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutShipmentsNestedInput
    quoteRequest?: QuoteRequestUpdateOneWithoutShipmentNestedInput
    transporterQuote?: QuoteResponseUpdateOneWithoutShipmentNestedInput
    rateCard?: RateCardUpdateOneWithoutShipmentsNestedInput
    vendor?: VendorUpdateOneWithoutShipmentsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedShipmentsNestedInput
    statusHistory?: StatusHistoryUpdateManyWithoutShipmentNestedInput
    complianceDocs?: ComplianceDocumentUpdateManyWithoutShipmentNestedInput
    payments?: PaymentUpdateManyWithoutShipmentNestedInput
    invoice?: InvoiceUpdateOneWithoutShipmentNestedInput
    consentLogs?: ConsentLogUpdateManyWithoutShipmentNestedInput
    transporterInvoices?: TransporterInvoiceUpdateManyWithoutShipmentNestedInput
  }

  export type ShipmentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    quoteRequestId?: NullableIntFieldUpdateOperationsInput | number | null
    transporterQuoteId?: NullableIntFieldUpdateOperationsInput | number | null
    selectedVendorId?: NullableIntFieldUpdateOperationsInput | number | null
    agreementId?: NullableIntFieldUpdateOperationsInput | number | null
    rateCardId?: NullableIntFieldUpdateOperationsInput | number | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedDriver?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    driverEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transporterResponseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ewayBillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstInvoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    source?: StringFieldUpdateOperationsInput | string
    podStatus?: StringFieldUpdateOperationsInput | string
    podUrl?: NullableStringFieldUpdateOperationsInput | string | null
    podNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusHistory?: StatusHistoryUncheckedUpdateManyWithoutShipmentNestedInput
    complianceDocs?: ComplianceDocumentUncheckedUpdateManyWithoutShipmentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutShipmentNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutShipmentNestedInput
    consentLogs?: ConsentLogUncheckedUpdateManyWithoutShipmentNestedInput
    transporterInvoices?: TransporterInvoiceUncheckedUpdateManyWithoutShipmentNestedInput
  }

  export type ShipmentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    quoteRequestId?: NullableIntFieldUpdateOperationsInput | number | null
    transporterQuoteId?: NullableIntFieldUpdateOperationsInput | number | null
    selectedVendorId?: NullableIntFieldUpdateOperationsInput | number | null
    agreementId?: NullableIntFieldUpdateOperationsInput | number | null
    rateCardId?: NullableIntFieldUpdateOperationsInput | number | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedDriver?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    driverEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transporterResponseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ewayBillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstInvoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    source?: StringFieldUpdateOperationsInput | string
    podStatus?: StringFieldUpdateOperationsInput | string
    podUrl?: NullableStringFieldUpdateOperationsInput | string | null
    podNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShipmentUpdateWithoutAssignedToInput = {
    agreementId?: NullableIntFieldUpdateOperationsInput | number | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedDriver?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    driverEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transporterResponseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ewayBillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstInvoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    source?: StringFieldUpdateOperationsInput | string
    podStatus?: StringFieldUpdateOperationsInput | string
    podUrl?: NullableStringFieldUpdateOperationsInput | string | null
    podNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutShipmentsNestedInput
    company?: CompanyUpdateOneWithoutShipmentsNestedInput
    quoteRequest?: QuoteRequestUpdateOneWithoutShipmentNestedInput
    transporterQuote?: QuoteResponseUpdateOneWithoutShipmentNestedInput
    rateCard?: RateCardUpdateOneWithoutShipmentsNestedInput
    vendor?: VendorUpdateOneWithoutShipmentsNestedInput
    statusHistory?: StatusHistoryUpdateManyWithoutShipmentNestedInput
    complianceDocs?: ComplianceDocumentUpdateManyWithoutShipmentNestedInput
    payments?: PaymentUpdateManyWithoutShipmentNestedInput
    invoice?: InvoiceUpdateOneWithoutShipmentNestedInput
    consentLogs?: ConsentLogUpdateManyWithoutShipmentNestedInput
    transporterInvoices?: TransporterInvoiceUpdateManyWithoutShipmentNestedInput
  }

  export type ShipmentUncheckedUpdateWithoutAssignedToInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    quoteRequestId?: NullableIntFieldUpdateOperationsInput | number | null
    transporterQuoteId?: NullableIntFieldUpdateOperationsInput | number | null
    selectedVendorId?: NullableIntFieldUpdateOperationsInput | number | null
    agreementId?: NullableIntFieldUpdateOperationsInput | number | null
    rateCardId?: NullableIntFieldUpdateOperationsInput | number | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedDriver?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    driverEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transporterResponseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ewayBillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstInvoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    source?: StringFieldUpdateOperationsInput | string
    podStatus?: StringFieldUpdateOperationsInput | string
    podUrl?: NullableStringFieldUpdateOperationsInput | string | null
    podNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusHistory?: StatusHistoryUncheckedUpdateManyWithoutShipmentNestedInput
    complianceDocs?: ComplianceDocumentUncheckedUpdateManyWithoutShipmentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutShipmentNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutShipmentNestedInput
    consentLogs?: ConsentLogUncheckedUpdateManyWithoutShipmentNestedInput
    transporterInvoices?: TransporterInvoiceUncheckedUpdateManyWithoutShipmentNestedInput
  }

  export type ShipmentUncheckedUpdateManyWithoutAssignedToInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    quoteRequestId?: NullableIntFieldUpdateOperationsInput | number | null
    transporterQuoteId?: NullableIntFieldUpdateOperationsInput | number | null
    selectedVendorId?: NullableIntFieldUpdateOperationsInput | number | null
    agreementId?: NullableIntFieldUpdateOperationsInput | number | null
    rateCardId?: NullableIntFieldUpdateOperationsInput | number | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedDriver?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    driverEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transporterResponseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ewayBillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstInvoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    source?: StringFieldUpdateOperationsInput | string
    podStatus?: StringFieldUpdateOperationsInput | string
    podUrl?: NullableStringFieldUpdateOperationsInput | string | null
    podNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgreementUpdateWithoutReviewedByInput = {
    title?: StringFieldUpdateOperationsInput | string
    referenceCode?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutAgreementsNestedInput
    rateCards?: RateCardUpdateManyWithoutAgreementNestedInput
    Company?: CompanyUpdateOneWithoutAgreementsNestedInput
  }

  export type AgreementUncheckedUpdateWithoutReviewedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    referenceCode?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    rateCards?: RateCardUncheckedUpdateManyWithoutAgreementNestedInput
  }

  export type AgreementUncheckedUpdateManyWithoutReviewedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    referenceCode?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TransporterInvoiceUpdateWithoutApprovedByInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceAmount?: FloatFieldUpdateOperationsInput | number
    invoiceUrl?: StringFieldUpdateOperationsInput | string
    approvalStatus?: StringFieldUpdateOperationsInput | string
    rejectionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    postedToErpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutTransporterInvoicesNestedInput
    shipment?: ShipmentUpdateOneRequiredWithoutTransporterInvoicesNestedInput
  }

  export type TransporterInvoiceUncheckedUpdateWithoutApprovedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    shipmentId?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceAmount?: FloatFieldUpdateOperationsInput | number
    invoiceUrl?: StringFieldUpdateOperationsInput | string
    approvalStatus?: StringFieldUpdateOperationsInput | string
    rejectionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    postedToErpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransporterInvoiceUncheckedUpdateManyWithoutApprovedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    shipmentId?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceAmount?: FloatFieldUpdateOperationsInput | number
    invoiceUrl?: StringFieldUpdateOperationsInput | string
    approvalStatus?: StringFieldUpdateOperationsInput | string
    rejectionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    postedToErpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteRequestUpdateWithoutCreatedByInput = {
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: QuoteResponseUpdateManyWithoutQuoteRequestNestedInput
    approvedResponse?: QuoteResponseUpdateOneWithoutApprovedForNestedInput
    shipment?: ShipmentUpdateOneWithoutQuoteRequestNestedInput
  }

  export type QuoteRequestUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedResponseId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: QuoteResponseUncheckedUpdateManyWithoutQuoteRequestNestedInput
    shipment?: ShipmentUncheckedUpdateOneWithoutQuoteRequestNestedInput
  }

  export type QuoteRequestUncheckedUpdateManyWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedResponseId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUpdateWithoutUserInput = {
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorChallengeUpdateWithoutUserInput = {
    codeHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consumed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorChallengeUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    codeHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consumed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorChallengeUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    codeHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consumed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserConsentUpdateWithoutUserInput = {
    consentType?: StringFieldUpdateOperationsInput | string
    status?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserConsentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    consentType?: StringFieldUpdateOperationsInput | string
    status?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserConsentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    consentType?: StringFieldUpdateOperationsInput | string
    status?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgreementCreateManyVendorInput = {
    id?: number
    title: string
    referenceCode: string
    status?: string
    effectiveFrom?: Date | string | null
    effectiveTo?: Date | string | null
    notes?: string | null
    reviewedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: number | null
  }

  export type RateCardCreateManyVendorInput = {
    id?: number
    agreementId: number
    routeName: string
    origin: string
    destination: string
    distanceKm?: number | null
    ratePerKm: number
    uom: string
    vehicleType: string
    effectiveFrom?: Date | string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuoteResponseCreateManyVendorInput = {
    id?: number
    quoteRequestId: number
    quotedPrice?: number | null
    estimatedDelivery?: Date | string | null
    expiresAt?: Date | string | null
    status?: $Enums.QuoteResponseStatus
    consentStatus?: $Enums.ConsentStatus
    notes?: string | null
    transporterNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShipmentCreateManyVendorInput = {
    id?: number
    userId: number
    companyId?: number | null
    quoteRequestId?: number | null
    transporterQuoteId?: number | null
    agreementId?: number | null
    rateCardId?: number | null
    trackingNumber?: string | null
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.ShipmentStatus
    bookingStatus?: $Enums.BookingStatus | null
    paymentStatus?: $Enums.PaymentStatus | null
    cost?: number | null
    distance?: number | null
    estimatedDelivery?: Date | string | null
    pickupTime?: Date | string | null
    deliveryTime?: Date | string | null
    assignedToId?: number | null
    assignedDriver?: string | null
    driverPhone?: string | null
    driverEta?: Date | string | null
    transporterResponseNotes?: string | null
    notes?: string | null
    ewayBillNumber?: string | null
    gstInvoiceId?: number | null
    complianceStatus?: $Enums.ComplianceStatus
    source?: string
    podStatus?: string
    podUrl?: string | null
    podNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DriverCreateManyVendorInput = {
    id?: number
    name: string
    phone?: string | null
    licenseNumber?: string | null
    vehicleNumber?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateManyVendorInput = {
    id?: number
    email: string
    passwordHash: string
    name?: string | null
    phone?: string | null
    role?: $Enums.Role
    approvalStatus?: $Enums.ApprovalStatus
    approvalNote?: string | null
    rejectionReason?: string | null
    reviewedById?: number | null
    reviewedAt?: Date | string | null
    isActive?: boolean
    companyId?: number | null
    lastLoginAt?: Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: boolean
    twoFactorChannel?: string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgreementUpdateWithoutVendorInput = {
    title?: StringFieldUpdateOperationsInput | string
    referenceCode?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedBy?: UserUpdateOneWithoutAgreementsReviewedNestedInput
    rateCards?: RateCardUpdateManyWithoutAgreementNestedInput
    Company?: CompanyUpdateOneWithoutAgreementsNestedInput
  }

  export type AgreementUncheckedUpdateWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    referenceCode?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    rateCards?: RateCardUncheckedUpdateManyWithoutAgreementNestedInput
  }

  export type AgreementUncheckedUpdateManyWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    referenceCode?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RateCardUpdateWithoutVendorInput = {
    routeName?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    distanceKm?: NullableFloatFieldUpdateOperationsInput | number | null
    ratePerKm?: FloatFieldUpdateOperationsInput | number
    uom?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agreement?: AgreementUpdateOneRequiredWithoutRateCardsNestedInput
    shipments?: ShipmentUpdateManyWithoutRateCardNestedInput
  }

  export type RateCardUncheckedUpdateWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    agreementId?: IntFieldUpdateOperationsInput | number
    routeName?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    distanceKm?: NullableFloatFieldUpdateOperationsInput | number | null
    ratePerKm?: FloatFieldUpdateOperationsInput | number
    uom?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipments?: ShipmentUncheckedUpdateManyWithoutRateCardNestedInput
  }

  export type RateCardUncheckedUpdateManyWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    agreementId?: IntFieldUpdateOperationsInput | number
    routeName?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    distanceKm?: NullableFloatFieldUpdateOperationsInput | number | null
    ratePerKm?: FloatFieldUpdateOperationsInput | number
    uom?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteResponseUpdateWithoutVendorInput = {
    quotedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumQuoteResponseStatusFieldUpdateOperationsInput | $Enums.QuoteResponseStatus
    consentStatus?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    transporterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quoteRequest?: QuoteRequestUpdateOneRequiredWithoutResponsesNestedInput
    shipment?: ShipmentUpdateOneWithoutTransporterQuoteNestedInput
    approvedFor?: QuoteRequestUpdateOneWithoutApprovedResponseNestedInput
    consentLogs?: ConsentLogUpdateManyWithoutQuoteResponseNestedInput
  }

  export type QuoteResponseUncheckedUpdateWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    quoteRequestId?: IntFieldUpdateOperationsInput | number
    quotedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumQuoteResponseStatusFieldUpdateOperationsInput | $Enums.QuoteResponseStatus
    consentStatus?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    transporterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipment?: ShipmentUncheckedUpdateOneWithoutTransporterQuoteNestedInput
    approvedFor?: QuoteRequestUncheckedUpdateOneWithoutApprovedResponseNestedInput
    consentLogs?: ConsentLogUncheckedUpdateManyWithoutQuoteResponseNestedInput
  }

  export type QuoteResponseUncheckedUpdateManyWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    quoteRequestId?: IntFieldUpdateOperationsInput | number
    quotedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumQuoteResponseStatusFieldUpdateOperationsInput | $Enums.QuoteResponseStatus
    consentStatus?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    transporterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShipmentUpdateWithoutVendorInput = {
    agreementId?: NullableIntFieldUpdateOperationsInput | number | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedDriver?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    driverEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transporterResponseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ewayBillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstInvoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    source?: StringFieldUpdateOperationsInput | string
    podStatus?: StringFieldUpdateOperationsInput | string
    podUrl?: NullableStringFieldUpdateOperationsInput | string | null
    podNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutShipmentsNestedInput
    company?: CompanyUpdateOneWithoutShipmentsNestedInput
    quoteRequest?: QuoteRequestUpdateOneWithoutShipmentNestedInput
    transporterQuote?: QuoteResponseUpdateOneWithoutShipmentNestedInput
    rateCard?: RateCardUpdateOneWithoutShipmentsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedShipmentsNestedInput
    statusHistory?: StatusHistoryUpdateManyWithoutShipmentNestedInput
    complianceDocs?: ComplianceDocumentUpdateManyWithoutShipmentNestedInput
    payments?: PaymentUpdateManyWithoutShipmentNestedInput
    invoice?: InvoiceUpdateOneWithoutShipmentNestedInput
    consentLogs?: ConsentLogUpdateManyWithoutShipmentNestedInput
    transporterInvoices?: TransporterInvoiceUpdateManyWithoutShipmentNestedInput
  }

  export type ShipmentUncheckedUpdateWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    quoteRequestId?: NullableIntFieldUpdateOperationsInput | number | null
    transporterQuoteId?: NullableIntFieldUpdateOperationsInput | number | null
    agreementId?: NullableIntFieldUpdateOperationsInput | number | null
    rateCardId?: NullableIntFieldUpdateOperationsInput | number | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedDriver?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    driverEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transporterResponseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ewayBillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstInvoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    source?: StringFieldUpdateOperationsInput | string
    podStatus?: StringFieldUpdateOperationsInput | string
    podUrl?: NullableStringFieldUpdateOperationsInput | string | null
    podNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusHistory?: StatusHistoryUncheckedUpdateManyWithoutShipmentNestedInput
    complianceDocs?: ComplianceDocumentUncheckedUpdateManyWithoutShipmentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutShipmentNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutShipmentNestedInput
    consentLogs?: ConsentLogUncheckedUpdateManyWithoutShipmentNestedInput
    transporterInvoices?: TransporterInvoiceUncheckedUpdateManyWithoutShipmentNestedInput
  }

  export type ShipmentUncheckedUpdateManyWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    quoteRequestId?: NullableIntFieldUpdateOperationsInput | number | null
    transporterQuoteId?: NullableIntFieldUpdateOperationsInput | number | null
    agreementId?: NullableIntFieldUpdateOperationsInput | number | null
    rateCardId?: NullableIntFieldUpdateOperationsInput | number | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedDriver?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    driverEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transporterResponseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ewayBillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstInvoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    source?: StringFieldUpdateOperationsInput | string
    podStatus?: StringFieldUpdateOperationsInput | string
    podUrl?: NullableStringFieldUpdateOperationsInput | string | null
    podNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverUpdateWithoutVendorInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverUncheckedUpdateWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverUncheckedUpdateManyWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutVendorInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorChannel?: NullableStringFieldUpdateOperationsInput | string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutUsersNestedInput
    shipments?: ShipmentUpdateManyWithoutUserNestedInput
    assignedShipments?: ShipmentUpdateManyWithoutAssignedToNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    agreementsReviewed?: AgreementUpdateManyWithoutReviewedByNestedInput
    transporterInvoices?: TransporterInvoiceUpdateManyWithoutApprovedByNestedInput
    QuoteRequest?: QuoteRequestUpdateManyWithoutCreatedByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    twoFactorChallenges?: TwoFactorChallengeUpdateManyWithoutUserNestedInput
    userConsents?: UserConsentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorChannel?: NullableStringFieldUpdateOperationsInput | string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipments?: ShipmentUncheckedUpdateManyWithoutUserNestedInput
    assignedShipments?: ShipmentUncheckedUpdateManyWithoutAssignedToNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    agreementsReviewed?: AgreementUncheckedUpdateManyWithoutReviewedByNestedInput
    transporterInvoices?: TransporterInvoiceUncheckedUpdateManyWithoutApprovedByNestedInput
    QuoteRequest?: QuoteRequestUncheckedUpdateManyWithoutCreatedByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    twoFactorChallenges?: TwoFactorChallengeUncheckedUpdateManyWithoutUserNestedInput
    userConsents?: UserConsentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notificationPreferences?: NullableJsonNullValueInput | InputJsonValue
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorChannel?: NullableStringFieldUpdateOperationsInput | string | null
    allowedIpRanges?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RateCardCreateManyAgreementInput = {
    id?: number
    routeName: string
    origin: string
    destination: string
    distanceKm?: number | null
    ratePerKm: number
    uom: string
    vehicleType: string
    effectiveFrom?: Date | string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendorId?: number | null
  }

  export type RateCardUpdateWithoutAgreementInput = {
    routeName?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    distanceKm?: NullableFloatFieldUpdateOperationsInput | number | null
    ratePerKm?: FloatFieldUpdateOperationsInput | number
    uom?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Vendor?: VendorUpdateOneWithoutRateCardsNestedInput
    shipments?: ShipmentUpdateManyWithoutRateCardNestedInput
  }

  export type RateCardUncheckedUpdateWithoutAgreementInput = {
    id?: IntFieldUpdateOperationsInput | number
    routeName?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    distanceKm?: NullableFloatFieldUpdateOperationsInput | number | null
    ratePerKm?: FloatFieldUpdateOperationsInput | number
    uom?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    shipments?: ShipmentUncheckedUpdateManyWithoutRateCardNestedInput
  }

  export type RateCardUncheckedUpdateManyWithoutAgreementInput = {
    id?: IntFieldUpdateOperationsInput | number
    routeName?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    distanceKm?: NullableFloatFieldUpdateOperationsInput | number | null
    ratePerKm?: FloatFieldUpdateOperationsInput | number
    uom?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ShipmentCreateManyRateCardInput = {
    id?: number
    userId: number
    companyId?: number | null
    quoteRequestId?: number | null
    transporterQuoteId?: number | null
    selectedVendorId?: number | null
    agreementId?: number | null
    trackingNumber?: string | null
    fromLocation: string
    toLocation: string
    fromLat?: number | null
    fromLng?: number | null
    toLat?: number | null
    toLng?: number | null
    weight?: number | null
    shipmentType?: string | null
    urgency?: string | null
    status?: $Enums.ShipmentStatus
    bookingStatus?: $Enums.BookingStatus | null
    paymentStatus?: $Enums.PaymentStatus | null
    cost?: number | null
    distance?: number | null
    estimatedDelivery?: Date | string | null
    pickupTime?: Date | string | null
    deliveryTime?: Date | string | null
    assignedToId?: number | null
    assignedDriver?: string | null
    driverPhone?: string | null
    driverEta?: Date | string | null
    transporterResponseNotes?: string | null
    notes?: string | null
    ewayBillNumber?: string | null
    gstInvoiceId?: number | null
    complianceStatus?: $Enums.ComplianceStatus
    source?: string
    podStatus?: string
    podUrl?: string | null
    podNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShipmentUpdateWithoutRateCardInput = {
    agreementId?: NullableIntFieldUpdateOperationsInput | number | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedDriver?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    driverEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transporterResponseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ewayBillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstInvoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    source?: StringFieldUpdateOperationsInput | string
    podStatus?: StringFieldUpdateOperationsInput | string
    podUrl?: NullableStringFieldUpdateOperationsInput | string | null
    podNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutShipmentsNestedInput
    company?: CompanyUpdateOneWithoutShipmentsNestedInput
    quoteRequest?: QuoteRequestUpdateOneWithoutShipmentNestedInput
    transporterQuote?: QuoteResponseUpdateOneWithoutShipmentNestedInput
    vendor?: VendorUpdateOneWithoutShipmentsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedShipmentsNestedInput
    statusHistory?: StatusHistoryUpdateManyWithoutShipmentNestedInput
    complianceDocs?: ComplianceDocumentUpdateManyWithoutShipmentNestedInput
    payments?: PaymentUpdateManyWithoutShipmentNestedInput
    invoice?: InvoiceUpdateOneWithoutShipmentNestedInput
    consentLogs?: ConsentLogUpdateManyWithoutShipmentNestedInput
    transporterInvoices?: TransporterInvoiceUpdateManyWithoutShipmentNestedInput
  }

  export type ShipmentUncheckedUpdateWithoutRateCardInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    quoteRequestId?: NullableIntFieldUpdateOperationsInput | number | null
    transporterQuoteId?: NullableIntFieldUpdateOperationsInput | number | null
    selectedVendorId?: NullableIntFieldUpdateOperationsInput | number | null
    agreementId?: NullableIntFieldUpdateOperationsInput | number | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedDriver?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    driverEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transporterResponseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ewayBillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstInvoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    source?: StringFieldUpdateOperationsInput | string
    podStatus?: StringFieldUpdateOperationsInput | string
    podUrl?: NullableStringFieldUpdateOperationsInput | string | null
    podNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusHistory?: StatusHistoryUncheckedUpdateManyWithoutShipmentNestedInput
    complianceDocs?: ComplianceDocumentUncheckedUpdateManyWithoutShipmentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutShipmentNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutShipmentNestedInput
    consentLogs?: ConsentLogUncheckedUpdateManyWithoutShipmentNestedInput
    transporterInvoices?: TransporterInvoiceUncheckedUpdateManyWithoutShipmentNestedInput
  }

  export type ShipmentUncheckedUpdateManyWithoutRateCardInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    quoteRequestId?: NullableIntFieldUpdateOperationsInput | number | null
    transporterQuoteId?: NullableIntFieldUpdateOperationsInput | number | null
    selectedVendorId?: NullableIntFieldUpdateOperationsInput | number | null
    agreementId?: NullableIntFieldUpdateOperationsInput | number | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    fromLocation?: StringFieldUpdateOperationsInput | string
    toLocation?: StringFieldUpdateOperationsInput | string
    fromLat?: NullableFloatFieldUpdateOperationsInput | number | null
    fromLng?: NullableFloatFieldUpdateOperationsInput | number | null
    toLat?: NullableFloatFieldUpdateOperationsInput | number | null
    toLng?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    shipmentType?: NullableStringFieldUpdateOperationsInput | string | null
    urgency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedDriver?: NullableStringFieldUpdateOperationsInput | string | null
    driverPhone?: NullableStringFieldUpdateOperationsInput | string | null
    driverEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transporterResponseNotes?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ewayBillNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstInvoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    source?: StringFieldUpdateOperationsInput | string
    podStatus?: StringFieldUpdateOperationsInput | string
    podUrl?: NullableStringFieldUpdateOperationsInput | string | null
    podNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteResponseCreateManyQuoteRequestInput = {
    id?: number
    vendorId: number
    quotedPrice?: number | null
    estimatedDelivery?: Date | string | null
    expiresAt?: Date | string | null
    status?: $Enums.QuoteResponseStatus
    consentStatus?: $Enums.ConsentStatus
    notes?: string | null
    transporterNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuoteResponseUpdateWithoutQuoteRequestInput = {
    quotedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumQuoteResponseStatusFieldUpdateOperationsInput | $Enums.QuoteResponseStatus
    consentStatus?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    transporterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutQuoteResponsesNestedInput
    shipment?: ShipmentUpdateOneWithoutTransporterQuoteNestedInput
    approvedFor?: QuoteRequestUpdateOneWithoutApprovedResponseNestedInput
    consentLogs?: ConsentLogUpdateManyWithoutQuoteResponseNestedInput
  }

  export type QuoteResponseUncheckedUpdateWithoutQuoteRequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    quotedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumQuoteResponseStatusFieldUpdateOperationsInput | $Enums.QuoteResponseStatus
    consentStatus?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    transporterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipment?: ShipmentUncheckedUpdateOneWithoutTransporterQuoteNestedInput
    approvedFor?: QuoteRequestUncheckedUpdateOneWithoutApprovedResponseNestedInput
    consentLogs?: ConsentLogUncheckedUpdateManyWithoutQuoteResponseNestedInput
  }

  export type QuoteResponseUncheckedUpdateManyWithoutQuoteRequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    quotedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumQuoteResponseStatusFieldUpdateOperationsInput | $Enums.QuoteResponseStatus
    consentStatus?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    transporterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsentLogCreateManyQuoteResponseInput = {
    id?: number
    shipmentId?: number | null
    statusBefore: $Enums.ConsentStatus
    statusAfter: $Enums.ConsentStatus
    note?: string | null
    recordedAt?: Date | string
  }

  export type ConsentLogUpdateWithoutQuoteResponseInput = {
    statusBefore?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    statusAfter?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipment?: ShipmentUpdateOneWithoutConsentLogsNestedInput
  }

  export type ConsentLogUncheckedUpdateWithoutQuoteResponseInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipmentId?: NullableIntFieldUpdateOperationsInput | number | null
    statusBefore?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    statusAfter?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsentLogUncheckedUpdateManyWithoutQuoteResponseInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipmentId?: NullableIntFieldUpdateOperationsInput | number | null
    statusBefore?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    statusAfter?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusHistoryCreateManyShipmentInput = {
    id?: number
    status: $Enums.ShipmentStatus
    notes?: string | null
    latitude?: number | null
    longitude?: number | null
    location?: string | null
    updatedBy?: number | null
    timestamp?: Date | string
  }

  export type ComplianceDocumentCreateManyShipmentInput = {
    id?: number
    type: $Enums.DocumentType
    status?: $Enums.ComplianceStatus
    issuedAt?: Date | string | null
    fileUrl?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyShipmentInput = {
    id?: number
    invoiceId: number
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    gateway?: string
    transactionRef?: string | null
    authorizedAt?: Date | string | null
    capturedAt?: Date | string | null
    failureReason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tdsAmount?: number | null
    tcsAmount?: number | null
    rcmLiability?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConsentLogCreateManyShipmentInput = {
    id?: number
    quoteResponseId: number
    statusBefore: $Enums.ConsentStatus
    statusAfter: $Enums.ConsentStatus
    note?: string | null
    recordedAt?: Date | string
  }

  export type TransporterInvoiceCreateManyShipmentInput = {
    id?: number
    companyId: number
    invoiceNumber: string
    invoiceDate: Date | string
    invoiceAmount: number
    invoiceUrl: string
    approvalStatus?: string
    rejectionNotes?: string | null
    postedToErpAt?: Date | string | null
    approvedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StatusHistoryUpdateWithoutShipmentInput = {
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusHistoryUncheckedUpdateWithoutShipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusHistoryUncheckedUpdateManyWithoutShipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceDocumentUpdateWithoutShipmentInput = {
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: ComplianceEventUpdateManyWithoutDocumentNestedInput
  }

  export type ComplianceDocumentUncheckedUpdateWithoutShipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: ComplianceEventUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type ComplianceDocumentUncheckedUpdateManyWithoutShipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutShipmentInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gateway?: StringFieldUpdateOperationsInput | string
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    authorizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tdsAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    tcsAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    rcmLiability?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentsNestedInput
    events?: PaymentEventUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutShipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gateway?: StringFieldUpdateOperationsInput | string
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    authorizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tdsAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    tcsAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    rcmLiability?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: PaymentEventUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutShipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gateway?: StringFieldUpdateOperationsInput | string
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    authorizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tdsAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    tcsAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    rcmLiability?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsentLogUpdateWithoutShipmentInput = {
    statusBefore?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    statusAfter?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quoteResponse?: QuoteResponseUpdateOneRequiredWithoutConsentLogsNestedInput
  }

  export type ConsentLogUncheckedUpdateWithoutShipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    quoteResponseId?: IntFieldUpdateOperationsInput | number
    statusBefore?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    statusAfter?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsentLogUncheckedUpdateManyWithoutShipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    quoteResponseId?: IntFieldUpdateOperationsInput | number
    statusBefore?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    statusAfter?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransporterInvoiceUpdateWithoutShipmentInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceAmount?: FloatFieldUpdateOperationsInput | number
    invoiceUrl?: StringFieldUpdateOperationsInput | string
    approvalStatus?: StringFieldUpdateOperationsInput | string
    rejectionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    postedToErpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutTransporterInvoicesNestedInput
    approvedBy?: UserUpdateOneWithoutTransporterInvoicesNestedInput
  }

  export type TransporterInvoiceUncheckedUpdateWithoutShipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceAmount?: FloatFieldUpdateOperationsInput | number
    invoiceUrl?: StringFieldUpdateOperationsInput | string
    approvalStatus?: StringFieldUpdateOperationsInput | string
    rejectionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    postedToErpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransporterInvoiceUncheckedUpdateManyWithoutShipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceAmount?: FloatFieldUpdateOperationsInput | number
    invoiceUrl?: StringFieldUpdateOperationsInput | string
    approvalStatus?: StringFieldUpdateOperationsInput | string
    rejectionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    postedToErpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInvoiceInput = {
    id?: number
    shipmentId: number
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    gateway?: string
    transactionRef?: string | null
    authorizedAt?: Date | string | null
    capturedAt?: Date | string | null
    failureReason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tdsAmount?: number | null
    tcsAmount?: number | null
    rcmLiability?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateWithoutInvoiceInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gateway?: StringFieldUpdateOperationsInput | string
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    authorizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tdsAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    tcsAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    rcmLiability?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shipment?: ShipmentUpdateOneRequiredWithoutPaymentsNestedInput
    events?: PaymentEventUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipmentId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gateway?: StringFieldUpdateOperationsInput | string
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    authorizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tdsAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    tcsAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    rcmLiability?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: PaymentEventUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipmentId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gateway?: StringFieldUpdateOperationsInput | string
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    authorizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tdsAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    tcsAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    rcmLiability?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentEventCreateManyPaymentInput = {
    id?: number
    eventType: string
    details?: NullableJsonNullValueInput | InputJsonValue
    recordedAt?: Date | string
  }

  export type PaymentEventUpdateWithoutPaymentInput = {
    eventType?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentEventUncheckedUpdateWithoutPaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    eventType?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentEventUncheckedUpdateManyWithoutPaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    eventType?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceEventCreateManyDocumentInput = {
    id?: number
    eventType: string
    details?: NullableJsonNullValueInput | InputJsonValue
    recordedAt?: Date | string
  }

  export type ComplianceEventUpdateWithoutDocumentInput = {
    eventType?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceEventUncheckedUpdateWithoutDocumentInput = {
    id?: IntFieldUpdateOperationsInput | number
    eventType?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceEventUncheckedUpdateManyWithoutDocumentInput = {
    id?: IntFieldUpdateOperationsInput | number
    eventType?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use CompanyCountOutputTypeDefaultArgs instead
     */
    export type CompanyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VendorCountOutputTypeDefaultArgs instead
     */
    export type VendorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VendorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AgreementCountOutputTypeDefaultArgs instead
     */
    export type AgreementCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AgreementCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RateCardCountOutputTypeDefaultArgs instead
     */
    export type RateCardCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RateCardCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuoteRequestCountOutputTypeDefaultArgs instead
     */
    export type QuoteRequestCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuoteRequestCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuoteResponseCountOutputTypeDefaultArgs instead
     */
    export type QuoteResponseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuoteResponseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShipmentCountOutputTypeDefaultArgs instead
     */
    export type ShipmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShipmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceCountOutputTypeDefaultArgs instead
     */
    export type InvoiceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentCountOutputTypeDefaultArgs instead
     */
    export type PaymentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComplianceDocumentCountOutputTypeDefaultArgs instead
     */
    export type ComplianceDocumentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ComplianceDocumentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyDefaultArgs instead
     */
    export type CompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyProfileDefaultArgs instead
     */
    export type CompanyProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PasswordResetTokenDefaultArgs instead
     */
    export type PasswordResetTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PasswordResetTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TwoFactorChallengeDefaultArgs instead
     */
    export type TwoFactorChallengeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TwoFactorChallengeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserConsentDefaultArgs instead
     */
    export type UserConsentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserConsentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VendorDefaultArgs instead
     */
    export type VendorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VendorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VendorProfileDefaultArgs instead
     */
    export type VendorProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VendorProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DriverDefaultArgs instead
     */
    export type DriverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DriverDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AgreementDefaultArgs instead
     */
    export type AgreementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AgreementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RateCardDefaultArgs instead
     */
    export type RateCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RateCardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuoteRequestDefaultArgs instead
     */
    export type QuoteRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuoteRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuoteResponseDefaultArgs instead
     */
    export type QuoteResponseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuoteResponseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConsentLogDefaultArgs instead
     */
    export type ConsentLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConsentLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShipmentDefaultArgs instead
     */
    export type ShipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShipmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StatusHistoryDefaultArgs instead
     */
    export type StatusHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StatusHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceDefaultArgs instead
     */
    export type InvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentDefaultArgs instead
     */
    export type PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentEventDefaultArgs instead
     */
    export type PaymentEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransporterInvoiceDefaultArgs instead
     */
    export type TransporterInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransporterInvoiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComplianceDocumentDefaultArgs instead
     */
    export type ComplianceDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ComplianceDocumentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComplianceEventDefaultArgs instead
     */
    export type ComplianceEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ComplianceEventDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}